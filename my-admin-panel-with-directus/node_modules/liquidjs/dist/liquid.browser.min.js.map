{"version":3,"file":"liquid.browser.min.js","sources":["../src/drop/drop.ts","../src/util/underscore.ts","../src/cache/lru.ts","../src/fs/browser.ts","../src/drop/comparable.ts","../src/render/boolean.ts","../src/render/operator.ts","../src/util/character.ts","../src/util/operator-trie.ts","../src/liquid-options.ts","../src/util/error.ts","../src/fs/loader.ts","../src/context/context.ts","../src/util/assert.ts","../src/emitters/simple-emitter.ts","../src/emitters/streamed-emitter-browser.ts","../src/util/async.ts","../src/emitters/keeping-type-emitter.ts","../src/render/render.ts","../src/parser/token-kind.ts","../src/util/type-guards.ts","../src/parser/parse-stream.ts","../src/template/template-impl.ts","../src/drop/null-drop.ts","../src/drop/empty-drop.ts","../src/drop/blank-drop.ts","../src/util/literal.ts","../src/parser/parse-string-literal.ts","../src/render/expression.ts","../src/tokens/token.ts","../src/tokens/delimited-token.ts","../src/parser/whitespace-ctrl.ts","../src/tokens/number-token.ts","../src/tokens/identifier-token.ts","../src/tokens/literal-token.ts","../src/tokens/operator-token.ts","../src/tokens/property-access-token.ts","../src/tokens/filter-token.ts","../src/tokens/hash-token.ts","../src/tokens/quoted-token.ts","../src/tokens/html-token.ts","../src/tokens/range-token.ts","../src/tokens/output-token.ts","../src/parser/tokenizer.ts","../src/parser/match-operator.ts","../src/tokens/tag-token.ts","../src/template/tag/hash.ts","../src/template/filter/filter.ts","../src/parser/filter-arg.ts","../src/template/value.ts","../src/template/tag/tag.ts","../src/template/output.ts","../src/template/html.ts","../src/parser/parser.ts","../src/builtin/tags/assign.ts","../src/util/collection.ts","../src/drop/forloop-drop.ts","../src/builtin/tags/for.ts","../src/builtin/tags/capture.ts","../src/context/block-mode.ts","../src/builtin/tags/case.ts","../src/builtin/tags/comment.ts","../src/builtin/tags/render.ts","../src/builtin/tags/include.ts","../src/builtin/tags/decrement.ts","../src/builtin/tags/cycle.ts","../src/builtin/tags/if.ts","../src/builtin/tags/increment.ts","../src/builtin/tags/layout.ts","../src/drop/block-drop.ts","../src/builtin/tags/block.ts","../src/builtin/tags/raw.ts","../src/drop/tablerowloop-drop.ts","../src/builtin/tags/index.ts","../src/builtin/tags/tablerow.ts","../src/builtin/tags/unless.ts","../src/builtin/tags/break.ts","../src/builtin/tags/continue.ts","../src/builtin/filters/html.ts","../src/builtin/filters/math.ts","../src/util/strftime.ts","../src/util/timezone-date.ts","../src/builtin/filters/url.ts","../src/builtin/filters/array.ts","../src/builtin/filters/date.ts","../src/builtin/filters/object.ts","../src/builtin/filters/string.ts","../src/template/tag/tag-map.ts","../src/template/filter/filter-map.ts","../src/liquid.ts"],"sourcesContent":["export abstract class Drop {\n  public valueOf (): any {\n    return undefined\n  }\n\n  public liquidMethodMissing (key: string): Promise<string | undefined> | string | undefined {\n    return undefined\n  }\n}\n","import { Drop } from '../drop/drop'\n\nconst toStr = Object.prototype.toString\nconst toLowerCase = String.prototype.toLowerCase\n\nexport function isString (value: any): value is string {\n  return typeof value === 'string'\n}\n\nexport function isFunction (value: any): value is Function {\n  return typeof value === 'function'\n}\n\nexport function escapeRegex (str: string) {\n  return str.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n\nexport function promisify<T1, T2> (fn: (arg1: T1, cb: (err: Error | null, result: T2) => void) => void): (arg1: T1) => Promise<T2>;\nexport function promisify<T1, T2, T3> (fn: (arg1: T1, arg2: T2, cb: (err: Error | null, result: T3) => void) => void): (arg1: T1, arg2: T2) => Promise<T3>;\nexport function promisify (fn: any) {\n  return function (...args: any[]) {\n    return new Promise((resolve, reject) => {\n      fn(...args, (err: Error, result: any) => {\n        err ? reject(err) : resolve(result)\n      })\n    })\n  }\n}\n\nexport function stringify (value: any): string {\n  value = toValue(value)\n  if (isString(value)) return value\n  if (isNil(value)) return ''\n  return String(value)\n}\n\nexport function toValue (value: any): any {\n  return value instanceof Drop ? value.valueOf() : value\n}\n\nexport function isNumber (value: any): value is number {\n  return typeof value === 'number'\n}\n\nexport function toLiquid (value: any): any {\n  if (value && isFunction(value.toLiquid)) return toLiquid(value.toLiquid())\n  return value\n}\n\nexport function isNil (value: any): boolean {\n  return value == null\n}\n\nexport function isArray (value: any): value is any[] {\n  // be compatible with IE 8\n  return toStr.call(value) === '[object Array]'\n}\n\n/*\n * Iterates over own enumerable string keyed properties of an object and invokes iteratee for each property.\n * The iteratee is invoked with three arguments: (value, key, object).\n * Iteratee functions may exit iteration early by explicitly returning false.\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @return {Object} Returns object.\n */\nexport function forOwn <T> (\n  object: {[key: string]: T} | undefined,\n  iteratee: ((val: T, key: string, obj: {[key: string]: T}) => boolean | void)\n) {\n  object = object || {}\n  for (const k in object) {\n    if (object.hasOwnProperty(k)) {\n      if (iteratee(object[k], k, object) === false) break\n    }\n  }\n  return object\n}\n\nexport function last <T>(arr: T[]): T;\nexport function last (arr: string): string;\nexport function last (arr: any[] | string): any | string {\n  return arr[arr.length - 1]\n}\n\n/*\n * Checks if value is the language type of Object.\n * (e.g. arrays, functions, objects, regexes, new Number(0), and new String(''))\n * @param {any} value The value to check.\n * @return {Boolean} Returns true if value is an object, else false.\n */\nexport function isObject (value: any): value is object {\n  const type = typeof value\n  return value !== null && (type === 'object' || type === 'function')\n}\n\nexport function range (start: number, stop: number, step = 1) {\n  const arr: number[] = []\n  for (let i = start; i < stop; i += step) {\n    arr.push(i)\n  }\n  return arr\n}\n\nexport function padStart (str: any, length: number, ch = ' ') {\n  return pad(str, length, ch, (str, ch) => ch + str)\n}\n\nexport function padEnd (str: any, length: number, ch = ' ') {\n  return pad(str, length, ch, (str, ch) => str + ch)\n}\n\nexport function pad (str: any, length: number, ch: string, add: (str: string, ch: string) => string) {\n  str = String(str)\n  let n = length - str.length\n  while (n-- > 0) str = add(str, ch)\n  return str\n}\n\nexport function identify<T> (val: T): T {\n  return val\n}\n\nexport function snakeCase (str: string) {\n  return str.replace(\n    /(\\w?)([A-Z])/g,\n    (_, a, b) => (a ? a + '_' : '') + b.toLowerCase()\n  )\n}\n\nexport function changeCase (str: string): string {\n  const hasLowerCase = [...str].some(ch => ch >= 'a' && ch <= 'z')\n  return hasLowerCase ? str.toUpperCase() : str.toLowerCase()\n}\n\nexport function ellipsis (str: string, N: number): string {\n  return str.length > N ? str.substr(0, N - 3) + '...' : str\n}\n\n// compare string in case-insensitive way, undefined values to the tail\nexport function caseInsensitiveCompare (a: any, b: any) {\n  if (a == null && b == null) return 0\n  if (a == null) return 1\n  if (b == null) return -1\n  a = toLowerCase.call(a)\n  b = toLowerCase.call(b)\n  if (a < b) return -1\n  if (a > b) return 1\n  return 0\n}\n","import { Cache } from './cache'\n\nclass Node<T> {\n  constructor (\n    public key: string,\n    public value: T,\n    public next: Node<T>,\n    public prev: Node<T>\n  ) {}\n}\n\nexport class LRU<T> implements Cache<T> {\n  private cache: { [key: string]: Node<T> } = {}\n  private head: Node<T>\n  private tail: Node<T>\n\n  constructor (\n    public limit: number,\n    public size = 0\n  ) {\n    this.head = new Node<T>('HEAD', null as any, null as any, null as any)\n    this.tail = new Node<T>('TAIL', null as any, null as any, null as any)\n    this.head.next = this.tail\n    this.tail.prev = this.head\n  }\n\n  write (key: string, value: T) {\n    if (this.cache[key]) {\n      this.cache[key].value = value\n    } else {\n      const node = new Node(key, value, this.head.next, this.head)\n      this.head.next.prev = node\n      this.head.next = node\n\n      this.cache[key] = node\n      this.size++\n      this.ensureLimit()\n    }\n  }\n\n  read (key: string): T | undefined {\n    if (!this.cache[key]) return\n    const { value } = this.cache[key]\n    this.remove(key)\n    this.write(key, value)\n    return value\n  }\n\n  remove (key: string) {\n    const node = this.cache[key]\n    node.prev.next = node.next\n    node.next.prev = node.prev\n    delete this.cache[key]\n    this.size--\n  }\n\n  clear () {\n    this.head.next = this.tail\n    this.tail.prev = this.head\n    this.size = 0\n    this.cache = {}\n  }\n\n  private ensureLimit () {\n    if (this.size > this.limit) this.remove(this.tail.prev.key)\n  }\n}\n","import { last } from '../util/underscore'\n\nfunction domResolve (root: string, path: string) {\n  const base = document.createElement('base')\n  base.href = root\n\n  const head = document.getElementsByTagName('head')[0]\n  head.insertBefore(base, head.firstChild)\n\n  const a = document.createElement('a')\n  a.href = path\n  const resolved = a.href\n  head.removeChild(base)\n\n  return resolved\n}\n\nexport function resolve (root: string, filepath: string, ext: string) {\n  if (root.length && last(root) !== '/') root += '/'\n  const url = domResolve(root, filepath)\n  return url.replace(/^(\\w+:\\/\\/[^/]+)(\\/[^?]+)/, (str, origin, path) => {\n    const last = path.split('/').pop()\n    if (/\\.\\w+$/.test(last)) return str\n    return origin + path + ext\n  })\n}\n\nexport async function readFile (url: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest()\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText as string)\n      } else {\n        reject(new Error(xhr.statusText))\n      }\n    }\n    xhr.onerror = () => {\n      reject(new Error('An error occurred whilst receiving the response.'))\n    }\n    xhr.open('GET', url)\n    xhr.send()\n  })\n}\n\nexport function readFileSync (url: string): string {\n  const xhr = new XMLHttpRequest()\n  xhr.open('GET', url, false)\n  xhr.send()\n  if (xhr.status < 200 || xhr.status >= 300) {\n    throw new Error(xhr.statusText)\n  }\n  return xhr.responseText as string\n}\n\nexport async function exists (filepath: string) {\n  return true\n}\n\nexport function existsSync (filepath: string) {\n  return true\n}\n\nexport function dirname (filepath: string) {\n  return domResolve(filepath, '.')\n}\n\nexport const sep = '/'\n","import { isFunction } from '../util/underscore'\n\nexport interface Comparable {\n  equals: (rhs: any) => boolean;\n  gt: (rhs: any) => boolean;\n  geq: (rhs: any) => boolean;\n  lt: (rhs: any) => boolean;\n  leq: (rhs: any) => boolean;\n}\n\nexport function isComparable (arg: any): arg is Comparable {\n  return arg && isFunction(arg.equals)\n}\n","import { Context } from '../context/context'\n\nexport function isTruthy (val: any, ctx: Context): boolean {\n  return !isFalsy(val, ctx)\n}\n\nexport function isFalsy (val: any, ctx: Context): boolean {\n  if (ctx.opts.jsTruthy) {\n    return !val\n  } else {\n    return val === false || undefined === val || val === null\n  }\n}\n","import { isComparable } from '../drop/comparable'\nimport { Context } from '../context/context'\nimport { isFunction } from '../util/underscore'\nimport { isTruthy } from '../render/boolean'\n\nexport interface Operators {\n  [key: string]: (lhs: any, rhs: any, ctx: Context) => boolean;\n}\n\nexport const defaultOperators: Operators = {\n  '==': (l: any, r: any) => {\n    if (isComparable(l)) return l.equals(r)\n    if (isComparable(r)) return r.equals(l)\n    return l === r\n  },\n  '!=': (l: any, r: any) => {\n    if (isComparable(l)) return !l.equals(r)\n    if (isComparable(r)) return !r.equals(l)\n    return l !== r\n  },\n  '>': (l: any, r: any) => {\n    if (isComparable(l)) return l.gt(r)\n    if (isComparable(r)) return r.lt(l)\n    return l > r\n  },\n  '<': (l: any, r: any) => {\n    if (isComparable(l)) return l.lt(r)\n    if (isComparable(r)) return r.gt(l)\n    return l < r\n  },\n  '>=': (l: any, r: any) => {\n    if (isComparable(l)) return l.geq(r)\n    if (isComparable(r)) return r.leq(l)\n    return l >= r\n  },\n  '<=': (l: any, r: any) => {\n    if (isComparable(l)) return l.leq(r)\n    if (isComparable(r)) return r.geq(l)\n    return l <= r\n  },\n  'contains': (l: any, r: any) => {\n    return l && isFunction(l.indexOf) ? l.indexOf(r) > -1 : false\n  },\n  'and': (l: any, r: any, ctx: Context) => isTruthy(l, ctx) && isTruthy(r, ctx),\n  'or': (l: any, r: any, ctx: Context) => isTruthy(l, ctx) || isTruthy(r, ctx)\n}\n","// **DO NOT CHANGE THIS FILE**\n//\n// This file is generated by bin/character-gen.js\n// bitmask character types to boost performance\nexport const TYPES = [0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 4, 4, 4, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 8, 0, 0, 0, 0, 8, 0, 0, 0, 64, 0, 65, 0, 0, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 0, 0, 2, 2, 2, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]\nexport const IDENTIFIER = 1\nexport const OPERATOR = 2\nexport const BLANK = 4\nexport const QUOTE = 8\nexport const INLINE_BLANK = 16\nexport const NUMBER = 32\nexport const SIGN = 64\nTYPES[160] = TYPES[5760] = TYPES[6158] = TYPES[8192] = TYPES[8193] = TYPES[8194] = TYPES[8195] = TYPES[8196] = TYPES[8197] = TYPES[8198] = TYPES[8199] = TYPES[8200] = TYPES[8201] = TYPES[8202] = TYPES[8232] = TYPES[8233] = TYPES[8239] = TYPES[8287] = TYPES[12288] = BLANK\n","import { Operators } from '../render/operator'\nimport { IDENTIFIER, TYPES } from '../util/character'\n\nexport interface Trie {\n  [key: string]: any;\n}\n\nexport function createTrie (operators: Operators): Trie {\n  const trie: Trie = {}\n  for (const [name, handler] of Object.entries(operators)) {\n    let node = trie\n\n    for (let i = 0; i < name.length; i++) {\n      const c = name[i]\n      node[c] = node[c] || {}\n\n      if (i === name.length - 1 && (TYPES[name.charCodeAt(i)] & IDENTIFIER)) {\n        node[c].needBoundary = true\n      }\n\n      node = node[c]\n    }\n\n    node.handler = handler\n    node.end = true\n  }\n  return trie\n}\n","import * as _ from './util/underscore'\nimport { Template } from './template/template'\nimport { Cache } from './cache/cache'\nimport { LRU } from './cache/lru'\nimport { FS } from './fs/fs'\nimport * as fs from './fs/node'\nimport { defaultOperators, Operators } from './render/operator'\nimport { createTrie, Trie } from './util/operator-trie'\nimport { Thenable } from './util/async'\n\nexport interface LiquidOptions {\n  /** A directory or an array of directories from where to resolve layout and include templates, and the filename passed to `.renderFile()`. If it's an array, the files are looked up in the order they occur in the array. Defaults to `[\".\"]` */\n  root?: string | string[];\n  /** A directory or an array of directories from where to resolve included templates. If it's an array, the files are looked up in the order they occur in the array. Defaults to `root` */\n  partials?: string | string[];\n  /** A directory or an array of directories from where to resolve layout templates. If it's an array, the files are looked up in the order they occur in the array. Defaults to `root` */\n  layouts?: string | string[];\n  /** Allow refer to layouts/partials by relative pathname. To avoid arbitrary filesystem read, paths been referenced also need to be within corresponding root, partials, layouts. Defaults to `true`. */\n  relativeReference?: boolean;\n  /** Add a extname (if filepath doesn't include one) before template file lookup. Eg: setting to `\".html\"` will allow including file by basename. Defaults to `\"\"`. */\n  extname?: string;\n  /** Whether or not to cache resolved templates. Defaults to `false`. */\n  cache?: boolean | number | Cache<Thenable<Template[]>>;\n  /** Use Javascript Truthiness. Defaults to `false`. */\n  jsTruthy?: boolean;\n  /** If set, treat the `filepath` parameter in `{%include filepath %}` and `{%layout filepath%}` as a variable, otherwise as a literal value. Defaults to `true`. */\n  dynamicPartials?: boolean;\n  /** Whether or not to assert filter existence. If set to `false`, undefined filters will be skipped. Otherwise, undefined filters will cause an exception. Defaults to `false`. */\n  strictFilters?: boolean;\n  /** Whether or not to assert variable existence.  If set to `false`, undefined variables will be rendered as empty string.  Otherwise, undefined variables will cause an exception. Defaults to `false`. */\n  strictVariables?: boolean;\n  /** Modifies the behavior of `strictVariables`. If set, a single undefined variable will *not* cause an exception in the context of the `if`/`elsif`/`unless` tag and the `default` filter. Instead, it will evaluate to `false` and `null`, respectively. Irrelevant if `strictVariables` is not set. Defaults to `false`. **/\n  lenientIf?: boolean;\n  /** JavaScript timezoneOffset for `date` filter, default to local time. That means if you're in Australia (UTC+10), it'll default to -600 */\n  timezoneOffset?: number;\n  /** Strip blank characters (including ` `, `\\t`, and `\\r`) from the right of tags (`{% %}`) until `\\n` (inclusive). Defaults to `false`. */\n  trimTagRight?: boolean;\n  /** Similar to `trimTagRight`, whereas the `\\n` is exclusive. Defaults to `false`. See Whitespace Control for details. */\n  trimTagLeft?: boolean;\n  /** Strip blank characters (including ` `, `\\t`, and `\\r`) from the right of values (`{{ }}`) until `\\n` (inclusive). Defaults to `false`. */\n  trimOutputRight?: boolean;\n  /** Similar to `trimOutputRight`, whereas the `\\n` is exclusive. Defaults to `false`. See Whitespace Control for details. */\n  trimOutputLeft?: boolean;\n  /** The left delimiter for liquid tags. **/\n  tagDelimiterLeft?: string;\n  /** The right delimiter for liquid tags. **/\n  tagDelimiterRight?: string;\n  /** The left delimiter for liquid outputs. **/\n  outputDelimiterLeft?: string;\n  /** The right delimiter for liquid outputs. **/\n  outputDelimiterRight?: string;\n  /** Whether input strings to date filter preserve the given timezone **/\n  preserveTimezones?: boolean;\n  /** Whether `trim*Left`/`trim*Right` is greedy. When set to `true`, all consecutive blank characters including `\\n` will be trimed regardless of line breaks. Defaults to `true`. */\n  greedy?: boolean;\n  /** `fs` is used to override the default file-system module with a custom implementation. */\n  fs?: FS;\n  /** the global environment passed down to all partial templates, i.e. templates included by `include`, `layout` and `render` tags. */\n  globals?: object;\n  /** Whether or not to keep value type when writing the Output, not working for streamed rendering. Defaults to `false`. */\n  keepOutputType?: boolean;\n  /** An object of operators for conditional statements. Defaults to the regular Liquid operators. */\n  operators?: Operators;\n  /** Respect parameter order when using filters like \"for ... reversed limit\", Defaults to `false`. */\n  orderedFilterParameters?: boolean;\n}\n\ninterface NormalizedOptions extends LiquidOptions {\n  root?: string[];\n  partials?: string[];\n  layouts?: string[];\n  cache?: Cache<Thenable<Template[]>>;\n  operatorsTrie?: Trie;\n}\n\nexport interface NormalizedFullOptions extends NormalizedOptions {\n  root: string[];\n  partials: string[];\n  layouts: string[];\n  relativeReference: boolean;\n  extname: string;\n  cache: undefined | Cache<Thenable<Template[]>>;\n  jsTruthy: boolean;\n  dynamicPartials: boolean;\n  fs: FS;\n  strictFilters: boolean;\n  strictVariables: boolean;\n  lenientIf: boolean;\n  trimTagRight: boolean;\n  trimTagLeft: boolean;\n  trimOutputRight: boolean;\n  trimOutputLeft: boolean;\n  tagDelimiterLeft: string;\n  tagDelimiterRight: string;\n  outputDelimiterLeft: string;\n  outputDelimiterRight: string;\n  preserveTimezones: boolean;\n  greedy: boolean;\n  globals: object;\n  keepOutputType: boolean;\n  operators: Operators;\n  operatorsTrie: Trie;\n}\n\nexport const defaultOptions: NormalizedFullOptions = {\n  root: ['.'],\n  layouts: ['.'],\n  partials: ['.'],\n  relativeReference: true,\n  cache: undefined,\n  extname: '',\n  fs: fs,\n  dynamicPartials: true,\n  jsTruthy: false,\n  trimTagRight: false,\n  trimTagLeft: false,\n  trimOutputRight: false,\n  trimOutputLeft: false,\n  greedy: true,\n  tagDelimiterLeft: '{%',\n  tagDelimiterRight: '%}',\n  outputDelimiterLeft: '{{',\n  outputDelimiterRight: '}}',\n  preserveTimezones: false,\n  strictFilters: false,\n  strictVariables: false,\n  lenientIf: false,\n  globals: {},\n  keepOutputType: false,\n  operators: defaultOperators,\n  operatorsTrie: createTrie(defaultOperators)\n}\n\nexport function normalize (options?: LiquidOptions): NormalizedOptions {\n  options = options || {}\n  if (options.hasOwnProperty('root')) {\n    options.root = normalizeDirectoryList(options.root)\n  }\n  if (options.hasOwnProperty('partials')) {\n    options.partials = normalizeDirectoryList(options.partials)\n  }\n  if (options.hasOwnProperty('layouts')) {\n    options.layouts = normalizeDirectoryList(options.layouts)\n  }\n  if (options.hasOwnProperty('cache')) {\n    let cache: Cache<Thenable<Template[]>> | undefined\n    if (typeof options.cache === 'number') cache = options.cache > 0 ? new LRU(options.cache) : undefined\n    else if (typeof options.cache === 'object') cache = options.cache\n    else cache = options.cache ? new LRU(1024) : undefined\n    options.cache = cache\n  }\n  if (options.hasOwnProperty('operators')) {\n    (options as NormalizedOptions).operatorsTrie = createTrie(options.operators!)\n  }\n  return options as NormalizedOptions\n}\n\nexport function applyDefault (options: NormalizedOptions): NormalizedFullOptions {\n  const fullOptions = { ...defaultOptions, ...options }\n  if (fullOptions.partials === defaultOptions.partials) {\n    fullOptions.partials = fullOptions.root\n  }\n  if (fullOptions.layouts === defaultOptions.layouts) {\n    fullOptions.layouts = fullOptions.root\n  }\n  return fullOptions\n}\n\nexport function normalizeDirectoryList (value: any): string[] {\n  let list: string[] = []\n  if (_.isArray(value)) list = value\n  if (_.isString(value)) list = [value]\n  return list\n}\n","import * as _ from './underscore'\nimport { Token } from '../tokens/token'\nimport { Template } from '../template/template'\n\nexport abstract class LiquidError extends Error {\n  private token: Token\n  public context: string\n  private originalError: Error\n  public constructor (err: Error, token: Token) {\n    super(err.message)\n    this.originalError = err\n    this.token = token\n    this.context = ''\n  }\n  protected update () {\n    const err = this.originalError\n    this.context = mkContext(this.token)\n    this.message = mkMessage(err.message, this.token)\n    this.stack = this.message + '\\n' + this.context +\n      '\\n' + this.stack + '\\nFrom ' + err.stack\n  }\n}\n\nexport class TokenizationError extends LiquidError {\n  public constructor (message: string, token: Token) {\n    super(new Error(message), token)\n    this.name = 'TokenizationError'\n    super.update()\n  }\n}\n\nexport class ParseError extends LiquidError {\n  public constructor (err: Error, token: Token) {\n    super(err, token)\n    this.name = 'ParseError'\n    this.message = err.message\n    super.update()\n  }\n}\n\nexport class RenderError extends LiquidError {\n  public constructor (err: Error, tpl: Template) {\n    super(err, tpl.token)\n    this.name = 'RenderError'\n    this.message = err.message\n    super.update()\n  }\n  public static is (obj: any): obj is RenderError {\n    return obj.name === 'RenderError'\n  }\n}\n\nexport class UndefinedVariableError extends LiquidError {\n  public constructor (err: Error, token: Token) {\n    super(err, token)\n    this.name = 'UndefinedVariableError'\n    this.message = err.message\n    super.update()\n  }\n}\n\n// only used internally; raised where we don't have token information,\n// so it can't be an UndefinedVariableError.\nexport class InternalUndefinedVariableError extends Error {\n  variableName: string\n\n  public constructor (variableName: string) {\n    super(`undefined variable: ${variableName}`)\n    this.name = 'InternalUndefinedVariableError'\n    this.variableName = variableName\n  }\n}\n\nexport class AssertionError extends Error {\n  public constructor (message: string) {\n    super(message)\n    this.name = 'AssertionError'\n    this.message = message + ''\n  }\n}\n\nfunction mkContext (token: Token) {\n  const [line] = token.getPosition()\n  const lines = token.input.split('\\n')\n  const begin = Math.max(line - 2, 1)\n  const end = Math.min(line + 3, lines.length)\n\n  const context = _\n    .range(begin, end + 1)\n    .map(lineNumber => {\n      const indicator = (lineNumber === line) ? '>> ' : '   '\n      const num = _.padStart(String(lineNumber), String(end).length)\n      const text = lines[lineNumber - 1]\n      return `${indicator}${num}| ${text}`\n    })\n    .join('\\n')\n\n  return context\n}\n\nfunction mkMessage (msg: string, token: Token) {\n  if (token.file) msg += `, file:${token.file}`\n  const [line, col] = token.getPosition()\n  msg += `, line:${line}, col:${col}`\n  return msg\n}\n","import { FS } from './fs'\nimport { escapeRegex } from '../util/underscore'\nimport { assert } from '../util/assert'\n\nexport interface LoaderOptions {\n  fs: FS;\n  extname: string;\n  root: string[];\n  partials: string[];\n  layouts: string[];\n  relativeReference: boolean;\n}\nexport enum LookupType {\n  Partials = 'partials',\n  Layouts = 'layouts',\n  Root = 'root'\n}\nexport class Loader {\n  private options: LoaderOptions\n  private sep: string\n  private rRelativePath: RegExp\n\n  constructor (options: LoaderOptions) {\n    this.options = options\n    this.sep = this.options.fs.sep || '/'\n    this.rRelativePath = new RegExp(['.' + this.sep, '..' + this.sep].map(prefix => escapeRegex(prefix)).join('|'))\n  }\n\n  public * lookup (file: string, type: LookupType, sync?: boolean, currentFile?: string) {\n    const { fs } = this.options\n    const dirs = this.options[type]\n    for (const filepath of this.candidates(file, dirs, currentFile, type !== LookupType.Root)) {\n      if (sync ? fs.existsSync(filepath) : yield fs.exists(filepath)) return filepath\n    }\n    throw this.lookupError(file, dirs)\n  }\n\n  public shouldLoadRelative (referencedFile: string) {\n    return this.options.relativeReference && this.rRelativePath.test(referencedFile)\n  }\n\n  public * candidates (file: string, dirs: string[], currentFile?: string, enforceRoot?: boolean) {\n    const { fs, extname } = this.options\n    if (this.shouldLoadRelative(file) && currentFile) {\n      const referenced = fs.resolve(this.dirname(currentFile), file, extname)\n      for (const dir of dirs) {\n        if (!enforceRoot || this.withinDir(referenced, dir)) {\n          // the relatively referenced file is within one of root dirs\n          yield referenced\n          break\n        }\n      }\n    }\n    for (const dir of dirs) {\n      const referenced = fs.resolve(dir, file, extname)\n      if (!enforceRoot || this.withinDir(referenced, dir)) {\n        yield referenced\n      }\n    }\n    if (fs.fallback !== undefined) {\n      const filepath = fs.fallback(file)\n      if (filepath !== undefined) yield filepath\n    }\n  }\n\n  private withinDir (file: string, dir: string) {\n    dir = dir.endsWith(this.sep) ? dir : dir + this.sep\n    return file.startsWith(dir)\n  }\n\n  private dirname (path: string) {\n    const fs = this.options.fs\n    assert(fs.dirname, '`fs.dirname` is required for relative reference')\n    return fs.dirname!(path)\n  }\n\n  private lookupError (file: string, roots: string[]) {\n    const err = new Error('ENOENT') as any\n    err.message = `ENOENT: Failed to lookup \"${file}\" in \"${roots}\"`\n    err.code = 'ENOENT'\n    return err\n  }\n}\n","import { Drop } from '../drop/drop'\nimport { __assign } from 'tslib'\nimport { NormalizedFullOptions, defaultOptions } from '../liquid-options'\nimport { Scope } from './scope'\nimport { isArray, isNil, isString, isFunction, toLiquid } from '../util/underscore'\nimport { InternalUndefinedVariableError } from '../util/error'\n\nexport class Context {\n  private scopes: Scope[] = [{}]\n  private registers = {}\n  public environments: Scope\n  public globals: Scope\n  public sync: boolean\n  public opts: NormalizedFullOptions\n  public constructor (env: object = {}, opts: NormalizedFullOptions = defaultOptions, sync = false) {\n    this.sync = sync\n    this.opts = opts\n    this.globals = opts.globals\n    this.environments = env\n  }\n  public getRegister (key: string) {\n    return (this.registers[key] = this.registers[key] || {})\n  }\n  public setRegister (key: string, value: any) {\n    return (this.registers[key] = value)\n  }\n  public saveRegister (...keys: string[]): [string, any][] {\n    return keys.map(key => [key, this.getRegister(key)])\n  }\n  public restoreRegister (keyValues: [string, any][]) {\n    return keyValues.forEach(([key, value]) => this.setRegister(key, value))\n  }\n  public getAll () {\n    return [this.globals, this.environments, ...this.scopes]\n      .reduce((ctx, val) => __assign(ctx, val), {})\n  }\n  public get (paths: string[]) {\n    const scope = this.findScope(paths[0])\n    return this.getFromScope(scope, paths)\n  }\n  public getFromScope (scope: object, paths: string[] | string) {\n    if (typeof paths === 'string') paths = paths.split('.')\n    return paths.reduce((scope, path) => {\n      scope = readProperty(scope, path)\n      if (isNil(scope) && this.opts.strictVariables) {\n        throw new InternalUndefinedVariableError(path)\n      }\n      return scope\n    }, scope)\n  }\n  public push (ctx: object) {\n    return this.scopes.push(ctx)\n  }\n  public pop () {\n    return this.scopes.pop()\n  }\n  public bottom () {\n    return this.scopes[0]\n  }\n  private findScope (key: string) {\n    for (let i = this.scopes.length - 1; i >= 0; i--) {\n      const candidate = this.scopes[i]\n      if (key in candidate) return candidate\n    }\n    if (key in this.environments) return this.environments\n    return this.globals\n  }\n}\n\nexport function readProperty (obj: Scope, key: string) {\n  if (isNil(obj)) return obj\n  obj = toLiquid(obj)\n  if (isFunction(obj[key])) return obj[key]()\n  if (obj instanceof Drop) {\n    if (obj.hasOwnProperty(key)) return obj[key]\n    return obj.liquidMethodMissing(key)\n  }\n  if (key === 'size') return readSize(obj)\n  if (key === 'first') return readFirst(obj)\n  if (key === 'last') return readLast(obj)\n  return obj[key]\n}\n\nfunction readFirst (obj: Scope) {\n  if (isArray(obj)) return obj[0]\n  return obj['first']\n}\n\nfunction readLast (obj: Scope) {\n  if (isArray(obj)) return obj[obj.length - 1]\n  return obj['last']\n}\n\nfunction readSize (obj: Scope) {\n  if (isArray(obj) || isString(obj)) return obj.length\n  return obj['size']\n}\n","import { AssertionError } from './error'\n\nexport function assert <T> (predicate: T | null | undefined, message?: string | (() => string)) {\n  if (!predicate) {\n    const msg = typeof message === 'function'\n      ? message()\n      : (message || `expect ${predicate} to be true`)\n    throw new AssertionError(msg)\n  }\n}\n","import { stringify } from '../util/underscore'\nimport { Emitter } from './emitter'\n\nexport class SimpleEmitter implements Emitter {\n  public buffer = '';\n\n  public write (html: any) {\n    this.buffer += stringify(html)\n  }\n}\n","import { Emitter } from './emitter'\n\nexport class StreamedEmitter implements Emitter {\n  public buffer = '';\n  public stream: NodeJS.ReadableStream = null as any\n  constructor () {\n    throw new Error('streaming not supported in browser')\n  }\n  public write: (html: any) => void\n  public error: (err: Error) => void\n  public end: () => void\n}\n","import { isFunction } from './underscore'\n\ntype resolver = (x?: any) => any\n\nexport interface Thenable<T> {\n  then (resolve: resolver, reject?: resolver): Thenable<T>;\n  catch (reject: resolver): Thenable<T>;\n}\n\nfunction createResolvedThenable<T> (value: T): Thenable<T> {\n  const ret = {\n    then: (resolve: resolver) => resolve(value),\n    catch: () => ret\n  }\n  return ret\n}\n\nfunction createRejectedThenable<T> (err: Error): Thenable<T> {\n  const ret = {\n    then: (resolve: resolver, reject?: resolver) => {\n      if (reject) return reject(err)\n      return ret\n    },\n    catch: (reject: resolver) => reject(err)\n  }\n  return ret\n}\n\nfunction isThenable<T> (val: any): val is Thenable<T> {\n  return val && isFunction(val.then)\n}\n\nfunction isAsyncIterator (val: any): val is IterableIterator<any> {\n  return val && isFunction(val.next) && isFunction(val.throw) && isFunction(val.return)\n}\n\ntype Task<T> = Thenable<T>\n\n// convert an async iterator to a thenable (Promise compatible)\nexport function toThenable<T> (val: IterableIterator<any> | Thenable<T> | any): Thenable<T> {\n  if (isThenable(val)) return val\n  if (isAsyncIterator(val)) return reduce()\n  return createResolvedThenable(val)\n\n  function reduce<T> (prev?: T): Thenable<T> {\n    let state\n    try {\n      state = (val as IterableIterator<any>).next(prev)\n    } catch (err) {\n      return createRejectedThenable(err)\n    }\n\n    if (state.done) return createResolvedThenable(state.value)\n    return toThenable(state.value!).then(reduce, err => {\n      let state\n      try {\n        state = (val as IterableIterator<any>).throw!(err)\n      } catch (e) {\n        return createRejectedThenable(e)\n      }\n      if (state.done) return createResolvedThenable(state.value)\n      return reduce(state.value)\n    })\n  }\n}\n\nexport function toPromise<T> (val: IterableIterator<any> | Thenable<T> | T): Promise<T> {\n  return Promise.resolve(toThenable(val))\n}\n\n// get the value of async iterator in synchronous manner\nexport function toValue<T> (val: IterableIterator<any> | Thenable<T> | T): T {\n  let ret: T\n  toThenable(val)\n    .then((x: any) => {\n      ret = x\n      return createResolvedThenable(ret)\n    })\n    .catch((err: Error) => {\n      throw err\n    })\n  return ret!\n}\n","import { stringify, toValue } from '../util/underscore'\nimport { Emitter } from '../types'\n\nexport class KeepingTypeEmitter implements Emitter {\n  public buffer: any = '';\n\n  public write (html: any) {\n    html = toValue(html)\n    // This will only preserve the type if the value is isolated.\n    // I.E:\n    // {{ my-port }} -> 42\n    // {{ my-host }}:{{ my-port }} -> 'host:42'\n    if (typeof html !== 'string' && this.buffer === '') {\n      this.buffer = html\n    } else {\n      this.buffer = stringify(this.buffer) + stringify(html)\n    }\n  }\n}\n","import { RenderError } from '../util/error'\nimport { Context } from '../context/context'\nimport { Template } from '../template/template'\nimport { Emitter } from '../emitters/emitter'\nimport { SimpleEmitter } from '../emitters/simple-emitter'\nimport { StreamedEmitter } from '../emitters/streamed-emitter'\nimport { toThenable } from '../util/async'\nimport { KeepingTypeEmitter } from '../emitters/keeping-type-emitter'\n\nexport class Render {\n  public renderTemplatesToNodeStream (templates: Template[], ctx: Context): NodeJS.ReadableStream {\n    const emitter = new StreamedEmitter()\n    Promise.resolve().then(() => toThenable(this.renderTemplates(templates, ctx, emitter)))\n      .then(() => emitter.end(), err => emitter.error(err))\n    return emitter.stream\n  }\n  public * renderTemplates (templates: Template[], ctx: Context, emitter?: Emitter): IterableIterator<any> {\n    if (!emitter) {\n      emitter = ctx.opts.keepOutputType ? new KeepingTypeEmitter() : new SimpleEmitter()\n    }\n    for (const tpl of templates) {\n      try {\n        // if tpl.render supports emitter, it'll return empty `html`\n        const html = yield tpl.render(ctx, emitter)\n        // if not, it'll return an `html`, write to the emitter for it\n        html && emitter.write(html)\n        if (emitter['break'] || emitter['continue']) break\n      } catch (e) {\n        const err = RenderError.is(e) ? e : new RenderError(e, tpl)\n        throw err\n      }\n    }\n    return emitter.buffer\n  }\n}\n","export enum TokenKind {\n  Number = 1,\n  Literal = 2,\n  Tag = 4,\n  Output = 8,\n  HTML = 16,\n  Filter = 32,\n  Hash = 64,\n  PropertyAccess = 128,\n  Word = 256,\n  Range = 512,\n  Quoted = 1024,\n  Operator = 2048,\n  Delimited = Tag | Output\n}\n","import { OperatorToken } from '../tokens/operator-token'\nimport { DelimitedToken } from '../tokens/delimited-token'\nimport { IdentifierToken } from '../tokens/identifier-token'\nimport { TagToken } from '../tokens/tag-token'\nimport { HTMLToken } from '../tokens/html-token'\nimport { OutputToken } from '../tokens/output-token'\nimport { PropertyAccessToken } from '../tokens/property-access-token'\nimport { LiteralToken } from '../tokens/literal-token'\nimport { QuotedToken } from '../tokens/quoted-token'\nimport { NumberToken } from '../tokens/number-token'\nimport { RangeToken } from '../tokens/range-token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport function isDelimitedToken (val: any): val is DelimitedToken {\n  return !!(getKind(val) & TokenKind.Delimited)\n}\n\nexport function isOperatorToken (val: any): val is OperatorToken {\n  return getKind(val) === TokenKind.Operator\n}\n\nexport function isHTMLToken (val: any): val is HTMLToken {\n  return getKind(val) === TokenKind.HTML\n}\n\nexport function isOutputToken (val: any): val is OutputToken {\n  return getKind(val) === TokenKind.Output\n}\n\nexport function isTagToken (val: any): val is TagToken {\n  return getKind(val) === TokenKind.Tag\n}\n\nexport function isQuotedToken (val: any): val is QuotedToken {\n  return getKind(val) === TokenKind.Quoted\n}\n\nexport function isLiteralToken (val: any): val is LiteralToken {\n  return getKind(val) === TokenKind.Literal\n}\n\nexport function isNumberToken (val: any): val is NumberToken {\n  return getKind(val) === TokenKind.Number\n}\n\nexport function isPropertyAccessToken (val: any): val is PropertyAccessToken {\n  return getKind(val) === TokenKind.PropertyAccess\n}\n\nexport function isWordToken (val: any): val is IdentifierToken {\n  return getKind(val) === TokenKind.Word\n}\n\nexport function isRangeToken (val: any): val is RangeToken {\n  return getKind(val) === TokenKind.Range\n}\n\nfunction getKind (val: any) {\n  return val ? val.kind : -1\n}\n","import { Token } from '../tokens/token'\nimport { Template } from '../template/template'\nimport { isTagToken } from '../util/type-guards'\nimport { TopLevelToken } from '../tokens/toplevel-token'\n\ntype ParseToken<T extends Token> = ((token: T, remainTokens: T[]) => Template)\n\nexport class ParseStream<T extends Token = TopLevelToken> {\n  private tokens: T[]\n  private handlers: {[key: string]: (arg: any) => void} = {}\n  private stopRequested = false\n  private parseToken: ParseToken<T>\n\n  public constructor (tokens: T[], parseToken: ParseToken<T>) {\n    this.tokens = tokens\n    this.parseToken = parseToken\n  }\n  public on<T2 extends Template | T | undefined> (name: string, cb: (this: ParseStream, arg: T2) => void): ParseStream<T> {\n    this.handlers[name] = cb\n    return this\n  }\n  private trigger <T extends Token | Template> (event: string, arg?: T) {\n    const h = this.handlers[event]\n    return h ? (h.call(this, arg), true) : false\n  }\n  public start () {\n    this.trigger('start')\n    let token: T | undefined\n    while (!this.stopRequested && (token = this.tokens.shift())) {\n      if (this.trigger('token', token)) continue\n      if (isTagToken(token) && this.trigger(`tag:${token.name}`, token)) {\n        continue\n      }\n      const template = this.parseToken(token, this.tokens)\n      this.trigger('template', template)\n    }\n    if (!this.stopRequested) this.trigger('end')\n    return this\n  }\n  public stop () {\n    this.stopRequested = true\n    return this\n  }\n}\n","export abstract class TemplateImpl<T> {\n  public token: T;\n  public constructor (token: T) {\n    this.token = token\n  }\n}\n","import { Drop } from './drop'\nimport { Comparable } from './comparable'\nimport { isNil, toValue } from '../util/underscore'\n\nexport class NullDrop extends Drop implements Comparable {\n  public equals (value: any) {\n    return isNil(toValue(value))\n  }\n  public gt () {\n    return false\n  }\n  public geq () {\n    return false\n  }\n  public lt () {\n    return false\n  }\n  public leq () {\n    return false\n  }\n  public valueOf () {\n    return null\n  }\n}\n","import { Drop } from './drop'\nimport { Comparable } from './comparable'\nimport { isObject, isString, isArray, toValue } from '../util/underscore'\n\nexport class EmptyDrop extends Drop implements Comparable {\n  public equals (value: any) {\n    if (value instanceof EmptyDrop) return false\n    value = toValue(value)\n    if (isString(value) || isArray(value)) return value.length === 0\n    if (isObject(value)) return Object.keys(value).length === 0\n    return false\n  }\n  public gt () {\n    return false\n  }\n  public geq () {\n    return false\n  }\n  public lt () {\n    return false\n  }\n  public leq () {\n    return false\n  }\n  public valueOf () {\n    return ''\n  }\n}\n","import { isNil, isString, toValue } from '../util/underscore'\nimport { EmptyDrop } from '../drop/empty-drop'\n\nexport class BlankDrop extends EmptyDrop {\n  public equals (value: any) {\n    if (value === false) return true\n    if (isNil(toValue(value))) return true\n    if (isString(value)) return /^\\s*$/.test(value)\n    return super.equals(value)\n  }\n}\n","import { NullDrop } from '../drop/null-drop'\nimport { EmptyDrop } from '../drop/empty-drop'\nimport { BlankDrop } from '../drop/blank-drop'\n\nconst nil = new NullDrop()\nexport const literalValues = {\n  'true': true,\n  'false': false,\n  'nil': nil,\n  'null': nil,\n  'empty': new EmptyDrop(),\n  'blank': new BlankDrop()\n}\n","const rHex = /[\\da-fA-F]/\nconst rOct = /[0-7]/\nconst escapeChar = {\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n  v: '\\x0B'\n}\n\nfunction hexVal (c: string) {\n  const code = c.charCodeAt(0)\n  if (code >= 97) return code - 87\n  if (code >= 65) return code - 55\n  return code - 48\n}\n\nexport function parseStringLiteral (str: string): string {\n  let ret = ''\n  for (let i = 1; i < str.length - 1; i++) {\n    if (str[i] !== '\\\\') {\n      ret += str[i]\n      continue\n    }\n    if (escapeChar[str[i + 1]] !== undefined) {\n      ret += escapeChar[str[++i]]\n    } else if (str[i + 1] === 'u') {\n      let val = 0\n      let j = i + 2\n      while (j <= i + 5 && rHex.test(str[j])) {\n        val = val * 16 + hexVal(str[j++])\n      }\n      i = j - 1\n      ret += String.fromCharCode(val)\n    } else if (!rOct.test(str[i + 1])) {\n      ret += str[++i]\n    } else {\n      let j = i + 1\n      let val = 0\n      while (j <= i + 3 && rOct.test(str[j])) {\n        val = val * 8 + hexVal(str[j++])\n      }\n      i = j - 1\n      ret += String.fromCharCode(val)\n    }\n  }\n  return ret\n}\n","import { QuotedToken } from '../tokens/quoted-token'\nimport { PropertyAccessToken } from '../tokens/property-access-token'\nimport { NumberToken } from '../tokens/number-token'\nimport { assert } from '../util/assert'\nimport { literalValues } from '../util/literal'\nimport { LiteralToken } from '../tokens/literal-token'\nimport * as TypeGuards from '../util/type-guards'\nimport { Token } from '../tokens/token'\nimport { OperatorToken } from '../tokens/operator-token'\nimport { RangeToken } from '../tokens/range-token'\nimport { parseStringLiteral } from '../parser/parse-string-literal'\nimport { Context } from '../context/context'\nimport { range } from '../util/underscore'\nimport { Operators } from '../render/operator'\nimport { UndefinedVariableError } from '../util/error'\n\nexport class Expression {\n  private postfix: Token[]\n\n  public constructor (tokens: IterableIterator<Token>) {\n    this.postfix = [...toPostfix(tokens)]\n  }\n  public * evaluate (ctx: Context, lenient: boolean): any {\n    assert(ctx, 'unable to evaluate: context not defined')\n    const operands: any[] = []\n    for (const token of this.postfix) {\n      if (TypeGuards.isOperatorToken(token)) {\n        const r = yield operands.pop()\n        const l = yield operands.pop()\n        const result = evalOperatorToken(ctx.opts.operators, token, l, r, ctx)\n        operands.push(result)\n      } else {\n        operands.push(yield evalToken(token, ctx, lenient && this.postfix.length === 1))\n      }\n    }\n    return operands[0]\n  }\n}\n\nexport function evalToken (token: Token | undefined, ctx: Context, lenient = false): any {\n  if (TypeGuards.isPropertyAccessToken(token)) return evalPropertyAccessToken(token, ctx, lenient)\n  if (TypeGuards.isRangeToken(token)) return evalRangeToken(token, ctx)\n  if (TypeGuards.isLiteralToken(token)) return evalLiteralToken(token)\n  if (TypeGuards.isNumberToken(token)) return evalNumberToken(token)\n  if (TypeGuards.isWordToken(token)) return token.getText()\n  if (TypeGuards.isQuotedToken(token)) return evalQuotedToken(token)\n}\n\nfunction evalPropertyAccessToken (token: PropertyAccessToken, ctx: Context, lenient: boolean) {\n  const props: string[] = token.props.map(prop => evalToken(prop, ctx, false))\n  try {\n    return ctx.get([token.propertyName, ...props])\n  } catch (e) {\n    if (lenient && e.name === 'InternalUndefinedVariableError') return null\n    throw (new UndefinedVariableError(e, token))\n  }\n}\n\nfunction evalNumberToken (token: NumberToken) {\n  const str = token.whole.content + '.' + (token.decimal ? token.decimal.content : '')\n  return Number(str)\n}\n\nexport function evalQuotedToken (token: QuotedToken) {\n  return parseStringLiteral(token.getText())\n}\n\nfunction evalOperatorToken (operators: Operators, token: OperatorToken, lhs: any, rhs: any, ctx: Context) {\n  const impl = operators[token.operator]\n  return impl(lhs, rhs, ctx)\n}\n\nfunction evalLiteralToken (token: LiteralToken) {\n  return literalValues[token.literal]\n}\n\nfunction evalRangeToken (token: RangeToken, ctx: Context) {\n  const low: number = evalToken(token.lhs, ctx)\n  const high: number = evalToken(token.rhs, ctx)\n  return range(+low, +high + 1)\n}\n\nfunction * toPostfix (tokens: IterableIterator<Token>): IterableIterator<Token> {\n  const ops: OperatorToken[] = []\n  for (const token of tokens) {\n    if (TypeGuards.isOperatorToken(token)) {\n      while (ops.length && ops[ops.length - 1].getPrecedence() > token.getPrecedence()) {\n        yield ops.pop()!\n      }\n      ops.push(token)\n    } else yield token\n  }\n  while (ops.length) {\n    yield ops.pop()!\n  }\n}\n","import { TokenKind } from '../parser/token-kind'\n\nexport abstract class Token {\n  public constructor (\n    public kind: TokenKind,\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {}\n  public getText () {\n    return this.input.slice(this.begin, this.end)\n  }\n  public getPosition () {\n    let [row, col] = [1, 1]\n    for (let i = 0; i < this.begin; i++) {\n      if (this.input[i] === '\\n') {\n        row++\n        col = 1\n      } else col++\n    }\n    return [row, col]\n  }\n  public size () {\n    return this.end - this.begin\n  }\n}\n","import { Token } from './token'\nimport { TokenKind } from '../parser/token-kind'\nimport { last } from '../util/underscore'\n\nexport abstract class DelimitedToken extends Token {\n  public trimLeft = false\n  public trimRight = false\n  public content: string\n  public constructor (\n    kind: TokenKind,\n    content: string,\n    input: string,\n    begin: number,\n    end: number,\n    trimLeft: boolean,\n    trimRight: boolean,\n    file?: string\n  ) {\n    super(kind, input, begin, end, file)\n    this.content = this.getText()\n    const tl = content[0] === '-'\n    const tr = last(content) === '-'\n    this.content = content\n      .slice(\n        tl ? 1 : 0,\n        tr ? -1 : content.length\n      )\n      .trim()\n    this.trimLeft = tl || trimLeft\n    this.trimRight = tr || trimRight\n  }\n}\n","import { Token } from '../tokens/token'\nimport { isTagToken, isHTMLToken, isDelimitedToken } from '../util/type-guards'\nimport { NormalizedFullOptions } from '../liquid-options'\nimport { TYPES, INLINE_BLANK, BLANK } from '../util/character'\n\nexport function whiteSpaceCtrl (tokens: Token[], options: NormalizedFullOptions) {\n  let inRaw = false\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n    if (!isDelimitedToken(token)) continue\n    if (!inRaw && token.trimLeft) {\n      trimLeft(tokens[i - 1], options.greedy)\n    }\n\n    if (isTagToken(token)) {\n      if (token.name === 'raw') inRaw = true\n      else if (token.name === 'endraw') inRaw = false\n    }\n\n    if (!inRaw && token.trimRight) {\n      trimRight(tokens[i + 1], options.greedy)\n    }\n  }\n}\n\nfunction trimLeft (token: Token, greedy: boolean) {\n  if (!token || !isHTMLToken(token)) return\n\n  const mask = greedy ? BLANK : INLINE_BLANK\n  while (TYPES[token.input.charCodeAt(token.end - 1 - token.trimRight)] & mask) token.trimRight++\n}\n\nfunction trimRight (token: Token, greedy: boolean) {\n  if (!token || !isHTMLToken(token)) return\n\n  const mask = greedy ? BLANK : INLINE_BLANK\n  while (TYPES[token.input.charCodeAt(token.begin + token.trimLeft)] & mask) token.trimLeft++\n  if (token.input.charAt(token.begin + token.trimLeft) === '\\n') token.trimLeft++\n}\n","import { Token } from './token'\nimport { IdentifierToken } from './identifier-token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class NumberToken extends Token {\n  constructor (\n    public whole: IdentifierToken,\n    public decimal?: IdentifierToken\n  ) {\n    super(TokenKind.Number, whole.input, whole.begin, decimal ? decimal.end : whole.end, whole.file)\n  }\n}\n","import { Token } from './token'\nimport { NUMBER, TYPES, SIGN } from '../util/character'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class IdentifierToken extends Token {\n  public content: string\n  constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {\n    super(TokenKind.Word, input, begin, end, file)\n    this.content = this.getText()\n  }\n  isNumber (allowSign = false) {\n    const begin = allowSign && TYPES[this.input.charCodeAt(this.begin)] & SIGN\n      ? this.begin + 1\n      : this.begin\n    for (let i = begin; i < this.end; i++) {\n      if (!(TYPES[this.input.charCodeAt(i)] & NUMBER)) return false\n    }\n    return true\n  }\n}\n","import { Token } from './token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class LiteralToken extends Token {\n  public literal: string\n  public constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {\n    super(TokenKind.Literal, input, begin, end, file)\n    this.literal = this.getText()\n  }\n}\n","import { Token } from './token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport const precedence = {\n  '==': 1,\n  '!=': 1,\n  '>': 1,\n  '<': 1,\n  '>=': 1,\n  '<=': 1,\n  'contains': 1,\n  'and': 0,\n  'or': 0\n}\n\nexport class OperatorToken extends Token {\n  public operator: string\n  public constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {\n    super(TokenKind.Operator, input, begin, end, file)\n    this.operator = this.getText()\n  }\n  getPrecedence () {\n    const key = this.getText()\n    return key in precedence ? precedence[key] : 1\n  }\n}\n","import { Token } from './token'\nimport { IdentifierToken } from './identifier-token'\nimport { QuotedToken } from './quoted-token'\nimport { TokenKind } from '../parser/token-kind'\nimport { parseStringLiteral } from '../parser/parse-string-literal'\n\nexport class PropertyAccessToken extends Token {\n  public propertyName: string\n  constructor (\n    public variable: IdentifierToken | QuotedToken,\n    public props: (IdentifierToken | QuotedToken | PropertyAccessToken)[],\n    end: number\n  ) {\n    super(TokenKind.PropertyAccess, variable.input, variable.begin, end, variable.file)\n    this.propertyName = this.variable instanceof IdentifierToken\n      ? this.variable.getText()\n      : parseStringLiteral(this.variable.getText())\n  }\n}\n","import { Token } from './token'\nimport { FilterArg } from '../parser/filter-arg'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class FilterToken extends Token {\n  public constructor (\n    public name: string,\n    public args: FilterArg[],\n    input: string,\n    begin: number,\n    end: number,\n    file?: string\n  ) {\n    super(TokenKind.Filter, input, begin, end, file)\n  }\n}\n","import { Token } from './token'\nimport { ValueToken } from './value-token'\nimport { IdentifierToken } from './identifier-token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class HashToken extends Token {\n  constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public name: IdentifierToken,\n    public value?: ValueToken,\n    public file?: string\n  ) {\n    super(TokenKind.Hash, input, begin, end, file)\n  }\n}\n","import { Token } from './token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class QuotedToken extends Token {\n  constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {\n    super(TokenKind.Quoted, input, begin, end, file)\n  }\n}\n","import { Token } from './token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class HTMLToken extends Token {\n  trimLeft = 0\n  trimRight = 0\n  constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {\n    super(TokenKind.HTML, input, begin, end, file)\n  }\n  public getContent () {\n    return this.input.slice(this.begin + this.trimLeft, this.end - this.trimRight)\n  }\n}\n","import { Token } from './token'\nimport { ValueToken } from './value-token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class RangeToken extends Token {\n  constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public lhs: ValueToken,\n    public rhs: ValueToken,\n    public file?: string\n  ) {\n    super(TokenKind.Range, input, begin, end, file)\n  }\n}\n","import { DelimitedToken } from './delimited-token'\nimport { NormalizedFullOptions } from '../liquid-options'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class OutputToken extends DelimitedToken {\n  public constructor (\n    input: string,\n    begin: number,\n    end: number,\n    options: NormalizedFullOptions,\n    file?: string\n  ) {\n    const { trimOutputLeft, trimOutputRight, outputDelimiterLeft, outputDelimiterRight } = options\n    const value = input.slice(begin + outputDelimiterLeft.length, end - outputDelimiterRight.length)\n    super(TokenKind.Output, value, input, begin, end, trimOutputLeft, trimOutputRight, file)\n  }\n}\n","import { whiteSpaceCtrl } from './whitespace-ctrl'\nimport { NumberToken } from '../tokens/number-token'\nimport { IdentifierToken } from '../tokens/identifier-token'\nimport { literalValues } from '../util/literal'\nimport { LiteralToken } from '../tokens/literal-token'\nimport { OperatorToken } from '../tokens/operator-token'\nimport { PropertyAccessToken } from '../tokens/property-access-token'\nimport { assert } from '../util/assert'\nimport { TopLevelToken } from '../tokens/toplevel-token'\nimport { FilterArg } from './filter-arg'\nimport { FilterToken } from '../tokens/filter-token'\nimport { HashToken } from '../tokens/hash-token'\nimport { QuotedToken } from '../tokens/quoted-token'\nimport { ellipsis } from '../util/underscore'\nimport { HTMLToken } from '../tokens/html-token'\nimport { TagToken } from '../tokens/tag-token'\nimport { Token } from '../tokens/token'\nimport { RangeToken } from '../tokens/range-token'\nimport { ValueToken } from '../tokens/value-token'\nimport { OutputToken } from '../tokens/output-token'\nimport { TokenizationError } from '../util/error'\nimport { NormalizedFullOptions, defaultOptions } from '../liquid-options'\nimport { TYPES, QUOTE, BLANK, IDENTIFIER } from '../util/character'\nimport { matchOperator } from './match-operator'\nimport { Trie } from '../util/operator-trie'\nimport { Expression } from '../render/expression'\n\nexport class Tokenizer {\n  p = 0\n  N: number\n  private rawBeginAt = -1\n\n  constructor (\n    public input: string,\n    private trie: Trie,\n    private file: string = ''\n  ) {\n    this.N = input.length\n  }\n\n  readExpression () {\n    return new Expression(this.readExpressionTokens())\n  }\n\n  * readExpressionTokens (): IterableIterator<Token> {\n    const operand = this.readValue()\n    if (!operand) return\n\n    yield operand\n\n    while (this.p < this.N) {\n      const operator = this.readOperator()\n      if (!operator) return\n\n      const operand = this.readValue()\n      if (!operand) return\n\n      yield operator\n      yield operand\n    }\n  }\n  readOperator (): OperatorToken | undefined {\n    this.skipBlank()\n    const end = matchOperator(this.input, this.p, this.trie, this.p + 8)\n    if (end === -1) return\n    return new OperatorToken(this.input, this.p, (this.p = end), this.file)\n  }\n  readFilters (): FilterToken[] {\n    const filters = []\n    while (true) {\n      const filter = this.readFilter()\n      if (!filter) return filters\n      filters.push(filter)\n    }\n  }\n  readFilter (): FilterToken | null {\n    this.skipBlank()\n    if (this.end()) return null\n    assert(this.peek() === '|', () => `unexpected token at ${this.snapshot()}`)\n    this.p++\n    const begin = this.p\n    const name = this.readIdentifier()\n    if (!name.size()) return null\n    const args = []\n    this.skipBlank()\n    if (this.peek() === ':') {\n      do {\n        ++this.p\n        const arg = this.readFilterArg()\n        arg && args.push(arg)\n        while (this.p < this.N && this.peek() !== ',' && this.peek() !== '|') ++this.p\n      } while (this.peek() === ',')\n    }\n    return new FilterToken(name.getText(), args, this.input, begin, this.p, this.file)\n  }\n\n  readFilterArg (): FilterArg | undefined {\n    const key = this.readValue()\n    if (!key) return\n    this.skipBlank()\n    if (this.peek() !== ':') return key\n    ++this.p\n    const value = this.readValue()\n    return [key.getText(), value]\n  }\n\n  readTopLevelTokens (options: NormalizedFullOptions = defaultOptions): TopLevelToken[] {\n    const tokens: TopLevelToken[] = []\n    while (this.p < this.N) {\n      const token = this.readTopLevelToken(options)\n      tokens.push(token)\n    }\n    whiteSpaceCtrl(tokens, options)\n    return tokens\n  }\n\n  readTopLevelToken (options: NormalizedFullOptions): TopLevelToken {\n    const { tagDelimiterLeft, outputDelimiterLeft } = options\n    if (this.rawBeginAt > -1) return this.readEndrawOrRawContent(options)\n    if (this.match(tagDelimiterLeft)) return this.readTagToken(options)\n    if (this.match(outputDelimiterLeft)) return this.readOutputToken(options)\n    return this.readHTMLToken(options)\n  }\n\n  readHTMLToken (options: NormalizedFullOptions): HTMLToken {\n    const begin = this.p\n    while (this.p < this.N) {\n      const { tagDelimiterLeft, outputDelimiterLeft } = options\n      if (this.match(tagDelimiterLeft)) break\n      if (this.match(outputDelimiterLeft)) break\n      ++this.p\n    }\n    return new HTMLToken(this.input, begin, this.p, this.file)\n  }\n\n  readTagToken (options: NormalizedFullOptions = defaultOptions): TagToken {\n    const { file, input } = this\n    const begin = this.p\n    if (this.readToDelimiter(options.tagDelimiterRight) === -1) {\n      throw this.mkError(`tag ${this.snapshot(begin)} not closed`, begin)\n    }\n    const token = new TagToken(input, begin, this.p, options, file)\n    if (token.name === 'raw') this.rawBeginAt = begin\n    return token\n  }\n\n  readToDelimiter (delimiter: string) {\n    while (this.p < this.N) {\n      if ((this.peekType() & QUOTE)) {\n        this.readQuoted()\n        continue\n      }\n      ++this.p\n      if (this.rmatch(delimiter)) return this.p\n    }\n    return -1\n  }\n\n  readOutputToken (options: NormalizedFullOptions = defaultOptions): OutputToken {\n    const { file, input } = this\n    const { outputDelimiterRight } = options\n    const begin = this.p\n    if (this.readToDelimiter(outputDelimiterRight) === -1) {\n      throw this.mkError(`output ${this.snapshot(begin)} not closed`, begin)\n    }\n    return new OutputToken(input, begin, this.p, options, file)\n  }\n\n  readEndrawOrRawContent (options: NormalizedFullOptions): HTMLToken | TagToken {\n    const { tagDelimiterLeft, tagDelimiterRight } = options\n    const begin = this.p\n    let leftPos = this.readTo(tagDelimiterLeft) - tagDelimiterLeft.length\n    while (this.p < this.N) {\n      if (this.readIdentifier().getText() !== 'endraw') {\n        leftPos = this.readTo(tagDelimiterLeft) - tagDelimiterLeft.length\n        continue\n      }\n      while (this.p <= this.N) {\n        if (this.rmatch(tagDelimiterRight)) {\n          const end = this.p\n          if (begin === leftPos) {\n            this.rawBeginAt = -1\n            return new TagToken(this.input, begin, end, options, this.file)\n          } else {\n            this.p = leftPos\n            return new HTMLToken(this.input, begin, leftPos, this.file)\n          }\n        }\n        if (this.rmatch(tagDelimiterLeft)) break\n        this.p++\n      }\n    }\n    throw this.mkError(`raw ${this.snapshot(this.rawBeginAt)} not closed`, begin)\n  }\n\n  mkError (msg: string, begin: number) {\n    return new TokenizationError(msg, new IdentifierToken(this.input, begin, this.N, this.file))\n  }\n\n  snapshot (begin: number = this.p) {\n    return JSON.stringify(ellipsis(this.input.slice(begin), 16))\n  }\n\n  /**\n   * @deprecated\n   */\n  readWord () {\n    console.warn('Tokenizer#readWord() will be removed, use #readIdentifier instead')\n    return this.readIdentifier()\n  }\n\n  readIdentifier (): IdentifierToken {\n    this.skipBlank()\n    const begin = this.p\n    while (this.peekType() & IDENTIFIER) ++this.p\n    return new IdentifierToken(this.input, begin, this.p, this.file)\n  }\n\n  readHashes () {\n    const hashes = []\n    while (true) {\n      const hash = this.readHash()\n      if (!hash) return hashes\n      hashes.push(hash)\n    }\n  }\n\n  readHash (): HashToken | undefined {\n    this.skipBlank()\n    if (this.peek() === ',') ++this.p\n    const begin = this.p\n    const name = this.readIdentifier()\n    if (!name.size()) return\n    let value\n\n    this.skipBlank()\n    if (this.peek() === ':') {\n      ++this.p\n      value = this.readValue()\n    }\n    return new HashToken(this.input, begin, this.p, name, value, this.file)\n  }\n\n  remaining () {\n    return this.input.slice(this.p)\n  }\n\n  advance (i = 1) {\n    this.p += i\n  }\n\n  end () {\n    return this.p >= this.N\n  }\n\n  readTo (end: string): number {\n    while (this.p < this.N) {\n      ++this.p\n      if (this.rmatch(end)) return this.p\n    }\n    return -1\n  }\n\n  readValue (): ValueToken | undefined {\n    const value = this.readQuoted() || this.readRange()\n    if (value) return value\n\n    if (this.peek() === '[') {\n      this.p++\n      const prop = this.readQuoted()\n      if (!prop) return\n      if (this.peek() !== ']') return\n      this.p++\n      return new PropertyAccessToken(prop, [], this.p)\n    }\n\n    const variable = this.readIdentifier()\n    if (!variable.size()) return\n\n    let isNumber = variable.isNumber(true)\n    const props: (QuotedToken | IdentifierToken)[] = []\n    while (true) {\n      if (this.peek() === '[') {\n        isNumber = false\n        this.p++\n        const prop = this.readValue() || new IdentifierToken(this.input, this.p, this.p, this.file)\n        this.readTo(']')\n        props.push(prop)\n      } else if (this.peek() === '.' && this.peek(1) !== '.') { // skip range syntax\n        this.p++\n        const prop = this.readIdentifier()\n        if (!prop.size()) break\n        if (!prop.isNumber()) isNumber = false\n        props.push(prop)\n      } else break\n    }\n    if (!props.length && literalValues.hasOwnProperty(variable.content)) {\n      return new LiteralToken(this.input, variable.begin, variable.end, this.file)\n    }\n    if (isNumber) return new NumberToken(variable, props[0] as IdentifierToken)\n    return new PropertyAccessToken(variable, props, this.p)\n  }\n\n  readRange (): RangeToken | undefined {\n    this.skipBlank()\n    const begin = this.p\n    if (this.peek() !== '(') return\n    ++this.p\n    const lhs = this.readValueOrThrow()\n    this.p += 2\n    const rhs = this.readValueOrThrow()\n    ++this.p\n    return new RangeToken(this.input, begin, this.p, lhs, rhs, this.file)\n  }\n\n  readValueOrThrow (): ValueToken {\n    const value = this.readValue()\n    assert(value, () => `unexpected token ${this.snapshot()}, value expected`)\n    return value!\n  }\n\n  readQuoted (): QuotedToken | undefined {\n    this.skipBlank()\n    const begin = this.p\n    if (!(this.peekType() & QUOTE)) return\n    ++this.p\n    let escaped = false\n    while (this.p < this.N) {\n      ++this.p\n      if (this.input[this.p - 1] === this.input[begin] && !escaped) break\n      if (escaped) escaped = false\n      else if (this.input[this.p - 1] === '\\\\') escaped = true\n    }\n    return new QuotedToken(this.input, begin, this.p, this.file)\n  }\n\n  readFileName (): IdentifierToken {\n    const begin = this.p\n    while (!(this.peekType() & BLANK) && this.peek() !== ',' && this.p < this.N) this.p++\n    return new IdentifierToken(this.input, begin, this.p, this.file)\n  }\n\n  match (word: string) {\n    for (let i = 0; i < word.length; i++) {\n      if (word[i] !== this.input[this.p + i]) return false\n    }\n    return true\n  }\n\n  rmatch (pattern: string) {\n    for (let i = 0; i < pattern.length; i++) {\n      if (pattern[pattern.length - 1 - i] !== this.input[this.p - 1 - i]) return false\n    }\n    return true\n  }\n\n  peekType (n = 0) {\n    return TYPES[this.input.charCodeAt(this.p + n)]\n  }\n\n  peek (n = 0) {\n    return this.input[this.p + n]\n  }\n\n  skipBlank () {\n    while (this.peekType() & BLANK) ++this.p\n  }\n}\n","import { IDENTIFIER, TYPES } from '../util/character'\nimport { Trie } from '../util/operator-trie'\n\nexport function matchOperator (str: string, begin: number, trie: Trie, end = str.length) {\n  let node = trie\n  let i = begin\n  let info\n  while (node[str[i]] && i < end) {\n    node = node[str[i++]]\n    if (node['end']) info = node\n  }\n  if (!info) return -1\n  if (info['needBoundary'] && (TYPES[str.charCodeAt(i)] & IDENTIFIER)) return -1\n  return i\n}\n","import { DelimitedToken } from './delimited-token'\nimport { TokenizationError } from '../util/error'\nimport { NormalizedFullOptions } from '../liquid-options'\nimport { TokenKind } from '../parser/token-kind'\nimport { Tokenizer } from '../parser/tokenizer'\n\nexport class TagToken extends DelimitedToken {\n  public name: string\n  public args: string\n  public constructor (\n    input: string,\n    begin: number,\n    end: number,\n    options: NormalizedFullOptions,\n    file?: string\n  ) {\n    const { trimTagLeft, trimTagRight, tagDelimiterLeft, tagDelimiterRight } = options\n    const value = input.slice(begin + tagDelimiterLeft.length, end - tagDelimiterRight.length)\n    super(TokenKind.Tag, value, input, begin, end, trimTagLeft, trimTagRight, file)\n\n    const tokenizer = new Tokenizer(this.content, options.operatorsTrie)\n    this.name = tokenizer.readIdentifier().getText()\n    if (!this.name) throw new TokenizationError(`illegal tag syntax`, this)\n\n    tokenizer.skipBlank()\n    this.args = tokenizer.remaining()\n  }\n}\n","import { evalToken } from '../../render/expression'\nimport { Context } from '../../context/context'\nimport { Tokenizer } from '../../parser/tokenizer'\n\n/**\n * Key-Value Pairs Representing Tag Arguments\n * Example:\n *    For the markup `, foo:'bar', coo:2 reversed %}`,\n *    hash['foo'] === 'bar'\n *    hash['coo'] === 2\n *    hash['reversed'] === undefined\n */\nexport class Hash {\n  hash: { [key: string]: any } = {}\n  constructor (markup: string) {\n    const tokenizer = new Tokenizer(markup, {})\n    for (const hash of tokenizer.readHashes()) {\n      this.hash[hash.name.content] = hash.value\n    }\n  }\n  * render (ctx: Context) {\n    const hash = {}\n    for (const key of Object.keys(this.hash)) {\n      hash[key] = this.hash[key] === undefined ? true : yield evalToken(this.hash[key], ctx)\n    }\n    return hash\n  }\n}\n","import { evalToken } from '../../render/expression'\nimport { Context } from '../../context/context'\nimport { identify } from '../../util/underscore'\nimport { FilterImplOptions } from './filter-impl-options'\nimport { FilterArg, isKeyValuePair } from '../../parser/filter-arg'\nimport { Liquid } from '../../liquid'\n\nexport class Filter {\n  public name: string\n  public args: FilterArg[]\n  private impl: FilterImplOptions\n  private liquid: Liquid\n\n  public constructor (name: string, impl: FilterImplOptions, args: FilterArg[], liquid: Liquid) {\n    this.name = name\n    this.impl = impl || identify\n    this.args = args\n    this.liquid = liquid\n  }\n  public render (value: any, context: Context) {\n    const argv: any[] = []\n    for (const arg of this.args as FilterArg[]) {\n      if (isKeyValuePair(arg)) argv.push([arg[0], evalToken(arg[1], context)])\n      else argv.push(evalToken(arg, context))\n    }\n    return this.impl.apply({ context, liquid: this.liquid }, [value, ...argv])\n  }\n}\n","import { isArray } from '../util/underscore'\nimport { ValueToken } from '../tokens/value-token'\n\ntype KeyValuePair = [string?, ValueToken?]\n\nexport type FilterArg = ValueToken | KeyValuePair\n\nexport function isKeyValuePair (arr: FilterArg): arr is KeyValuePair { // TODO check\n  return isArray(arr)\n}\n","import { Expression } from '../render/expression'\nimport { Tokenizer } from '../parser/tokenizer'\nimport { Filter } from './filter/filter'\nimport { Context } from '../context/context'\nimport { Liquid } from '../liquid'\n\nexport class Value {\n  public readonly filters: Filter[] = []\n  public readonly initial: Expression\n\n  /**\n   * @param str the value to be valuated, eg.: \"foobar\" | truncate: 3\n   */\n  public constructor (str: string, liquid: Liquid) {\n    const tokenizer = new Tokenizer(str, liquid.options.operatorsTrie)\n    this.initial = tokenizer.readExpression()\n    this.filters = tokenizer.readFilters().map(({ name, args }) => new Filter(name, liquid.filters.get(name), args, liquid))\n  }\n  public * value (ctx: Context, lenient: boolean) {\n    lenient = lenient || (ctx.opts.lenientIf && this.filters.length > 0 && this.filters[0].name === 'default')\n    let val = yield this.initial.evaluate(ctx, lenient)\n\n    for (const filter of this.filters) {\n      val = yield filter.render(val, ctx)\n    }\n    return val\n  }\n}\n","import { isFunction } from '../../util/underscore'\nimport { Liquid } from '../../liquid'\nimport { TemplateImpl } from '../../template/template-impl'\nimport { Emitter, Hash, Context, TagToken, Template, TopLevelToken } from '../../types'\nimport { TagImpl } from './tag-impl'\n\nexport class Tag extends TemplateImpl<TagToken> implements Template {\n  public name: string\n  private impl: TagImpl\n\n  public constructor (token: TagToken, tokens: TopLevelToken[], liquid: Liquid) {\n    super(token)\n    this.name = token.name\n\n    const impl = liquid.tags.get(token.name)\n\n    this.impl = Object.create(impl)\n    this.impl.liquid = liquid\n    if (this.impl.parse) {\n      this.impl.parse(token, tokens)\n    }\n  }\n  public * render (ctx: Context, emitter: Emitter) {\n    const hash = yield new Hash(this.token.args).render(ctx)\n    const impl = this.impl\n    if (isFunction(impl.render)) return yield impl.render(ctx, emitter, hash)\n  }\n}\n","import { Value } from './value'\nimport { TemplateImpl } from '../template/template-impl'\nimport { Template } from '../template/template'\nimport { Context } from '../context/context'\nimport { Emitter } from '../emitters/emitter'\nimport { OutputToken } from '../tokens/output-token'\nimport { Liquid } from '../liquid'\n\nexport class Output extends TemplateImpl<OutputToken> implements Template {\n  private value: Value\n  public constructor (token: OutputToken, liquid: Liquid) {\n    super(token)\n    this.value = new Value(token.content, liquid)\n  }\n  public * render (ctx: Context, emitter: Emitter) {\n    const val = yield this.value.value(ctx, false)\n    emitter.write(val)\n  }\n}\n","import { TemplateImpl } from '../template/template-impl'\nimport { Template } from '../template/template'\nimport { HTMLToken } from '../tokens/html-token'\nimport { Context } from '../context/context'\nimport { Emitter } from '../emitters/emitter'\n\nexport class HTML extends TemplateImpl<HTMLToken> implements Template {\n  private str: string\n  public constructor (token: HTMLToken) {\n    super(token)\n    this.str = token.getContent()\n  }\n  public * render (ctx: Context, emitter: Emitter): IterableIterator<void> {\n    emitter.write(this.str)\n  }\n}\n","import { ParseError } from '../util/error'\nimport { Liquid, Tokenizer } from '../liquid'\nimport { ParseStream } from './parse-stream'\nimport { isTagToken, isOutputToken } from '../util/type-guards'\nimport { OutputToken } from '../tokens/output-token'\nimport { Tag } from '../template/tag/tag'\nimport { Output } from '../template/output'\nimport { HTML } from '../template/html'\nimport { Template } from '../template/template'\nimport { TopLevelToken } from '../tokens/toplevel-token'\nimport { Cache } from '../cache/cache'\nimport { Loader, LookupType } from '../fs/loader'\nimport { FS } from '../fs/fs'\nimport { toThenable, Thenable } from '../util/async'\n\nexport default class Parser {\n  public parseFile: (file: string, sync?: boolean, type?: LookupType, currentFile?: string) => IterableIterator<any>\n\n  private liquid: Liquid\n  private fs: FS\n  private cache: Cache<Thenable<Template[]>> | undefined\n  private loader: Loader\n\n  public constructor (liquid: Liquid) {\n    this.liquid = liquid\n    this.cache = this.liquid.options.cache\n    this.fs = this.liquid.options.fs\n    this.parseFile = this.cache ? this._parseFileCached : this._parseFile\n    this.loader = new Loader(this.liquid.options)\n  }\n  public parse (html: string, filepath?: string): Template[] {\n    const tokenizer = new Tokenizer(html, this.liquid.options.operatorsTrie, filepath)\n    const tokens = tokenizer.readTopLevelTokens(this.liquid.options)\n    return this.parseTokens(tokens)\n  }\n  public parseTokens (tokens: TopLevelToken[]) {\n    let token\n    const templates: Template[] = []\n    while ((token = tokens.shift())) {\n      templates.push(this.parseToken(token, tokens))\n    }\n    return templates\n  }\n  public parseToken (token: TopLevelToken, remainTokens: TopLevelToken[]) {\n    try {\n      if (isTagToken(token)) {\n        return new Tag(token, remainTokens, this.liquid)\n      }\n      if (isOutputToken(token)) {\n        return new Output(token as OutputToken, this.liquid)\n      }\n      return new HTML(token)\n    } catch (e) {\n      throw new ParseError(e, token)\n    }\n  }\n  public parseStream (tokens: TopLevelToken[]) {\n    return new ParseStream(tokens, (token, tokens) => this.parseToken(token, tokens))\n  }\n  private * _parseFileCached (file: string, sync?: boolean, type: LookupType = LookupType.Root, currentFile?: string) {\n    const key = this.loader.shouldLoadRelative(file)\n      ? currentFile + ',' + file\n      : type + ':' + file\n    const tpls = yield this.cache!.read(key)\n    if (tpls) return tpls\n\n    const task = toThenable(this._parseFile(file, sync, type, currentFile))\n    this.cache!.write(key, task)\n    try {\n      return yield task\n    } catch (e) {\n      // remove cached task if failed\n      this.cache!.remove(key)\n    }\n  }\n  private * _parseFile (file: string, sync?: boolean, type: LookupType = LookupType.Root, currentFile?: string): IterableIterator<any> {\n    const filepath = yield this.loader.lookup(file, type, sync, currentFile)\n    return this.liquid.parse(sync ? this.fs.readFileSync(filepath) : yield this.fs.readFile(filepath), filepath)\n  }\n}\n","import { Tokenizer, assert, TagImplOptions, TagToken, Context } from '../../types'\n\nexport default {\n  parse: function (token: TagToken) {\n    const tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie)\n    this.key = tokenizer.readIdentifier().content\n    tokenizer.skipBlank()\n    assert(tokenizer.peek() === '=', () => `illegal token ${token.getText()}`)\n    tokenizer.advance()\n    this.value = tokenizer.remaining()\n  },\n  render: function * (ctx: Context) {\n    ctx.bottom()[this.key] = yield this.liquid._evalValue(this.value, ctx)\n  }\n} as TagImplOptions\n","import { isString, isObject, isArray } from './underscore'\n\nexport function toEnumerable (val: any) {\n  if (isArray(val)) return val\n  if (isString(val) && val.length > 0) return [val]\n  if (isObject(val)) return Object.keys(val).map((key) => [key, val[key]])\n  return []\n}\n\nexport function toArray (val: any) {\n  if (isArray(val)) return val\n  return [ val ]\n}\n","import { Drop } from './drop'\n\nexport class ForloopDrop extends Drop {\n  protected i = 0\n  public name: string\n  public length: number\n  public constructor (length: number, collection: string, variable: string) {\n    super()\n    this.length = length\n    this.name = `${variable}-${collection}`\n  }\n  public next () {\n    this.i++\n  }\n  public index0 () {\n    return this.i\n  }\n  public index () {\n    return this.i + 1\n  }\n  public first () {\n    return this.i === 0\n  }\n  public last () {\n    return this.i === this.length - 1\n  }\n  public rindex () {\n    return this.length - this.i\n  }\n  public rindex0 () {\n    return this.length - this.i - 1\n  }\n  public valueOf () {\n    return JSON.stringify(this)\n  }\n}\n","import { assert, Tokenizer, evalToken, Emitter, TagToken, TopLevelToken, Context, Template, TagImplOptions, ParseStream } from '../../types'\nimport { toEnumerable } from '../../util/collection'\nimport { ForloopDrop } from '../../drop/forloop-drop'\nimport { Hash } from '../../template/tag/hash'\n\nconst MODIFIERS = ['offset', 'limit', 'reversed']\n\ntype valueof<T> = T[keyof T]\n\nexport default {\n  type: 'block',\n  parse: function (token: TagToken, remainTokens: TopLevelToken[]) {\n    const tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie)\n\n    const variable = tokenizer.readIdentifier()\n    const inStr = tokenizer.readIdentifier()\n    const collection = tokenizer.readValue()\n    assert(\n      variable.size() && inStr.content === 'in' && collection,\n      () => `illegal tag: ${token.getText()}`\n    )\n\n    this.variable = variable.content\n    this.collection = collection\n    this.hash = new Hash(tokenizer.remaining())\n    this.templates = []\n    this.elseTemplates = []\n\n    let p\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => (p = this.templates))\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endfor', () => stream.stop())\n      .on('template', (tpl: Template) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${token.getText()} not closed`)\n      })\n\n    stream.start()\n  },\n  render: function * (ctx: Context, emitter: Emitter) {\n    const r = this.liquid.renderer\n    let collection = toEnumerable(yield evalToken(this.collection, ctx))\n\n    if (!collection.length) {\n      yield r.renderTemplates(this.elseTemplates, ctx, emitter)\n      return\n    }\n\n    const hash = yield this.hash.render(ctx)\n    const modifiers = this.liquid.options.orderedFilterParameters\n      ? Object.keys(hash).filter(x => MODIFIERS.includes(x))\n      : MODIFIERS.filter(x => hash[x] !== undefined)\n\n    collection = modifiers.reduce((collection, modifier: valueof<typeof MODIFIERS>) => {\n      if (modifier === 'offset') return offset(collection, hash['offset'])\n      if (modifier === 'limit') return limit(collection, hash['limit'])\n      return reversed(collection)\n    }, collection)\n\n    const scope = { forloop: new ForloopDrop(collection.length, this.collection.getText(), this.variable) }\n    ctx.push(scope)\n    for (const item of collection) {\n      scope[this.variable] = item\n      yield r.renderTemplates(this.templates, ctx, emitter)\n      if (emitter['break']) {\n        emitter['break'] = false\n        break\n      }\n      emitter['continue'] = false\n      scope.forloop.next()\n    }\n    ctx.pop()\n  }\n} as TagImplOptions\n\nfunction reversed<T> (arr: Array<T>) {\n  return [...arr].reverse()\n}\n\nfunction offset<T> (arr: Array<T>, count: number) {\n  return arr.slice(count)\n}\n\nfunction limit<T> (arr: Array<T>, count: number) {\n  return arr.slice(0, count)\n}\n","import { Tokenizer, assert, Template, Context, TagImplOptions, TagToken, TopLevelToken } from '../../types'\nimport { evalQuotedToken } from '../../render/expression'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    const tokenizer = new Tokenizer(tagToken.args, this.liquid.options.operatorsTrie)\n    this.variable = readVariableName(tokenizer)\n    assert(this.variable, () => `${tagToken.args} not valid identifier`)\n\n    this.templates = []\n\n    const stream = this.liquid.parser.parseStream(remainTokens)\n    stream.on('tag:endcapture', () => stream.stop())\n      .on('template', (tpl: Template) => this.templates.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n    stream.start()\n  },\n  render: function * (ctx: Context) {\n    const r = this.liquid.renderer\n    const html = yield r.renderTemplates(this.templates, ctx)\n    ctx.bottom()[this.variable] = html\n  }\n} as TagImplOptions\n\nfunction readVariableName (tokenizer: Tokenizer) {\n  const word = tokenizer.readIdentifier().content\n  if (word) return word\n  const quoted = tokenizer.readQuoted()\n  if (quoted) return evalQuotedToken(quoted)\n}\n","enum BlockMode {\n  /* store rendered html into blocks */\n  OUTPUT,\n  /* output rendered html directly */\n  STORE\n}\n\nexport default BlockMode\n","import { toValue, evalToken, Value, Emitter, TagToken, TopLevelToken, Context, Template, TagImplOptions, ParseStream } from '../../types'\nimport { Tokenizer } from '../../parser/tokenizer'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    this.cond = new Value(tagToken.args, this.liquid)\n    this.cases = []\n    this.elseTemplates = []\n\n    let p: Template[] = []\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('tag:when', (token: TagToken) => {\n        p = []\n\n        const tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie)\n\n        while (!tokenizer.end()) {\n          const value = tokenizer.readValue()\n          this.cases.push({\n            val: value,\n            templates: p\n          })\n          tokenizer.readTo(',')\n        }\n      })\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endcase', () => stream.stop())\n      .on('template', (tpl: Template) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n\n    stream.start()\n  },\n\n  render: function * (ctx: Context, emitter: Emitter) {\n    const r = this.liquid.renderer\n    const cond = toValue(yield this.cond.value(ctx, ctx.opts.lenientIf))\n    for (const branch of this.cases) {\n      const val = evalToken(branch.val, ctx, ctx.opts.lenientIf)\n      if (val === cond) {\n        yield r.renderTemplates(branch.templates, ctx, emitter)\n        return\n      }\n    }\n    yield r.renderTemplates(this.elseTemplates, ctx, emitter)\n  }\n} as TagImplOptions\n","import { TagToken } from '../../tokens/tag-token'\nimport { TopLevelToken } from '../../tokens/toplevel-token'\nimport { TagImplOptions } from '../../template/tag/tag-impl-options'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    const stream = this.liquid.parser.parseStream(remainTokens)\n    stream\n      .on('token', (token: TagToken) => {\n        if (token.name === 'endcomment') stream.stop()\n      })\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n    stream.start()\n  }\n} as TagImplOptions\n","import { assert } from '../../util/assert'\nimport { ForloopDrop } from '../../drop/forloop-drop'\nimport { toEnumerable } from '../../util/collection'\nimport { Liquid } from '../../liquid'\nimport { Token, Template, evalQuotedToken, TypeGuards, Tokenizer, evalToken, Hash, Emitter, TagToken, Context, TagImplOptions } from '../../types'\n\nexport default {\n  parseFilePath,\n  renderFilePath,\n  parse: function (token: TagToken) {\n    const args = token.args\n    const tokenizer = new Tokenizer(args, this.liquid.options.operatorsTrie)\n    this['file'] = this.parseFilePath(tokenizer, this.liquid)\n    this['currentFile'] = token.file\n    while (!tokenizer.end()) {\n      tokenizer.skipBlank()\n      const begin = tokenizer.p\n      const keyword = tokenizer.readIdentifier()\n      if (keyword.content === 'with' || keyword.content === 'for') {\n        tokenizer.skipBlank()\n        // can be normal key/value pair, like \"with: true\"\n        if (tokenizer.peek() !== ':') {\n          const value = tokenizer.readValue()\n          // can be normal key, like \"with,\"\n          if (value) {\n            const beforeAs = tokenizer.p\n            const asStr = tokenizer.readIdentifier()\n            let alias\n            if (asStr.content === 'as') alias = tokenizer.readIdentifier()\n            else tokenizer.p = beforeAs\n\n            this[keyword.content] = { value, alias: alias && alias.content }\n            tokenizer.skipBlank()\n            if (tokenizer.peek() === ',') tokenizer.advance()\n            // matched!\n            continue\n          }\n        }\n      }\n      /**\n       * restore cursor if with/for not matched\n       */\n      tokenizer.p = begin\n      break\n    }\n    this.hash = new Hash(tokenizer.remaining())\n  },\n  render: function * (ctx: Context, emitter: Emitter) {\n    const { liquid, hash } = this\n    const filepath = yield this.renderFilePath(this['file'], ctx, liquid)\n    assert(filepath, () => `illegal filename \"${filepath}\"`)\n\n    const childCtx = new Context({}, ctx.opts, ctx.sync)\n    const scope = yield hash.render(ctx)\n    if (this['with']) {\n      const { value, alias } = this['with']\n      scope[alias || filepath] = evalToken(value, ctx)\n    }\n    childCtx.push(scope)\n\n    if (this['for']) {\n      const { value, alias } = this['for']\n      let collection = evalToken(value, ctx)\n      collection = toEnumerable(collection)\n      scope['forloop'] = new ForloopDrop(collection.length, value.getText(), alias)\n      for (const item of collection) {\n        scope[alias] = item\n        const templates = yield liquid._parsePartialFile(filepath, childCtx.sync, this['currentFile'])\n        yield liquid.renderer.renderTemplates(templates, childCtx, emitter)\n        scope.forloop.next()\n      }\n    } else {\n      const templates = yield liquid._parsePartialFile(filepath, childCtx.sync, this['currentFile'])\n      yield liquid.renderer.renderTemplates(templates, childCtx, emitter)\n    }\n  }\n} as TagImplOptions\n\ntype ParsedFileName = Template[] | Token | string | undefined\n\n/**\n * @return null for \"none\",\n * @return Template[] for quoted with tags and/or filters\n * @return Token for expression (not quoted)\n * @throws TypeError if cannot read next token\n */\nexport function parseFilePath (tokenizer: Tokenizer, liquid: Liquid): ParsedFileName | null {\n  if (liquid.options.dynamicPartials) {\n    const file = tokenizer.readValue()\n    if (file === undefined) throw new TypeError(`illegal argument \"${tokenizer.input}\"`)\n    if (file.getText() === 'none') return null\n    if (TypeGuards.isQuotedToken(file)) {\n      // for filenames like \"files/{{file}}\", eval as liquid template\n      const tpls = liquid.parse(evalQuotedToken(file))\n      // for filenames like \"files/file.liquid\", extract the string directly\n      if (tpls.length === 1 && TypeGuards.isHTMLToken(tpls[0].token)) return tpls[0].token.getContent()\n      return tpls\n    }\n    return file\n  }\n  const filepath = tokenizer.readFileName().getText()\n  return filepath === 'none' ? null : filepath\n}\n\nexport function renderFilePath (file: ParsedFileName, ctx: Context, liquid: Liquid) {\n  if (typeof file === 'string') return file\n  if (Array.isArray(file)) return liquid.renderer.renderTemplates(file, ctx)\n  return evalToken(file, ctx)\n}\n","import { assert, Tokenizer, evalToken, Hash, Emitter, TagToken, Context, TagImplOptions } from '../../types'\nimport BlockMode from '../../context/block-mode'\nimport { parseFilePath, renderFilePath } from './render'\n\nexport default {\n  parseFilePath,\n  renderFilePath,\n  parse: function (token: TagToken) {\n    const args = token.args\n    const tokenizer = new Tokenizer(args, this.liquid.options.operatorsTrie)\n    this['file'] = this.parseFilePath(tokenizer, this.liquid)\n    this['currentFile'] = token.file\n\n    const begin = tokenizer.p\n    const withStr = tokenizer.readIdentifier()\n    if (withStr.content === 'with') {\n      tokenizer.skipBlank()\n      if (tokenizer.peek() !== ':') {\n        this.withVar = tokenizer.readValue()\n      } else tokenizer.p = begin\n    } else tokenizer.p = begin\n\n    this.hash = new Hash(tokenizer.remaining())\n  },\n  render: function * (ctx: Context, emitter: Emitter) {\n    const { liquid, hash, withVar } = this\n    const { renderer } = liquid\n    const filepath = yield this.renderFilePath(this['file'], ctx, liquid)\n    assert(filepath, () => `illegal filename \"${filepath}\"`)\n\n    const saved = ctx.saveRegister('blocks', 'blockMode')\n    ctx.setRegister('blocks', {})\n    ctx.setRegister('blockMode', BlockMode.OUTPUT)\n    const scope = yield hash.render(ctx)\n    if (withVar) scope[filepath] = evalToken(withVar, ctx)\n    const templates = yield liquid._parsePartialFile(filepath, ctx.sync, this['currentFile'])\n    ctx.push(scope)\n    yield renderer.renderTemplates(templates, ctx, emitter)\n    ctx.pop()\n    ctx.restoreRegister(saved)\n  }\n} as TagImplOptions\n","import { Tokenizer, Emitter, TagToken, Context, TagImplOptions } from '../../types'\nimport { isNumber, stringify } from '../../util/underscore'\n\nexport default {\n  parse: function (token: TagToken) {\n    const tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie)\n    this.variable = tokenizer.readIdentifier().content\n  },\n  render: function (context: Context, emitter: Emitter) {\n    const scope = context.environments\n    if (!isNumber(scope[this.variable])) {\n      scope[this.variable] = 0\n    }\n    emitter.write(stringify(--scope[this.variable]))\n  }\n} as TagImplOptions\n","import { assert } from '../../util/assert'\nimport { evalToken, Emitter, TagToken, Context, TagImplOptions } from '../../types'\nimport { Tokenizer } from '../../parser/tokenizer'\n\nexport default {\n  parse: function (tagToken: TagToken) {\n    const tokenizer = new Tokenizer(tagToken.args, this.liquid.options.operatorsTrie)\n    const group = tokenizer.readValue()\n    tokenizer.skipBlank()\n\n    this.candidates = []\n\n    if (group) {\n      if (tokenizer.peek() === ':') {\n        this.group = group\n        tokenizer.advance()\n      } else this.candidates.push(group)\n    }\n\n    while (!tokenizer.end()) {\n      const value = tokenizer.readValue()\n      if (value) this.candidates.push(value)\n      tokenizer.readTo(',')\n    }\n    assert(this.candidates.length, () => `empty candidates: ${tagToken.getText()}`)\n  },\n\n  render: function (ctx: Context, emitter: Emitter) {\n    const group = evalToken(this.group, ctx)\n    const fingerprint = `cycle:${group}:` + this.candidates.join(',')\n    const groups = ctx.getRegister('cycle')\n    let idx = groups[fingerprint]\n\n    if (idx === undefined) {\n      idx = groups[fingerprint] = 0\n    }\n\n    const candidate = this.candidates[idx]\n    idx = (idx + 1) % this.candidates.length\n    groups[fingerprint] = idx\n    const html = evalToken(candidate, ctx)\n    emitter.write(html)\n  }\n} as TagImplOptions\n","import { Value, Emitter, isTruthy, TagToken, TopLevelToken, Context, Template, TagImplOptions } from '../../types'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    this.branches = []\n    this.elseTemplates = []\n\n    let p\n    this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => this.branches.push({\n        predicate: new Value(tagToken.args, this.liquid),\n        templates: (p = [])\n      }))\n      .on('tag:elsif', (token: TagToken) => this.branches.push({\n        predicate: new Value(token.args, this.liquid),\n        templates: (p = [])\n      }))\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endif', function () { this.stop() })\n      .on('template', (tpl: Template) => p.push(tpl))\n      .on('end', () => { throw new Error(`tag ${tagToken.getText()} not closed`) })\n      .start()\n  },\n\n  render: function * (ctx: Context, emitter: Emitter) {\n    const r = this.liquid.renderer\n\n    for (const { predicate, templates } of this.branches) {\n      const value = yield predicate.value(ctx, ctx.opts.lenientIf)\n      if (isTruthy(value, ctx)) {\n        yield r.renderTemplates(templates, ctx, emitter)\n        return\n      }\n    }\n    yield r.renderTemplates(this.elseTemplates, ctx, emitter)\n  }\n} as TagImplOptions\n","import { isNumber, stringify } from '../../util/underscore'\nimport { Tokenizer, Emitter, TagToken, Context, TagImplOptions } from '../../types'\n\nexport default {\n  parse: function (token: TagToken) {\n    const tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie)\n    this.variable = tokenizer.readIdentifier().content\n  },\n  render: function (context: Context, emitter: Emitter) {\n    const scope = context.environments\n    if (!isNumber(scope[this.variable])) {\n      scope[this.variable] = 0\n    }\n    const val = scope[this.variable]\n    scope[this.variable]++\n    emitter.write(stringify(val))\n  }\n} as TagImplOptions\n","import { assert, Tokenizer, Emitter, Hash, TagToken, TopLevelToken, Context, TagImplOptions } from '../../types'\nimport BlockMode from '../../context/block-mode'\nimport { parseFilePath, renderFilePath } from './render'\nimport { BlankDrop } from '../../drop/blank-drop'\n\nexport default {\n  parseFilePath,\n  renderFilePath,\n  parse: function (token: TagToken, remainTokens: TopLevelToken[]) {\n    const tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie)\n    this['file'] = this.parseFilePath(tokenizer, this.liquid)\n    this['currentFile'] = token.file\n    this.hash = new Hash(tokenizer.remaining())\n    this.tpls = this.liquid.parser.parseTokens(remainTokens)\n  },\n  render: function * (ctx: Context, emitter: Emitter) {\n    const { liquid, hash, file } = this\n    const { renderer } = liquid\n    if (file === null) {\n      ctx.setRegister('blockMode', BlockMode.OUTPUT)\n      yield renderer.renderTemplates(this.tpls, ctx, emitter)\n      return\n    }\n    const filepath = yield this.renderFilePath(this['file'], ctx, liquid)\n    assert(filepath, () => `illegal filename \"${filepath}\"`)\n    const templates = yield liquid._parseLayoutFile(filepath, ctx.sync, this['currentFile'])\n\n    // render remaining contents and store rendered results\n    ctx.setRegister('blockMode', BlockMode.STORE)\n    const html = yield renderer.renderTemplates(this.tpls, ctx)\n    const blocks = ctx.getRegister('blocks')\n\n    // set whole content to anonymous block if anonymous doesn't specified\n    if (blocks[''] === undefined) blocks[''] = (parent: BlankDrop, emitter: Emitter) => emitter.write(html)\n    ctx.setRegister('blockMode', BlockMode.OUTPUT)\n\n    // render the layout file use stored blocks\n    ctx.push(yield hash.render(ctx))\n    yield renderer.renderTemplates(templates, ctx, emitter)\n    ctx.pop()\n  }\n} as TagImplOptions\n","import { Drop } from './drop'\n\nexport class BlockDrop extends Drop {\n  constructor (\n    // the block render from layout template\n    private superBlockRender: () => Iterable<any> = () => ''\n  ) {\n    super()\n  }\n  /**\n   * Provide parent access in child block by\n   * {{ block.super }}\n   */\n  public super () {\n    return this.superBlockRender()\n  }\n}\n","import BlockMode from '../../context/block-mode'\nimport { BlockDrop } from '../../drop/block-drop'\nimport { TagToken, TopLevelToken, Template, Context, TagImpl, Emitter } from '../../types'\n\nexport default {\n  parse (this: TagImpl, token: TagToken, remainTokens: TopLevelToken[]) {\n    const match = /\\w+/.exec(token.args)\n    this.block = match ? match[0] : ''\n    this.tpls = [] as Template[]\n    this.liquid.parser.parseStream(remainTokens)\n      .on('tag:endblock', function () { this.stop() })\n      .on('template', (tpl: Template) => this.tpls.push(tpl))\n      .on('end', () => { throw new Error(`tag ${token.getText()} not closed`) })\n      .start()\n  },\n\n  * render (this: TagImpl, ctx: Context, emitter: Emitter) {\n    const blockRender = this.getBlockRender(ctx)\n    if (ctx.getRegister('blockMode') === BlockMode.STORE) {\n      ctx.getRegister('blocks')[this.block] = blockRender\n    } else {\n      yield blockRender(new BlockDrop(), emitter)\n    }\n  },\n\n  getBlockRender (this: TagImpl, ctx: Context) {\n    const { liquid, tpls } = this\n    const renderChild = ctx.getRegister('blocks')[this.block]\n    const renderCurrent = function * (superBlock: BlockDrop, emitter: Emitter) {\n      // add {{ block.super }} support when rendering\n      ctx.push({ block: superBlock })\n      yield liquid.renderer.renderTemplates(tpls, ctx, emitter)\n      ctx.pop()\n    }\n    return renderChild\n      ? (superBlock: BlockDrop, emitter: Emitter) => renderChild(new BlockDrop(() => renderCurrent(superBlock, emitter)), emitter)\n      : renderCurrent\n  }\n}\n","import { TagToken, TopLevelToken, TagImplOptions } from '../../types'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    this.tokens = []\n\n    const stream = this.liquid.parser.parseStream(remainTokens)\n    stream\n      .on('token', (token: TagToken) => {\n        if (token.name === 'endraw') stream.stop()\n        else this.tokens.push(token)\n      })\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n    stream.start()\n  },\n  render: function () {\n    return this.tokens.map((token: TopLevelToken) => token.getText()).join('')\n  }\n} as TagImplOptions\n","import { ForloopDrop } from './forloop-drop'\n\nexport class TablerowloopDrop extends ForloopDrop {\n  private cols: number\n  public constructor (length: number, cols: number, collection: string, variable: string) {\n    super(length, collection, variable)\n    this.length = length\n    this.cols = cols\n  }\n  public row () {\n    return Math.floor(this.i / this.cols) + 1\n  }\n  public col0 () {\n    return (this.i % this.cols)\n  }\n  public col () {\n    return this.col0() + 1\n  }\n  public col_first () {  // eslint-disable-line\n    return this.col0() === 0\n  }\n  public col_last () { // eslint-disable-line\n    return this.col() === this.cols\n  }\n}\n","import assign from './assign'\nimport For from './for'\nimport capture from './capture'\nimport Case from './case'\nimport comment from './comment'\nimport include from './include'\nimport render from './render'\nimport decrement from './decrement'\nimport cycle from './cycle'\nimport If from './if'\nimport increment from './increment'\nimport layout from './layout'\nimport block from './block'\nimport raw from './raw'\nimport tablerow from './tablerow'\nimport unless from './unless'\nimport Break from './break'\nimport Continue from './continue'\nimport { TagImplOptions } from '../../template/tag/tag-impl-options'\n\nconst tags: { [key: string]: TagImplOptions } = {\n  assign, 'for': For, capture, 'case': Case, comment, include, render, decrement, increment, cycle, 'if': If, layout, block, raw, tablerow, unless, 'break': Break, 'continue': Continue\n}\n\nexport default tags\n","import { toEnumerable } from '../../util/collection'\nimport { assert, evalToken, Emitter, Hash, TagToken, TopLevelToken, Context, Template, TagImplOptions, ParseStream } from '../../types'\nimport { TablerowloopDrop } from '../../drop/tablerowloop-drop'\nimport { Tokenizer } from '../../parser/tokenizer'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    const tokenizer = new Tokenizer(tagToken.args, this.liquid.options.operatorsTrie)\n\n    const variable = tokenizer.readIdentifier()\n    tokenizer.skipBlank()\n\n    const tmp = tokenizer.readIdentifier()\n    assert(tmp && tmp.content === 'in', () => `illegal tag: ${tagToken.getText()}`)\n\n    this.variable = variable.content\n    this.collection = tokenizer.readValue()\n    this.hash = new Hash(tokenizer.remaining())\n    this.templates = []\n\n    let p\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => (p = this.templates))\n      .on('tag:endtablerow', () => stream.stop())\n      .on('template', (tpl: Template) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n\n    stream.start()\n  },\n\n  render: function * (ctx: Context, emitter: Emitter) {\n    let collection = toEnumerable(yield evalToken(this.collection, ctx))\n    const hash = yield this.hash.render(ctx)\n    const offset = hash.offset || 0\n    const limit = (hash.limit === undefined) ? collection.length : hash.limit\n\n    collection = collection.slice(offset, offset + limit)\n    const cols = hash.cols || collection.length\n\n    const r = this.liquid.renderer\n    const tablerowloop = new TablerowloopDrop(collection.length, cols, this.collection.getText(), this.variable)\n    const scope = { tablerowloop }\n    ctx.push(scope)\n\n    for (let idx = 0; idx < collection.length; idx++, tablerowloop.next()) {\n      scope[this.variable] = collection[idx]\n      if (tablerowloop.col0() === 0) {\n        if (tablerowloop.row() !== 1) emitter.write('</tr>')\n        emitter.write(`<tr class=\"row${tablerowloop.row()}\">`)\n      }\n      emitter.write(`<td class=\"col${tablerowloop.col()}\">`)\n      yield r.renderTemplates(this.templates, ctx, emitter)\n      emitter.write('</td>')\n    }\n    if (collection.length) emitter.write('</tr>')\n    ctx.pop()\n  }\n} as TagImplOptions\n","import { Value, TopLevelToken, Template, Emitter, isTruthy, isFalsy, Context, TagImplOptions, TagToken } from '../../types'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    this.branches = []\n    this.elseTemplates = []\n    let p\n    this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => this.branches.push({\n        predicate: new Value(tagToken.args, this.liquid),\n        test: isFalsy,\n        templates: (p = [])\n      }))\n      .on('tag:elsif', (token: TagToken) => this.branches.push({\n        predicate: new Value(token.args, this.liquid),\n        test: isTruthy,\n        templates: (p = [])\n      }))\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endunless', function () { this.stop() })\n      .on('template', (tpl: Template) => p.push(tpl))\n      .on('end', () => { throw new Error(`tag ${tagToken.getText()} not closed`) })\n      .start()\n  },\n\n  render: function * (ctx: Context, emitter: Emitter) {\n    const r = this.liquid.renderer\n\n    for (const { predicate, test, templates } of this.branches) {\n      const value = yield predicate.value(ctx, ctx.opts.lenientIf)\n      if (test(value, ctx)) {\n        yield r.renderTemplates(templates, ctx, emitter)\n        return\n      }\n    }\n\n    yield r.renderTemplates(this.elseTemplates, ctx, emitter)\n  }\n} as TagImplOptions\n","import { Emitter, Context } from '../../types'\n\nexport default {\n  render: function (ctx: Context, emitter: Emitter) {\n    emitter['break'] = true\n  }\n}\n","import { Emitter, Context } from '../../types'\n\nexport default {\n  render: function (ctx: Context, emitter: Emitter) {\n    emitter['continue'] = true\n  }\n}\n","import { stringify } from '../../util/underscore'\n\nconst escapeMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&#34;',\n  \"'\": '&#39;'\n}\nconst unescapeMap = {\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>',\n  '&#34;': '\"',\n  '&#39;': \"'\"\n}\n\nexport function escape (str: string) {\n  return stringify(str).replace(/&|<|>|\"|'/g, m => escapeMap[m])\n}\n\nfunction unescape (str: string) {\n  return String(str).replace(/&(amp|lt|gt|#34|#39);/g, m => unescapeMap[m])\n}\n\nexport function escapeOnce (str: string) {\n  return escape(unescape(str))\n}\n\nexport function newlineToBr (v: string) {\n  return v.replace(/\\n/g, '<br />\\n')\n}\n\nexport function stripHtml (v: string) {\n  return v.replace(/<script.*?<\\/script>|<!--.*?-->|<style.*?<\\/style>|<.*?>/g, '')\n}\n","import { caseInsensitiveCompare } from '../../util/underscore'\n\nexport const abs = Math.abs\nexport const atLeast = Math.max\nexport const atMost = Math.min\nexport const ceil = Math.ceil\nexport const dividedBy = (v: number, arg: number) => v / arg\nexport const floor = Math.floor\nexport const minus = (v: number, arg: number) => v - arg\nexport const modulo = (v: number, arg: number) => v % arg\nexport const times = (v: number, arg: number) => v * arg\n\nexport function round (v: number, arg = 0) {\n  const amp = Math.pow(10, arg)\n  return Math.round(v * amp) / amp\n}\n\nexport function plus (v: number, arg: number) {\n  return Number(v) + Number(arg)\n}\n\nexport function sortNatural (input: any[], property?: string) {\n  if (!input || !input.sort) return []\n  if (property !== undefined) {\n    return [...input].sort(\n      (lhs, rhs) => caseInsensitiveCompare(lhs[property], rhs[property])\n    )\n  }\n  return [...input].sort(caseInsensitiveCompare)\n}\n","import { changeCase, padStart, padEnd } from './underscore'\n\nconst rFormat = /%([-_0^#:]+)?(\\d+)?([EO])?(.)/\nconst monthNames = [\n  'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',\n  'September', 'October', 'November', 'December'\n]\nconst dayNames = [\n  'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'\n]\nconst monthNamesShort = monthNames.map(abbr)\nconst dayNamesShort = dayNames.map(abbr)\nconst suffixes = {\n  1: 'st',\n  2: 'nd',\n  3: 'rd',\n  'default': 'th'\n}\ninterface FormatOptions {\n  flags: object;\n  width?: string;\n  modifier?: string;\n}\n\nfunction abbr (str: string) {\n  return str.slice(0, 3)\n}\n\n// prototype extensions\nfunction daysInMonth (d: Date) {\n  const feb = isLeapYear(d) ? 29 : 28\n  return [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n}\nfunction getDayOfYear (d: Date) {\n  let num = 0\n  for (let i = 0; i < d.getMonth(); ++i) {\n    num += daysInMonth(d)[i]\n  }\n  return num + d.getDate()\n}\nfunction getWeekOfYear (d: Date, startDay: number) {\n  // Skip to startDay of this week\n  const now = getDayOfYear(d) + (startDay - d.getDay())\n  // Find the first startDay of the year\n  const jan1 = new Date(d.getFullYear(), 0, 1)\n  const then = (7 - jan1.getDay() + startDay)\n  return String(Math.floor((now - then) / 7) + 1)\n}\nfunction isLeapYear (d: Date) {\n  const year = d.getFullYear()\n  return !!((year & 3) === 0 && (year % 100 || (year % 400 === 0 && year)))\n}\nfunction getSuffix (d: Date) {\n  const str = d.getDate().toString()\n  const index = parseInt(str.slice(-1))\n  return suffixes[index] || suffixes['default']\n}\nfunction century (d: Date) {\n  return parseInt(d.getFullYear().toString().substring(0, 2), 10)\n}\n\n// default to 0\nconst padWidths = {\n  d: 2,\n  e: 2,\n  H: 2,\n  I: 2,\n  j: 3,\n  k: 2,\n  l: 2,\n  L: 3,\n  m: 2,\n  M: 2,\n  S: 2,\n  U: 2,\n  W: 2\n}\n\n// default to '0'\nconst padChars = {\n  a: ' ',\n  A: ' ',\n  b: ' ',\n  B: ' ',\n  c: ' ',\n  e: ' ',\n  k: ' ',\n  l: ' ',\n  p: ' ',\n  P: ' '\n}\nconst formatCodes = {\n  a: (d: Date) => dayNamesShort[d.getDay()],\n  A: (d: Date) => dayNames[d.getDay()],\n  b: (d: Date) => monthNamesShort[d.getMonth()],\n  B: (d: Date) => monthNames[d.getMonth()],\n  c: (d: Date) => d.toLocaleString(),\n  C: (d: Date) => century(d),\n  d: (d: Date) => d.getDate(),\n  e: (d: Date) => d.getDate(),\n  H: (d: Date) => d.getHours(),\n  I: (d: Date) => String(d.getHours() % 12 || 12),\n  j: (d: Date) => getDayOfYear(d),\n  k: (d: Date) => d.getHours(),\n  l: (d: Date) => String(d.getHours() % 12 || 12),\n  L: (d: Date) => d.getMilliseconds(),\n  m: (d: Date) => d.getMonth() + 1,\n  M: (d: Date) => d.getMinutes(),\n  N: (d: Date, opts: FormatOptions) => {\n    const width = Number(opts.width) || 9\n    const str = String(d.getMilliseconds()).substr(0, width)\n    return padEnd(str, width, '0')\n  },\n  p: (d: Date) => (d.getHours() < 12 ? 'AM' : 'PM'),\n  P: (d: Date) => (d.getHours() < 12 ? 'am' : 'pm'),\n  q: (d: Date) => getSuffix(d),\n  s: (d: Date) => Math.round(d.valueOf() / 1000),\n  S: (d: Date) => d.getSeconds(),\n  u: (d: Date) => d.getDay() || 7,\n  U: (d: Date) => getWeekOfYear(d, 0),\n  w: (d: Date) => d.getDay(),\n  W: (d: Date) => getWeekOfYear(d, 1),\n  x: (d: Date) => d.toLocaleDateString(),\n  X: (d: Date) => d.toLocaleTimeString(),\n  y: (d: Date) => d.getFullYear().toString().substring(2, 4),\n  Y: (d: Date) => d.getFullYear(),\n  z: (d: Date, opts: FormatOptions) => {\n    const nOffset = Math.abs(d.getTimezoneOffset())\n    const h = Math.floor(nOffset / 60)\n    const m = nOffset % 60\n    return (d.getTimezoneOffset() > 0 ? '-' : '+') +\n      padStart(h, 2, '0') +\n      (opts.flags[':'] ? ':' : '') +\n      padStart(m, 2, '0')\n  },\n  't': () => '\\t',\n  'n': () => '\\n',\n  '%': () => '%'\n};\n(formatCodes as any).h = formatCodes.b\n\nexport default function (d: Date, formatStr: string) {\n  let output = ''\n  let remaining = formatStr\n  let match\n  while ((match = rFormat.exec(remaining))) {\n    output += remaining.slice(0, match.index)\n    remaining = remaining.slice(match.index + match[0].length)\n    output += format(d, match)\n  }\n  return output + remaining\n}\n\nfunction format (d: Date, match: RegExpExecArray) {\n  const [input, flagStr = '', width, modifier, conversion] = match\n  const convert = formatCodes[conversion]\n  if (!convert) return input\n  const flags = {}\n  for (const flag of flagStr) flags[flag] = true\n  let ret = String(convert(d, { flags, width, modifier }))\n  let padChar = padChars[conversion] || '0'\n  let padWidth = width || padWidths[conversion] || 0\n  if (flags['^']) ret = ret.toUpperCase()\n  else if (flags['#']) ret = changeCase(ret)\n  if (flags['_']) padChar = ' '\n  else if (flags['0']) padChar = '0'\n  if (flags['-']) padWidth = 0\n  return padStart(ret, padWidth, padChar)\n}\n","// one minute in milliseconds\nconst OneMinute = 60000\nconst hostTimezoneOffset = new Date().getTimezoneOffset()\nconst ISO8601_TIMEZONE_PATTERN = /([zZ]|([+-])(\\d{2}):(\\d{2}))$/\n\n/**\n * A date implementation with timezone info, just like Ruby date\n *\n * Implementation:\n * - create a Date offset by it's timezone difference, avoiding overriding a bunch of methods\n * - rewrite getTimezoneOffset() to trick strftime\n */\nexport class TimezoneDate extends Date {\n  private timezoneOffset?: number\n  constructor (init: string | number | Date, timezoneOffset: number) {\n    if (init instanceof TimezoneDate) return init\n    const diff = (hostTimezoneOffset - timezoneOffset) * OneMinute\n    const time = new Date(init).getTime() + diff\n    super(time)\n    this.timezoneOffset = timezoneOffset\n  }\n  getTimezoneOffset () {\n    return this.timezoneOffset!\n  }\n\n  /**\n   * Create a Date object fixed to it's declared Timezone. Both\n   * - 2021-08-06T02:29:00.000Z and\n   * - 2021-08-06T02:29:00.000+08:00\n   * will always be displayed as\n   * - 2021-08-06 02:29:00\n   * regardless timezoneOffset in JavaScript realm\n   *\n   * The implementation hack:\n   * Instead of calling `.getMonth()`/`.getUTCMonth()` respect to `preserveTimezones`,\n   * we create a different Date to trick strftime, it's both simpler and more performant.\n   * Given that a template is expected to be parsed fewer times than rendered.\n   */\n  static createDateFixedToTimezone (dateString: string) {\n    const m = dateString.match(ISO8601_TIMEZONE_PATTERN)\n    // representing a UTC timestamp\n    if (m && m[1] === 'Z') {\n      return new TimezoneDate(+new Date(dateString), 0)\n    }\n    // has a timezone specified\n    if (m && m[2] && m[3] && m[4]) {\n      const [, , sign, hours, minutes] = m\n      const delta = (sign === '+' ? -1 : 1) * (parseInt(hours, 10) * 60 + parseInt(minutes, 10))\n      return new TimezoneDate(+new Date(dateString), delta)\n    }\n    return new Date(dateString)\n  }\n}\n","export const urlDecode = (x: string) => x.split('+').map(decodeURIComponent).join(' ')\nexport const urlEncode = (x: string) => x.split(' ').map(encodeURIComponent).join('+')\n","import { isArray, isNil, last as arrayLast } from '../../util/underscore'\nimport { toArray } from '../../util/collection'\nimport { isTruthy } from '../../render/boolean'\nimport { FilterImpl } from '../../template/filter/filter-impl'\nimport { Scope } from '../../context/scope'\n\nexport const join = (v: any[], arg: string) => v.join(arg === undefined ? ' ' : arg)\nexport const last = (v: any) => isArray(v) ? arrayLast(v) : ''\nexport const first = (v: any) => isArray(v) ? v[0] : ''\nexport const reverse = (v: any[]) => [...v].reverse()\n\nexport function sort<T> (this: FilterImpl, arr: T[], property?: string) {\n  const getValue = (obj: Scope) => property ? this.context.getFromScope(obj, property.split('.')) : obj\n  return toArray(arr).sort((lhs, rhs) => {\n    lhs = getValue(lhs)\n    rhs = getValue(rhs)\n    return lhs < rhs ? -1 : (lhs > rhs ? 1 : 0)\n  })\n}\n\nexport const size = (v: string | any[]) => (v && v.length) || 0\n\nexport function map<T1, T2> (this: FilterImpl, arr: Scope[], property: string) {\n  return toArray(arr).map(obj => this.context.getFromScope(obj, property.split('.')))\n}\n\nexport function compact<T> (this: FilterImpl, arr: T[]) {\n  return toArray(arr).filter(x => !isNil(x))\n}\n\nexport function concat<T1, T2> (v: T1[], arg: T2[] | T2): (T1 | T2)[] {\n  return toArray(v).concat(arg)\n}\n\nexport function slice<T> (v: T[], begin: number, length = 1): T[] {\n  begin = begin < 0 ? v.length + begin : begin\n  return v.slice(begin, begin + length)\n}\n\nexport function where<T extends object> (this: FilterImpl, arr: T[], property: string, expected?: any): T[] {\n  return toArray(arr).filter(obj => {\n    const value = this.context.getFromScope(obj, String(property).split('.'))\n    return expected === undefined ? isTruthy(value, this.context) : value === expected\n  })\n}\n\nexport function uniq<T> (arr: T[]): T[] {\n  const u = {}\n  return (arr || []).filter(val => {\n    if (u.hasOwnProperty(String(val))) return false\n    u[String(val)] = true\n    return true\n  })\n}\n","import strftime from '../../util/strftime'\nimport { isString, isNumber } from '../../util/underscore'\nimport { FilterImpl } from '../../template/filter/filter-impl'\nimport { TimezoneDate } from '../../util/timezone-date'\n\nexport function date (this: FilterImpl, v: string | Date, arg: string) {\n  const opts = this.context.opts\n  let date: Date\n  if (v === 'now' || v === 'today') {\n    date = new Date()\n  } else if (isNumber(v)) {\n    date = new Date(v * 1000)\n  } else if (isString(v)) {\n    if (/^\\d+$/.test(v)) {\n      date = new Date(+v * 1000)\n    } else if (opts.preserveTimezones) {\n      date = TimezoneDate.createDateFixedToTimezone(v)\n    } else {\n      date = new Date(v)\n    }\n  } else {\n    date = v\n  }\n  if (!isValidDate(date)) return v\n  if (opts.hasOwnProperty('timezoneOffset')) {\n    date = new TimezoneDate(date, opts.timezoneOffset!)\n  }\n  return strftime(date, arg)\n}\n\nfunction isValidDate (date: any): date is Date {\n  return date instanceof Date && !isNaN(date.getTime())\n}\n","import { isFalsy } from '../../render/boolean'\nimport { isArray, isString, toValue } from '../../util/underscore'\nimport { FilterImpl } from '../../template/filter/filter-impl'\n\nexport function Default<T1, T2> (this: FilterImpl, v: string | T1, arg: T2): string | T1 | T2 {\n  if (isArray(v) || isString(v)) return v.length ? v : arg\n  return isFalsy(toValue(v), this.context) ? arg : v\n}\nexport function json (v: any) {\n  return JSON.stringify(v)\n}\n","/**\n * String related filters\n *\n * * prefer stringify() to String() since `undefined`, `null` should eval ''\n */\nimport { stringify } from '../../util/underscore'\nimport { assert } from '../../util/assert'\n\nexport function append (v: string, arg: string) {\n  assert(arguments.length === 2, 'append expect 2 arguments')\n  return stringify(v) + stringify(arg)\n}\n\nexport function prepend (v: string, arg: string) {\n  assert(arguments.length === 2, 'prepend expect 2 arguments')\n  return stringify(arg) + stringify(v)\n}\n\nexport function lstrip (v: string) {\n  return stringify(v).replace(/^\\s+/, '')\n}\n\nexport function downcase (v: string) {\n  return stringify(v).toLowerCase()\n}\n\nexport function upcase (str: string) {\n  return stringify(str).toUpperCase()\n}\n\nexport function remove (v: string, arg: string) {\n  return stringify(v).split(String(arg)).join('')\n}\n\nexport function removeFirst (v: string, l: string) {\n  return stringify(v).replace(String(l), '')\n}\n\nexport function rstrip (str: string) {\n  return stringify(str).replace(/\\s+$/, '')\n}\n\nexport function split (v: string, arg: string) {\n  return stringify(v).split(String(arg))\n}\n\nexport function strip (v: string) {\n  return stringify(v).trim()\n}\n\nexport function stripNewlines (v: string) {\n  return stringify(v).replace(/\\n/g, '')\n}\n\nexport function capitalize (str: string) {\n  str = stringify(str)\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()\n}\n\nexport function replace (v: string, pattern: string, replacement: string) {\n  return stringify(v).split(String(pattern)).join(replacement)\n}\n\nexport function replaceFirst (v: string, arg1: string, arg2: string) {\n  return stringify(v).replace(String(arg1), arg2)\n}\n\nexport function truncate (v: string, l = 50, o = '...') {\n  v = stringify(v)\n  if (v.length <= l) return v\n  return v.substr(0, l - o.length) + o\n}\n\nexport function truncatewords (v: string, l = 15, o = '...') {\n  const arr = v.split(/\\s+/)\n  let ret = arr.slice(0, l).join(' ')\n  if (arr.length >= l) ret += o\n  return ret\n}\n","import { TagImplOptions } from './tag-impl-options'\nimport { assert } from '../../util/assert'\n\nexport class TagMap {\n  private impls: {[key: string]: TagImplOptions} = {}\n\n  get (name: string) {\n    const impl = this.impls[name]\n    assert(impl, () => `tag \"${name}\" not found`)\n    return impl\n  }\n\n  set (name: string, impl: TagImplOptions) {\n    this.impls[name] = impl\n  }\n}\n","import { FilterImplOptions } from './filter-impl-options'\nimport { Filter } from './filter'\nimport { FilterArg } from '../../parser/filter-arg'\nimport { assert } from '../../util/assert'\nimport { Liquid } from '../../liquid'\n\nexport class FilterMap {\n  private impls: {[key: string]: FilterImplOptions} = {}\n\n  constructor (\n    private readonly strictFilters: boolean,\n    private readonly liquid: Liquid\n  ) {}\n\n  get (name: string) {\n    const impl = this.impls[name]\n    assert(impl || !this.strictFilters, () => `undefined filter: ${name}`)\n    return impl\n  }\n\n  set (name: string, impl: FilterImplOptions) {\n    this.impls[name] = impl\n  }\n\n  create (name: string, args: FilterArg[]) {\n    return new Filter(name, this.get(name), args, this.liquid)\n  }\n}\n","import { Context } from './context/context'\nimport { forOwn, snakeCase } from './util/underscore'\nimport { Template } from './template/template'\nimport { LookupType } from './fs/loader'\nimport { Render } from './render/render'\nimport Parser from './parser/parser'\nimport { TagImplOptions } from './template/tag/tag-impl-options'\nimport { Value } from './template/value'\nimport builtinTags from './builtin/tags'\nimport * as builtinFilters from './builtin/filters'\nimport { TagMap } from './template/tag/tag-map'\nimport { FilterMap } from './template/filter/filter-map'\nimport { LiquidOptions, normalizeDirectoryList, NormalizedFullOptions, applyDefault, normalize } from './liquid-options'\nimport { FilterImplOptions } from './template/filter/filter-impl-options'\nimport { toPromise, toValue } from './util/async'\n\nexport * from './util/error'\nexport * from './types'\n\nexport class Liquid {\n  public readonly options: NormalizedFullOptions\n  public readonly renderer: Render\n  public readonly parser: Parser\n  public readonly filters: FilterMap\n  public readonly tags: TagMap\n\n  public constructor (opts: LiquidOptions = {}) {\n    this.options = applyDefault(normalize(opts))\n    this.parser = new Parser(this)\n    this.renderer = new Render()\n    this.filters = new FilterMap(this.options.strictFilters, this)\n    this.tags = new TagMap()\n\n    forOwn(builtinTags, (conf: TagImplOptions, name: string) => this.registerTag(snakeCase(name), conf))\n    forOwn(builtinFilters, (handler: FilterImplOptions, name: string) => this.registerFilter(snakeCase(name), handler))\n  }\n  public parse (html: string, filepath?: string): Template[] {\n    return this.parser.parse(html, filepath)\n  }\n\n  public _render (tpl: Template[], scope?: object, sync?: boolean): IterableIterator<any> {\n    const ctx = new Context(scope, this.options, sync)\n    return this.renderer.renderTemplates(tpl, ctx)\n  }\n  public async render (tpl: Template[], scope?: object): Promise<any> {\n    return toPromise(this._render(tpl, scope, false))\n  }\n  public renderSync (tpl: Template[], scope?: object): any {\n    return toValue(this._render(tpl, scope, true))\n  }\n  public renderToNodeStream (tpl: Template[], scope?: object): NodeJS.ReadableStream {\n    const ctx = new Context(scope, this.options)\n    return this.renderer.renderTemplatesToNodeStream(tpl, ctx)\n  }\n\n  public _parseAndRender (html: string, scope?: object, sync?: boolean): IterableIterator<any> {\n    const tpl = this.parse(html)\n    return this._render(tpl, scope, sync)\n  }\n  public async parseAndRender (html: string, scope?: object): Promise<any> {\n    return toPromise(this._parseAndRender(html, scope, false))\n  }\n  public parseAndRenderSync (html: string, scope?: object): any {\n    return toValue(this._parseAndRender(html, scope, true))\n  }\n\n  public _parsePartialFile (file: string, sync?: boolean, currentFile?: string) {\n    return this.parser.parseFile(file, sync, LookupType.Partials, currentFile)\n  }\n  public _parseLayoutFile (file: string, sync?: boolean, currentFile?: string) {\n    return this.parser.parseFile(file, sync, LookupType.Layouts, currentFile)\n  }\n  public async parseFile (file: string): Promise<Template[]> {\n    return toPromise<Template[]>(this.parser.parseFile(file, false))\n  }\n  public parseFileSync (file: string): Template[] {\n    return toValue<Template[]>(this.parser.parseFile(file, true))\n  }\n  public async renderFile (file: string, ctx?: object) {\n    const templates = await this.parseFile(file)\n    return this.render(templates, ctx)\n  }\n  public renderFileSync (file: string, ctx?: object) {\n    const templates = this.parseFileSync(file)\n    return this.renderSync(templates, ctx)\n  }\n  public async renderFileToNodeStream (file: string, scope?: object) {\n    const templates = await this.parseFile(file)\n    return this.renderToNodeStream(templates, scope)\n  }\n\n  public _evalValue (str: string, ctx: Context): IterableIterator<any> {\n    const value = new Value(str, this)\n    return value.value(ctx, false)\n  }\n  public async evalValue (str: string, ctx: Context): Promise<any> {\n    return toPromise(this._evalValue(str, ctx))\n  }\n  public evalValueSync (str: string, ctx: Context): any {\n    return toValue(this._evalValue(str, ctx))\n  }\n\n  public registerFilter (name: string, filter: FilterImplOptions) {\n    this.filters.set(name, filter)\n  }\n  public registerTag (name: string, tag: TagImplOptions) {\n    this.tags.set(name, tag)\n  }\n  public plugin (plugin: (this: Liquid, L: typeof Liquid) => void) {\n    return plugin.call(this, Liquid)\n  }\n  public express () {\n    const self = this // eslint-disable-line\n    let firstCall = true\n\n    return function (this: any, filePath: string, ctx: object, callback: (err: Error | null, rendered: string) => void) {\n      if (firstCall) {\n        firstCall = false\n        self.options.root.unshift(...normalizeDirectoryList(this.root))\n      }\n      self.renderFile(filePath, ctx).then(html => callback(null, html) as any, callback as any)\n    }\n  }\n}\n"],"names":["Drop","key","toStr","Object","prototype","toString","toLowerCase","String","isString","value","isFunction","stringify","toValue","isNil","valueOf","isNumber","isArray","call","forOwn","object","iteratee","k","hasOwnProperty","last","arr","length","isObject","type","range","start","stop","step","i","push","padStart","str","ch","pad","add","n","identify","val","snakeCase","replace","_","a","b","caseInsensitiveCompare","next","prev","this","LRU","cache","node","Node","head","size","ensureLimit","remove","write","tail","limit","domResolve","root","path","base","document","createElement","href","getElementsByTagName","insertBefore","firstChild","resolved","removeChild","filepath","ext","origin","split","pop","test","url","Promise","resolve","reject","xhr","XMLHttpRequest","onload","status","responseText","Error","statusText","onerror","open","send","isComparable","arg","equals","isTruthy","ctx","isFalsy","opts","jsTruthy","defaultOperators","==","l","r","!=",">","gt","lt","<",">=","geq","leq","<=","contains","indexOf","and","or","TYPES","IDENTIFIER","BLANK","INLINE_BLANK","createTrie","operators","trie","_b","tslib_1.__values","entries","_d","name_1","handler","c","charCodeAt","needBoundary","end","defaultOptions","layouts","partials","relativeReference","undefined","extname","fs","dynamicPartials","trimTagRight","trimTagLeft","trimOutputRight","trimOutputLeft","greedy","tagDelimiterLeft","tagDelimiterRight","outputDelimiterLeft","outputDelimiterRight","preserveTimezones","strictFilters","strictVariables","lenientIf","globals","keepOutputType","operatorsTrie","normalizeDirectoryList","list","_.isArray","_.isString","tslib_1.__extends","LiquidError","err","originalError","context","token","line","lines","input","begin","Math","max","min","_\r\n        .range","map","lineNumber","_.padStart","join","mkContext","message","msg","file","_a","col","mkMessage","stack","_super","_this","name","update","RenderError","obj","tpl","variableName","LookupType","Context","registers","_i","keys","getRegister","keyValues","forEach","setRegister","tslib_1.__spread","environments","scopes","reduce","__assign","paths","scope","findScope","getFromScope","toLiquid","liquidMethodMissing","readSize","readFirst","readLast","readProperty","InternalUndefinedVariableError","candidate","env","sync","assert","predicate","AssertionError","Loader","currentFile","options","dirs","candidates","Root","_c","existsSync","exists","_e","lookupError","referencedFile","rRelativePath","enforceRoot","shouldLoadRelative","referenced","dirname","dirs_1","dir","withinDir","dirs_2","fallback","endsWith","sep","startsWith","roots","code","RegExp","prefix","escapeRegex","SimpleEmitter","html","buffer","createResolvedThenable","ret","then","catch","createRejectedThenable","toThenable","isThenable","throw","return","isAsyncIterator","state","done","e","toPromise","x","KeepingTypeEmitter","TokenKind","Render","templates","emitter","StreamedEmitter","renderTemplates","error","stream","templates_1","render","is","e_1","isDelimitedToken","getKind","Delimited","isOperatorToken","Operator","isHTMLToken","HTML","isOutputToken","Output","isTagToken","Tag","isQuotedToken","Quoted","isLiteralToken","Literal","isNumberToken","Number","isPropertyAccessToken","PropertyAccess","isWordToken","Word","isRangeToken","Range","kind","ParseStream","cb","handlers","event","h","trigger","stopRequested","tokens","shift","template","parseToken","NullDrop","EmptyDrop","BlankDrop","nil","literalValues","true","false","null","empty","blank","rHex","rOct","escapeChar","f","t","v","hexVal","parseStringLiteral","j","fromCharCode","Expression","lenient","operands","postfix","TypeGuards.isOperatorToken","_f","result","lhs","rhs","impl","operator","evalOperatorToken","evalToken","ops","tokens_1","getPrecedence","toPostfix","TypeGuards.isPropertyAccessToken","props","prop","get","propertyName","UndefinedVariableError","evalPropertyAccessToken","TypeGuards.isRangeToken","low","high","evalRangeToken","TypeGuards.isLiteralToken","literal","evalLiteralToken","TypeGuards.isNumberToken","whole","content","decimal","evalNumberToken","TypeGuards.isWordToken","getText","TypeGuards.isQuotedToken","evalQuotedToken","Token","slice","row","trimLeft","trimRight","tl","tr","trim","mask","charAt","IdentifierToken","allowSign","precedence","OperatorToken","variable","args","Filter","Hash","HTMLToken","DelimitedToken","Tokenizer","readExpressionTokens","operand","readValue","p","N","readOperator","operand_1","skipBlank","info","matchOperator","filters","filter","readFilter","peek","snapshot","readIdentifier","readFilterArg","FilterToken","readTopLevelToken","inRaw","whiteSpaceCtrl","rawBeginAt","readEndrawOrRawContent","match","readTagToken","readOutputToken","readHTMLToken","readToDelimiter","mkError","TagToken","delimiter","peekType","readQuoted","rmatch","OutputToken","leftPos","readTo","TokenizationError","JSON","substr","ellipsis","console","warn","hashes","hash","readHash","HashToken","readRange","PropertyAccessToken","LiteralToken","NumberToken","readValueOrThrow","RangeToken","escaped","QuotedToken","word","pattern","tokenizer","remaining","_g","markup","readHashes","argv","apply","liquid","Value","initial","evaluate","readExpression","readFilters","TemplateImpl","tags","create","parse","getContent","Parser","readTopLevelTokens","parseTokens","remainTokens","ParseError","loader","read","tpls","task","_parseFile","lookup","readFileSync","readFile","parseFile","_parseFileCached","advance","bottom","_evalValue","toEnumerable","toArray","ForloopDrop","collection","MODIFIERS","inStr","elseTemplates","parser","parseStream","on","renderer","modifiers","orderedFilterParameters","includes","modifier","count","offset","reverse","reversed","forloop","collection_1","item","tagToken","quoted","readVariableName","BlockMode","cond","cases","branch","parseFilePath","renderFilePath","keyword","beforeAs","alias","childCtx","_parsePartialFile","TypeError","TypeGuards.isHTMLToken","readFileName","Array","withVar","saved","saveRegister","OUTPUT","restoreRegister","group","fingerprint","groups","idx","branches","_parseLayoutFile","STORE","blocks","parent","BlockDrop","superBlockRender","exec","block","blockRender","getBlockRender","renderCurrent","superBlock","renderChild","TablerowloopDrop","floor","cols","col0","assign","for","For","capture","case","Case","comment","include","decrement","increment","cycle","if","If","layout","raw","tablerow","tmp","tablerowloop","unless","test_1","break","continue","escapeMap","&","\"","'","unescapeMap","&amp;","&lt;","&gt;","&#34;","&#39;","escape","m","abs","atLeast","atMost","ceil","rFormat","monthNames","dayNames","monthNamesShort","abbr","dayNamesShort","suffixes","1","2","3","default","getDayOfYear","d","num","getMonth","year","getFullYear","isLeapYear","getDate","getWeekOfYear","startDay","now","getDay","Date","padWidths","H","I","L","M","S","U","W","padChars","A","B","P","formatCodes","toLocaleString","C","parseInt","substring","century","getHours","getMilliseconds","getMinutes","width","padEnd","q","index","getSuffix","s","round","getSeconds","u","w","toLocaleDateString","X","toLocaleTimeString","y","Y","z","nOffset","getTimezoneOffset","flags","%","format","flagStr","conversion","convert","flagStr_1","padChar","padWidth","toUpperCase","some","changeCase","hostTimezoneOffset","ISO8601_TIMEZONE_PATTERN","TimezoneDate","timezoneOffset","dateString","sign","hours","minutes","delta","init","diff","time","getTime","unescape","amp","pow","property","sort","decodeURIComponent","encodeURIComponent","arrayLast","getValue","concat","expected","date","isNaN","isValidDate","createDateFixedToTimezone","formatStr","output","strftime","arguments","replacement","arg1","arg2","o","TagMap","impls","FilterMap","Liquid","_render","renderTemplatesToNodeStream","_parseAndRender","Partials","Layouts","parseFileSync","renderSync","renderToNodeStream","set","tag","plugin","self","firstCall","filePath","callback","unshift","renderFile","fullOptions","applyDefault","normalize","builtinTags","conf","registerTag","builtinFilters","registerFilter"],"mappings":"shFACSA,oBAAP,aAIOA,gCAAP,SAA4BC,QAL9B,cCEA,IAAMC,EAAQC,OAAOC,UAAUC,SACzBC,EAAcC,OAAOH,UAAUE,qBAErBE,EAAUC,GACxB,MAAwB,iBAAVA,WAGAC,EAAYD,GAC1B,MAAwB,mBAAVA,WAmBAE,EAAWF,GAEzB,OAAID,EADJC,EAAQG,EAAQH,IACYA,EACxBI,EAAMJ,GAAe,GAClBF,OAAOE,YAGAG,EAASH,GACvB,OAAOA,aAAiBT,EAAOS,EAAMK,UAAYL,WAGnCM,EAAUN,GACxB,MAAwB,iBAAVA,WAQAI,EAAOJ,GACrB,OAAgB,MAATA,WAGOO,EAASP,GAEvB,MAA6B,mBAAtBP,EAAMe,KAAKR,YAWJS,EACdC,EACAC,GAGA,IAAK,IAAMC,KADXF,EAASA,GAAU,GAEjB,GAAIA,EAAOG,eAAeD,KACe,IAAnCD,EAASD,EAAOE,GAAIA,EAAGF,GAAmB,MAGlD,OAAOA,WAKOI,EAAMC,GACpB,OAAOA,EAAIA,EAAIC,OAAS,YASVC,EAAUjB,GACxB,IAAMkB,SAAclB,EACpB,OAAiB,OAAVA,IAA4B,UAATkB,GAA8B,YAATA,YAGjCC,EAAOC,EAAeC,EAAcC,gBAAAA,KAElD,IADA,IAAMP,EAAgB,GACbQ,EAAIH,EAAOG,EAAIF,EAAME,GAAKD,EACjCP,EAAIS,KAAKD,GAEX,OAAOR,WAGOU,EAAUC,EAAUV,EAAgBW,GAClD,oBADkDA,OAC3CC,EAAIF,EAAKV,EAAQW,EAAI,SAACD,EAAKC,GAAO,OAAAA,EAAKD,aAOhCE,EAAKF,EAAUV,EAAgBW,EAAYE,GAGzD,IADA,IAAIC,EAAId,GADRU,EAAM5B,OAAO4B,IACQV,OACR,EAANc,KAASJ,EAAMG,EAAIH,EAAKC,GAC/B,OAAOD,WAGOK,EAAaC,GAC3B,OAAOA,WAGOC,EAAWP,GACzB,OAAOA,EAAIQ,QACT,gBACA,SAACC,EAAGC,EAAGC,GAAM,OAACD,EAAIA,EAAI,IAAM,IAAMC,EAAExC,yBAcxByC,EAAwBF,EAAQC,GAC9C,OAAS,MAALD,GAAkB,MAALC,EAAkB,EAC1B,MAALD,EAAkB,EACb,MAALC,GAAmB,GACvBD,EAAIvC,EAAYW,KAAK4B,KACrBC,EAAIxC,EAAYW,KAAK6B,KACF,EACXA,EAAJD,EAAc,EACX,EClJT,MACE,SACS5C,EACAQ,EACAuC,EACAC,GAHAC,SAAAjD,EACAiD,WAAAzC,EACAyC,UAAAF,EACAE,UAAAD,MAmBTE,kBAAA,SAAOlD,EAAaQ,GAClB,GAAIyC,KAAKE,MAAMnD,GACbiD,KAAKE,MAAMnD,GAAKQ,MAAQA,MACnB,CACL,IAAM4C,EAAO,IAAIC,EAAKrD,EAAKQ,EAAOyC,KAAKK,KAAKP,KAAME,KAAKK,MACvDL,KAAKK,KAAKP,KAAKC,KAAOI,EACtBH,KAAKK,KAAKP,KAAOK,EAEjBH,KAAKE,MAAMnD,GAAOoD,EAClBH,KAAKM,OACLN,KAAKO,gBAITN,iBAAA,SAAMlD,GACJ,GAAKiD,KAAKE,MAAMnD,GAAhB,CACQ,IAAAQ,sBAGR,OAFAyC,KAAKQ,OAAOzD,GACZiD,KAAKS,MAAM1D,EAAKQ,GACTA,IAGT0C,mBAAA,SAAQlD,GACN,IAAMoD,EAAOH,KAAKE,MAAMnD,GACxBoD,EAAKJ,KAAKD,KAAOK,EAAKL,KACtBK,EAAKL,KAAKC,KAAOI,EAAKJ,YACfC,KAAKE,MAAMnD,GAClBiD,KAAKM,QAGPL,kBAAA,WACED,KAAKK,KAAKP,KAAOE,KAAKU,KACtBV,KAAKU,KAAKX,KAAOC,KAAKK,KACtBL,KAAKM,KAAO,EACZN,KAAKE,MAAQ,IAGPD,wBAAR,WACMD,KAAKM,KAAON,KAAKW,OAAOX,KAAKQ,OAAOR,KAAKU,KAAKX,KAAKhD,SAhDzD,WACS4D,EACAL,gBAAAA,KADAN,WAAAW,EACAX,UAAAM,EANDN,WAAoC,GAQ1CA,KAAKK,KAAO,IAAID,EAAQ,OAAQ,KAAa,KAAa,MAC1DJ,KAAKU,KAAO,IAAIN,EAAQ,OAAQ,KAAa,KAAa,MAC1DJ,KAAKK,KAAKP,KAAOE,KAAKU,KACtBV,KAAKU,KAAKX,KAAOC,KAAKK,KCrB1B,SAASO,EAAYC,EAAcC,GACjC,IAAMC,EAAOC,SAASC,cAAc,QACpCF,EAAKG,KAAOL,EAEZ,IAAMR,EAAOW,SAASG,qBAAqB,QAAQ,GACnDd,EAAKe,aAAaL,EAAMV,EAAKgB,YAE7B,IAAM1B,EAAIqB,SAASC,cAAc,KACjCtB,EAAEuB,KAAOJ,EACT,IAAMQ,EAAW3B,EAAEuB,KAGnB,OAFAb,EAAKkB,YAAYR,GAEVO,EAqDF,sCAlDkBT,EAAcW,EAAkBC,GAGvD,OAFIZ,EAAKtC,QAAyB,MAAfF,EAAKwC,KAAeA,GAAQ,KACnCD,EAAWC,EAAMW,GAClB/B,QAAQ,4BAA6B,SAACR,EAAKyC,EAAQZ,GAC5D,IAAMzC,EAAOyC,EAAKa,MAAM,KAAKC,MAC7B,MAAI,SAASC,KAAKxD,GAAcY,EACzByC,EAASZ,EAAOW,uBAIKK,oEAC9B,SAAO,IAAIC,QAAQ,SAACC,EAASC,GAC3B,IAAMC,EAAM,IAAIC,eAChBD,EAAIE,OAAS,WACO,KAAdF,EAAIG,QAAiBH,EAAIG,OAAS,IACpCL,EAAQE,EAAII,cAEZL,EAAO,IAAIM,MAAML,EAAIM,cAGzBN,EAAIO,QAAU,WACZR,EAAO,IAAIM,MAAM,sDAEnBL,EAAIQ,KAAK,MAAOZ,GAChBI,EAAIS,qCAIsBb,GAC5B,IAAMI,EAAM,IAAIC,eAGhB,GAFAD,EAAIQ,KAAK,MAAOZ,GAAK,GACrBI,EAAIS,OACAT,EAAIG,OAAS,KAAqB,KAAdH,EAAIG,OAC1B,MAAM,IAAIE,MAAML,EAAIM,YAEtB,OAAON,EAAII,8BAGiBd,oEAC5B,UAAO,4BAGmBA,GAC1B,OAAO,oBAGgBA,GACvB,OAAOZ,EAAWY,EAAU,UAGX,eCzDHoB,EAAcC,GAC5B,OAAOA,GAAOrF,EAAWqF,EAAIC,iBCTfC,EAAUxD,EAAUyD,GAClC,OAAQC,EAAQ1D,EAAKyD,YAGPC,EAAS1D,EAAUyD,GACjC,OAAIA,EAAIE,KAAKC,UACH5D,GAEO,IAARA,GAAAA,MAA+BA,MCD7B6D,EAA8B,CACzCC,KAAM,SAACC,EAAQC,GACb,OAAIX,EAAaU,GAAWA,EAAER,OAAOS,GACjCX,EAAaW,GAAWA,EAAET,OAAOQ,GAC9BA,IAAMC,GAEfC,KAAM,SAACF,EAAQC,GACb,OAAIX,EAAaU,IAAYA,EAAER,OAAOS,GAClCX,EAAaW,IAAYA,EAAET,OAAOQ,GAC/BA,IAAMC,GAEfE,IAAK,SAACH,EAAQC,GACZ,OAAIX,EAAaU,GAAWA,EAAEI,GAAGH,GAC7BX,EAAaW,GAAWA,EAAEI,GAAGL,GACtBC,EAAJD,GAETM,IAAK,SAACN,EAAQC,GACZ,OAAIX,EAAaU,GAAWA,EAAEK,GAAGJ,GAC7BX,EAAaW,GAAWA,EAAEG,GAAGJ,GAC1BA,EAAIC,GAEbM,KAAM,SAACP,EAAQC,GACb,OAAIX,EAAaU,GAAWA,EAAEQ,IAAIP,GAC9BX,EAAaW,GAAWA,EAAEQ,IAAIT,GACtBC,GAALD,GAETU,KAAM,SAACV,EAAQC,GACb,OAAIX,EAAaU,GAAWA,EAAES,IAAIR,GAC9BX,EAAaW,GAAWA,EAAEO,IAAIR,GAC3BA,GAAKC,GAEdU,SAAY,SAACX,EAAQC,GACnB,SAAOD,IAAK9F,EAAW8F,EAAEY,YAA2B,EAAhBZ,EAAEY,QAAQX,IAEhDY,IAAO,SAACb,EAAQC,EAAQP,GAAiB,OAAAD,EAASO,EAAGN,IAAQD,EAASQ,EAAGP,IACzEoB,GAAM,SAACd,EAAQC,EAAQP,GAAiB,OAAAD,EAASO,EAAGN,IAAQD,EAASQ,EAAGP,KCxC7DqB,EAAQ,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACrZC,EAAa,EAEbC,EAAQ,EAERC,EAAe,YCFZC,EAAYC,WACpBC,EAAa,OACnB,IAA8B,IAAAC,EAAAC,EAAA5H,OAAO6H,QAAQJ,kCAAY,CAGvD,IAHS,IAAAK,eAACC,OAAMC,OACZ9E,EAAOwE,EAEF7F,EAAI,EAAGA,EAAIkG,EAAKzG,OAAQO,IAAK,CACpC,IAAMoG,EAAIF,EAAKlG,GACfqB,EAAK+E,GAAK/E,EAAK+E,IAAM,GAEjBpG,IAAMkG,EAAKzG,OAAS,GAAM8F,EAAMW,EAAKG,WAAWrG,IAAMwF,IACxDnE,EAAK+E,GAAGE,cAAe,GAGzBjF,EAAOA,EAAK+E,GAGd/E,EAAK8E,QAAUA,EACf9E,EAAKkF,KAAM,oGAEb,OAAOV,EDdTN,EAAM,KAAOA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,MAAQA,EAAM,OAASE,EE4FnQ,IAAMe,EAAwC,CACnDzE,KAAM,CAAC,KACP0E,QAAS,CAAC,KACVC,SAAU,CAAC,KACXC,mBAAmB,EACnBvF,WAAOwF,EACPC,QAAS,GACTC,GAAIA,EACJC,iBAAiB,EACjB1C,UAAU,EACV2C,cAAc,EACdC,aAAa,EACbC,iBAAiB,EACjBC,gBAAgB,EAChBC,QAAQ,EACRC,iBAAkB,KAClBC,kBAAmB,KACnBC,oBAAqB,KACrBC,qBAAsB,KACtBC,mBAAmB,EACnBC,eAAe,EACfC,iBAAiB,EACjBC,WAAW,EACXC,QAAS,GACTC,gBAAgB,EAChBlC,UAAWtB,EACXyD,cAAepC,EAAWrB,aAsCZ0D,EAAwBvJ,GACtC,IAAIwJ,EAAiB,GAGrB,OAFIC,EAAUzJ,KAAQwJ,EAAOxJ,GACzB0J,EAAW1J,KAAQwJ,EAAO,CAACxJ,IACxBwJ,WCxKiCG,MAAA3E,OAU9B4E,mBAAV,WACE,IAAMC,EAAMpH,KAAKqH,cACjBrH,KAAKsH,QAiET,SAAoBC,GACZ,IAACC,0BACDC,EAAQF,EAAMG,MAAM/F,MAAM,MAC1BgG,EAAQC,KAAKC,IAAIL,EAAO,EAAG,GAC3BnC,EAAMuC,KAAKE,IAAIN,EAAO,EAAGC,EAAMlJ,QAYrC,OAVgBwJ,EACPJ,EAAOtC,EAAM,GACnB2C,IAAI,SAAAC,GAIH,OAHmBA,IAAeT,EAAQ,MAAQ,OACtCU,EAAW7K,OAAO4K,GAAa5K,OAAOgI,GAAK9G,aAC1CkJ,EAAMQ,EAAa,KAGjCE,KAAK,MA/ESC,CAAUpI,KAAKuH,OAC9BvH,KAAKqI,QAmFT,SAAoBC,EAAaf,GAC3BA,EAAMgB,OAAMD,GAAO,UAAUf,EAAMgB,MACjC,IAAAC,uBAAChB,OAAMiB,OAEb,OADAH,GAAO,UAAUd,WAAaiB,EAtFbC,CAAUtB,EAAIiB,QAASrI,KAAKuH,OAC3CvH,KAAK2I,MAAQ3I,KAAKqI,QAAU,KAAOrI,KAAKsH,QACtC,KAAOtH,KAAK2I,MAAQ,UAAYvB,EAAIuB,UAXxC,WAAoBvB,EAAYG,GAAhC,MACEqB,YAAMxB,EAAIiB,sBACVQ,EAAKxB,cAAgBD,EACrByB,EAAKtB,MAAQA,EACbsB,EAAKvB,QAAU,cAWoBJ,MAAAC,MACrC,WAAoBkB,EAAiBd,GAArC,MACEqB,YAAM,IAAIrG,MAAM8F,GAAUd,gBAC1BsB,EAAKC,KAAO,oBACZF,YAAMG,0BAIsB7B,MAAAC,MAC9B,WAAoBC,EAAYG,GAAhC,MACEqB,YAAMxB,EAAKG,gBACXsB,EAAKC,KAAO,aACZD,EAAKR,QAAUjB,EAAIiB,QACnBO,YAAMG,4BAIuB7B,QAAAC,GAOjB6B,MAAd,SAAkBC,GAChB,MAAoB,gBAAbA,EAAIH,UAPb,YAAoB1B,EAAY8B,GAAhC,MACEN,aAAMxB,EAAK8B,EAAI3B,oBACfsB,EAAKC,KAAO,cACZD,EAAKR,QAAUjB,EAAIiB,QACnBO,aAAMG,4BAOkC7B,QAAAC,OAC1C,YAAoBC,EAAYG,GAAhC,MACEqB,aAAMxB,EAAKG,gBACXsB,EAAKC,KAAO,yBACZD,EAAKR,QAAUjB,EAAIiB,QACnBO,aAAMG,4BAM0C7B,QAAA3E,WAGlD,YAAoB4G,GAApB,MACEP,aAAM,uBAAuBO,gBAC7BN,EAAKC,KAAO,iCACZD,EAAKM,aAAeA,eAIYjC,QAAA3E,WAClC,YAAoB8F,GAApB,MACEO,aAAMP,gBACNQ,EAAKC,KAAO,iBACZD,EAAKR,QAAUA,EAAU,SCjEjBe,GAAAA,OCQHC,yBAAP,SAAoBtM,GAClB,OAAQiD,KAAKsJ,UAAUvM,GAAOiD,KAAKsJ,UAAUvM,IAAQ,IAEhDsM,yBAAP,SAAoBtM,EAAaQ,GAC/B,OAAQyC,KAAKsJ,UAAUvM,GAAOQ,GAEzB8L,0BAAP,eAAA,oBAAqBE,mBAAAA,IAAAC,kBACnB,OAAOA,EAAKxB,IAAI,SAAAjL,GAAO,MAAA,CAACA,EAAK8L,EAAKY,YAAY1M,OAEzCsM,6BAAP,SAAwBK,GAAxB,WACE,OAAOA,EAAUC,QAAQ,SAACnB,OAAA5D,SAAC7H,OAAKQ,OAAW,OAAAsL,EAAKe,YAAY7M,EAAKQ,MAE5D8L,oBAAP,WACE,OAAOQ,GAAC7J,KAAK2G,QAAS3G,KAAK8J,cAAiB9J,KAAK+J,QAC9CC,OAAO,SAAChH,EAAKzD,GAAQ,OAAA0K,EAASjH,EAAKzD,IAAM,KAEvC8J,iBAAP,SAAYa,GACV,IAAMC,EAAQnK,KAAKoK,UAAUF,EAAM,IACnC,OAAOlK,KAAKqK,aAAaF,EAAOD,IAE3Bb,0BAAP,SAAqBc,EAAeD,GAApC,WAEE,MADqB,iBAAVA,IAAoBA,EAAQA,EAAMvI,MAAM,MAC5CuI,EAAMF,OAAO,SAACG,EAAOrJ,GAE1B,GAAInD,EADJwM,WA0BwBlB,EAAYlM,GACxC,OAAIY,EAAMsL,GAAaA,EAEnBzL,GADJyL,WX3BcqB,EAAU/M,GACxB,OAAIA,GAASC,EAAWD,EAAM+M,UAAkBA,EAAS/M,EAAM+M,YACxD/M,EWyBD+M,CAASrB,IACIlM,IAAckM,EAAIlM,KACjCkM,aAAenM,EACbmM,EAAI7K,eAAerB,GAAakM,EAAIlM,GACjCkM,EAAIsB,oBAAoBxN,GAErB,SAARA,EAgBN,SAAmBkM,GACjB,OAAInL,EAAQmL,IAAQ3L,EAAS2L,GAAaA,EAAI1K,OACvC0K,EAAU,KAlBUuB,CAASvB,GACxB,UAARlM,EAKN,SAAoBkM,GAClB,OAAInL,EAAQmL,GAAaA,EAAI,GACtBA,EAAW,MAPUwB,CAAUxB,GAC1B,SAARlM,EASN,SAAmBkM,GACjB,OAAInL,EAAQmL,GAAaA,EAAIA,EAAI1K,OAAS,GACnC0K,EAAU,KAXUyB,CAASzB,GAC7BA,EAAIlM,GArCC4N,CAAaR,EAAOrJ,KACR+H,EAAK3F,KAAKuD,gBAC5B,MAAM,IAAImE,GAA+B9J,GAE3C,OAAOqJ,GACNA,IAEEd,kBAAP,SAAarG,GACX,OAAOhD,KAAK+J,OAAOhL,KAAKiE,IAEnBqG,iBAAP,WACE,OAAOrJ,KAAK+J,OAAOnI,OAEdyH,oBAAP,WACE,OAAOrJ,KAAK+J,OAAO,IAEbV,uBAAR,SAAmBtM,GACjB,IAAK,IAAI+B,EAAIkB,KAAK+J,OAAOxL,OAAS,EAAQ,GAALO,EAAQA,IAAK,CAChD,IAAM+L,EAAY7K,KAAK+J,OAAOjL,GAC9B,GAAI/B,KAAO8N,EAAW,OAAOA,EAE/B,OAAI9N,KAAOiD,KAAK8J,aAAqB9J,KAAK8J,aACnC9J,KAAK2G,aAnDd,YAAoBmE,EAAkB5H,EAA8C6H,gBAAhED,mBAAkB5H,kBAA8C6H,MAN5E/K,YAAkB,CAAC,IACnBA,eAAY,GAMlBA,KAAK+K,KAAOA,EACZ/K,KAAKkD,KAAOA,EACZlD,KAAK2G,QAAUzD,EAAKyD,QACpB3G,KAAK8J,aAAegB,WChBRE,GAAYC,EAAiC5C,GAC3D,IAAK4C,EAAW,CACd,IAAM3C,EAAyB,mBAAZD,EACfA,IACCA,GAAW,UAAU4C,gBAC1B,MAAM,IAAIC,GAAe5C,KFKjBc,GAAAA,GAAAA,4BAEVA,qBACAA,eAEF,QAWW+B,oBAAT,SAAiB5C,EAAc9J,EAAkBsM,EAAgBK,0EACvDxF,EAAO5F,KAAKqL,WACdC,EAAOtL,KAAKqL,QAAQ5M,4CACH+J,EAAA3D,EAAA7E,KAAKuL,WAAWhD,EAAM+C,EAAMF,EAAa3M,IAAS2K,GAAWoC,wDAAzEhK,UACLuJ,GAAOU,EAAA7F,EAAG8F,WAAWlK,wBAAY,SAAMoE,EAAG+F,OAAOnK,WAAhBiK,EAAAG,0BAArC,KAAgE,SAAOpK,wMAEzE,MAAMxB,KAAK6L,YAAYtD,EAAM+C,OAGxBH,gCAAP,SAA2BW,GACzB,OAAO9L,KAAKqL,QAAQ5F,mBAAqBzF,KAAK+L,cAAclK,KAAKiK,IAG1DX,wBAAT,SAAqB5C,EAAc+C,EAAgBF,EAAsBY,2FACjExD,EAAkBxI,KAAKqL,QAArBzF,OAAID,aACR3F,KAAKiM,mBAAmB1D,KAAS6C,EAAjC,YACIc,EAAatG,EAAG5D,QAAQhC,KAAKmM,QAAQf,GAAc7C,EAAM5C,2CAC7CyG,EAAAvH,EAAAyG,oDAAPe,UACJL,IAAehM,KAAKsM,UAAUJ,EAAYG,YAEvCH,WACN,OADAnH,iOAKYwH,EAAA1H,EAAAyG,qDAAPe,UACHH,EAAatG,EAAG5D,QAAQqK,EAAK9D,EAAM5C,GACpCqG,IAAehM,KAAKsM,UAAUJ,EAAYG,aACvCH,YAANnH,+NAGgBW,IAAhBE,EAAG4G,qBAEY9G,KADXlE,EAAWoE,EAAG4G,SAASjE,cACK/G,WAANuD,0CAIxBoG,uBAAR,SAAmB5C,EAAc8D,GAE/B,OADAA,EAAMA,EAAII,SAASzM,KAAK0M,KAAOL,EAAMA,EAAMrM,KAAK0M,IACzCnE,EAAKoE,WAAWN,IAGjBlB,qBAAR,SAAiBrK,GACf,IAAM8E,EAAK5F,KAAKqL,QAAQzF,GAExB,OADAoF,GAAOpF,EAAGuG,QAAS,mDACZvG,EAAGuG,QAASrL,IAGbqK,yBAAR,SAAqB5C,EAAcqE,GACjC,IAAMxF,EAAM,IAAI7E,MAAM,UAGtB,OAFA6E,EAAIiB,QAAU,6BAA6BE,WAAaqE,MACxDxF,EAAIyF,KAAO,SACJzF,OA1DT,YAAaiE,GACXrL,KAAKqL,QAAUA,EACfrL,KAAK0M,IAAM1M,KAAKqL,QAAQzF,GAAG8G,KAAO,IAClC1M,KAAK+L,cAAgB,IAAIe,OAAO,CAAC,IAAM9M,KAAK0M,IAAK,KAAO1M,KAAK0M,KAAK1E,IAAI,SAAA+E,GAAU,gBVZvD9N,GAC3B,OAAOA,EAAIQ,QAAQ,wBAAyB,QUWsCuN,CAAYD,KAAS5E,KAAK,MGtB9G,QAGS8E,mBAAP,SAAcC,GACZlN,KAAKmN,QAAU1P,EAAUyP,QAJ7B,cACSlN,YAAS,GCFlB,OAGE,WACE,MAHKA,YAAS,GACTA,YAAgC,KAE/B,IAAIuC,MAAM,uCCGpB,SAAS6K,GAA2B7P,GAClC,IAAM8P,EAAM,CACVC,KAAM,SAACtL,GAAsB,OAAAA,EAAQzE,IACrCgQ,MAAO,WAAM,OAAAF,IAEf,OAAOA,EAGT,SAASG,GAA2BpG,GAClC,IAAMiG,EAAM,CACVC,KAAM,SAACtL,EAAmBC,GACxB,OAAIA,EAAeA,EAAOmF,GACnBiG,GAETE,MAAO,SAACtL,GAAqB,OAAAA,EAAOmF,KAEtC,OAAOiG,WAcOI,GAAelO,GAC7B,OAZF,SAAwBA,GACtB,OAAOA,GAAO/B,EAAW+B,EAAI+N,MAWzBI,CAAWnO,GAAaA,EAR9B,SAA0BA,GACxB,OAAOA,GAAO/B,EAAW+B,EAAIO,OAAStC,EAAW+B,EAAIoO,QAAUnQ,EAAW+B,EAAIqO,QAQ1EC,CAAgBtO,GAGpB,SAASyK,EAAWjK,GAClB,IAAI+N,EACJ,IACEA,EAASvO,EAA8BO,KAAKC,GAC5C,MAAOqH,GACP,OAAOoG,GAAuBpG,GAGhC,GAAI0G,EAAMC,KAAM,OAAOX,GAAuBU,EAAMvQ,OACpD,OAAOkQ,GAAWK,EAAMvQ,OAAQ+P,KAAKtD,EAAQ,SAAA5C,GAC3C,IAAI0G,EACJ,IACEA,EAASvO,EAA8BoO,MAAOvG,GAC9C,MAAO4G,GACP,OAAOR,GAAuBQ,GAEhC,OAAIF,EAAMC,KAAaX,GAAuBU,EAAMvQ,OAC7CyM,EAAO8D,EAAMvQ,SApBSyM,GAC1BoD,GAAuB7N,YAwBhB0O,GAAc1O,GAC5B,OAAOwC,QAAQC,QAAQyL,GAAWlO,aAIpB7B,GAAY6B,GAC1B,IAAI8N,EASJ,OARAI,GAAWlO,GACR+N,KAAK,SAACY,GAEL,OAAOd,GADPC,EAAMa,KAGPX,MAAM,SAACnG,GACN,MAAMA,IAEHiG,EC9ET,QAGSc,mBAAP,SAAcjB,GAMQ,iBALpBA,EAAOxP,EAAQwP,KAKiC,KAAhBlN,KAAKmN,OACnCnN,KAAKmN,OAASD,EAEdlN,KAAKmN,OAAS1P,EAAUuC,KAAKmN,QAAU1P,EAAUyP,QAZvD,cACSlN,YAAc,GCKvB,ICTYoO,ODUHC,yCAAP,SAAoCC,EAAuBtL,GAA3D,WACQuL,EAAU,IAAIC,GAGpB,OAFAzM,QAAQC,UAAUsL,KAAK,WAAM,OAAAG,GAAW5E,EAAK4F,gBAAgBH,EAAWtL,EAAKuL,MAC1EjB,KAAK,WAAM,OAAAiB,EAAQlJ,OAAO,SAAA+B,GAAO,OAAAmH,EAAQG,MAAMtH,KAC3CmH,EAAQI,QAERN,6BAAT,SAA0BC,EAAuBtL,EAAcuL,wEAE3DA,EADGA,IACOvL,EAAIE,KAAK0D,eAAiB,IAAIuH,GAAuB,IAAIlB,6CAEnD2B,EAAA/J,EAAAyJ,qDAAPpF,2BAGM,gCAAMA,EAAI2F,OAAO7L,EAAKuL,WAGnC,OAHMrB,EAAOtI,WAEL2J,EAAQ9N,MAAMyM,GAClBqB,EAAe,OAAKA,EAAkB,4BAG1C,iBADYvF,GAAY8F,GAAGC,GAAKA,EAAI,IAAI/F,GAAY+F,EAAG7F,8LAI3D,SAAOqF,EAAQpB,gBAvBnB,wBEIgB6B,GAAkBzP,GAChC,SAAU0P,GAAQ1P,GAAO6O,YAAUc,oBAGrBC,GAAiB5P,GAC/B,OAAO0P,GAAQ1P,KAAS6O,YAAUgB,kBAGpBC,GAAa9P,GAC3B,OAAO0P,GAAQ1P,KAAS6O,YAAUkB,cAGpBC,GAAehQ,GAC7B,OAAO0P,GAAQ1P,KAAS6O,YAAUoB,gBAGpBC,GAAYlQ,GAC1B,OAAO0P,GAAQ1P,KAAS6O,YAAUsB,aAGpBC,GAAepQ,GAC7B,OAAO0P,GAAQ1P,KAAS6O,YAAUwB,gBAGpBC,GAAgBtQ,GAC9B,OAAO0P,GAAQ1P,KAAS6O,YAAU0B,iBAGpBC,GAAexQ,GAC7B,OAAO0P,GAAQ1P,KAAS6O,YAAU4B,gBAGpBC,GAAuB1Q,GACrC,OAAO0P,GAAQ1P,KAAS6O,YAAU8B,wBAGpBC,GAAa5Q,GAC3B,OAAO0P,GAAQ1P,KAAS6O,YAAUgC,cAGpBC,GAAc9Q,GAC5B,OAAO0P,GAAQ1P,KAAS6O,YAAUkC,MAGpC,SAASrB,GAAS1P,GAChB,OAAOA,EAAMA,EAAIgR,MAAQ,GD1DfnC,GAAAA,cAAAA,uCAEVA,2BACAA,mBACAA,yBACAA,sBACAA,0BACAA,sBACAA,2CACAA,uBACAA,yBACAA,4BACAA,gCACAA,6PEIOoC,gBAAP,SAAgD1H,EAAc2H,GAE5D,OADAzQ,KAAK0Q,SAAS5H,GAAQ2H,EACfzQ,MAEDwQ,qBAAR,SAA8CG,EAAe9N,GAC3D,IAAM+N,EAAI5Q,KAAK0Q,SAASC,GACxB,QAAOC,IAAKA,EAAE7S,KAAKiC,KAAM6C,IAAM,IAE1B2N,mBAAP,WAEE,IAAIjJ,EACJ,IAFAvH,KAAK6Q,QAAQ,UAEL7Q,KAAK8Q,gBAAkBvJ,EAAQvH,KAAK+Q,OAAOC,UACjD,KAAIhR,KAAK6Q,QAAQ,QAAStJ,IACtBkI,GAAWlI,IAAUvH,KAAK6Q,QAAQ,OAAOtJ,EAAMuB,KAAQvB,IAA3D,CAGA,IAAM0J,EAAWjR,KAAKkR,WAAW3J,EAAOvH,KAAK+Q,QAC7C/Q,KAAK6Q,QAAQ,WAAYI,GAG3B,OADKjR,KAAK8Q,eAAe9Q,KAAK6Q,QAAQ,OAC/B7Q,MAEFwQ,kBAAP,WAEE,OADAxQ,KAAK8Q,eAAgB,EACd9Q,UA5BT,YAAoB+Q,EAAaG,GAJzBlR,cAAgD,GAChDA,oBAAgB,EAItBA,KAAK+Q,OAASA,EACd/Q,KAAKkR,WAAaA,ECbpB,YAAoB3J,GAClBvH,KAAKuH,MAAQA,EAHjB,WCI8BL,QAAApK,GACrBqU,oBAAP,SAAe5T,GACb,OAAOI,EAAMD,EAAQH,KAEhB4T,gBAAP,WACE,OAAO,GAEFA,iBAAP,WACE,OAAO,GAEFA,gBAAP,WACE,OAAO,GAEFA,iBAAP,WACE,OAAO,GAEFA,qBAAP,WACE,OAAO,UAjBX,+DCAA,WAA+BjK,QAAApK,GACtBsU,oBAAP,SAAe7T,GACb,QAAIA,aAAiB6T,KAEjB9T,EADJC,EAAQG,EAAQH,KACOO,EAAQP,GAAgC,IAAjBA,EAAMgB,QAChDC,EAASjB,IAA6C,IAA9BN,OAAOuM,KAAKjM,GAAOgB,UAG1C6S,gBAAP,WACE,OAAO,GAEFA,iBAAP,WACE,OAAO,GAEFA,gBAAP,WACE,OAAO,GAEFA,iBAAP,WACE,OAAO,GAEFA,qBAAP,WACE,MAAO,QArBX,+DCDA,WAA+BlK,QAAAkK,IACtBC,oBAAP,SAAe9T,GACb,OAAc,IAAVA,KACAI,EAAMD,EAAQH,MACdD,EAASC,GAAe,QAAQsE,KAAKtE,GAClCqL,aAAM9F,iBAAOvF,SALxB,+DCCA,IAAM+T,GAAM,IAAIH,GACHI,GAAgB,CAC3BC,MAAQ,EACRC,OAAS,EACTH,IAAOA,GACPI,KAAQJ,GACRK,MAAS,IAAIP,GACbQ,MAAS,IAAIP,ICXTQ,GAAO,aACPC,GAAO,QACPC,GAAa,CACjBnS,EAAG,KACHoS,EAAG,KACH3S,EAAG,KACHkE,EAAG,KACH0O,EAAG,KACHC,EAAG,MAGL,SAASC,GAAQjN,GACf,IAAM2H,EAAO3H,EAAEC,WAAW,GAC1B,OAAY,IAAR0H,EAAmBA,EAAO,GAClB,IAARA,EAAmBA,EAAO,GACvBA,EAAO,YAGAuF,GAAoBnT,GAElC,IADA,IAAIoO,EAAM,GACDvO,EAAI,EAAGA,EAAIG,EAAIV,OAAS,EAAGO,IAClC,GAAe,OAAXG,EAAIH,GAIR,QAA+B4G,IAA3BqM,GAAW9S,EAAIH,EAAI,IACrBuO,GAAO0E,GAAW9S,IAAMH,SACnB,GAAmB,MAAfG,EAAIH,EAAI,GAAY,CAG7B,IAFA,IAAIS,EAAM,EACN8S,EAAIvT,EAAI,EACLuT,GAAKvT,EAAI,GAAK+S,GAAKhQ,KAAK5C,EAAIoT,KACjC9S,EAAY,GAANA,EAAW4S,GAAOlT,EAAIoT,MAE9BvT,EAAIuT,EAAI,EACRhF,GAAOhQ,OAAOiV,aAAa/S,QACtB,GAAKuS,GAAKjQ,KAAK5C,EAAIH,EAAI,IAEvB,CAGL,IAFIuT,EAAIvT,EAAI,EACRS,EAAM,EACH8S,GAAKvT,EAAI,GAAKgT,GAAKjQ,KAAK5C,EAAIoT,KACjC9S,EAAY,EAANA,EAAU4S,GAAOlT,EAAIoT,MAE7BvT,EAAIuT,EAAI,EACRhF,GAAOhQ,OAAOiV,aAAa/S,QAR3B8N,GAAOpO,IAAMH,QAdbuO,GAAOpO,EAAIH,GAyBf,OAAOuO,UCzBEkF,sBAAT,SAAmBvP,EAAcwP,gFAC/BxH,GAAOhI,EAAK,2CACNyP,EAAkB,6CACJjK,EAAA3D,EAAA7E,KAAK0S,yDACnBC,GADKpL,cAESkL,EAAS7Q,oBACf,OADJ2B,EAAIqP,YACMH,EAAS7Q,qBAAnB0B,EAAIsP,SACJC,EAsCd,SAA4BnO,EAAsB6C,EAAsBuL,EAAUC,EAAU/P,GAE1F,OAAOgQ,EADMtO,EAAU6C,EAAM0L,WACjBH,EAAKC,EAAK/P,GAxCDkQ,CAAkBlQ,EAAIE,KAAKwB,UAAW6C,EAAOjE,EAAGC,EAAGP,GAClEyP,EAAS1T,KAAK8T,gBAEA,OAAd9N,GAAA0G,EAAAgH,GAAS1T,QAAWoU,GAAU5L,EAAOvE,EAAKwP,GAAmC,IAAxBxS,KAAK0S,QAAQnU,gBAAlEwG,WAAc6N,iNAGlB,SAAOH,EAAS,YAhBlB,YAAoB1B,GAClB/Q,KAAK0S,UA8DT,SAAsB3B,sEACdqC,EAAuB,8CACTC,EAAAxO,EAAAkM,yDACd4B,GADKpL,WACL,oCACK6L,EAAI7U,QAAU6U,EAAIA,EAAI7U,OAAS,GAAG+U,gBAAkB/L,EAAM+L,mBACzDF,EAAIxR,2BAAVgD,6BAEFwO,EAAIrU,KAAKwI,gBACJ,SAAMA,UAAN3C,uNAEFwO,EAAI7U,UACH6U,EAAIxR,6BAAVgD,qCAzEmB2O,CAAUxC,aAmBjBoC,GAAW5L,EAA0BvE,EAAcwP,GACjE,oBADiEA,MAC7DgB,GAAiCjM,GAQvC,SAAkCA,EAA4BvE,EAAcwP,GAC1E,IAAMiB,EAAkBlM,EAAMkM,MAAMzL,IAAI,SAAA0L,GAAQ,OAAAP,GAAUO,EAAM1Q,GAAK,KACrE,IACE,OAAOA,EAAI2Q,OAAKpM,EAAMqM,cAAiBH,IACvC,MAAOzF,GACP,GAAIwE,GAAsB,mCAAXxE,EAAElF,KAA2C,OAAO,KACnE,UAAW+K,GAAuB7F,EAAGzG,IAdauM,CAAwBvM,EAAOvE,EAAKwP,GACpFuB,GAAwBxM,GAmC9B,SAAyBA,EAAmBvE,GAC1C,IAAMgR,EAAcb,GAAU5L,EAAMuL,IAAK9P,GACnCiR,EAAed,GAAU5L,EAAMwL,IAAK/P,GAC1C,OAAOtE,GAAOsV,GAAMC,EAAO,GAtCgBC,CAAe3M,EAAOvE,GAC7DmR,GAA0B5M,GA8BhC,SAA2BA,GACzB,OAAOgK,GAAchK,EAAM6M,SA/BkBC,CAAiB9M,GAC1D+M,GAAyB/M,GAe/B,SAA0BA,GACxB,IAAMtI,EAAMsI,EAAMgN,MAAMC,QAAU,KAAOjN,EAAMkN,QAAUlN,EAAMkN,QAAQD,QAAU,IACjF,OAAOxE,OAAO/Q,GAjB8ByV,CAAgBnN,GACxDoN,GAAuBpN,GAAeA,EAAMqN,UAC5CC,GAAyBtN,GAAeuN,GAAgBvN,QAA5D,WAkBcuN,GAAiBvN,GAC/B,OAAO6K,GAAmB7K,EAAMqN,mBCtDzBG,qBAAP,WACE,OAAO/U,KAAK0H,MAAMsN,MAAMhV,KAAK2H,MAAO3H,KAAKqF,MAEpC0P,yBAAP,WAEE,IADI,IAAAvM,aAACyM,OAAKxM,OACD3J,EAAI,EAAGA,EAAIkB,KAAK2H,MAAO7I,IACR,OAAlBkB,KAAK0H,MAAM5I,IACbmW,IACAxM,EAAM,GACDA,IAET,MAAO,CAACwM,EAAKxM,IAERsM,kBAAP,WACE,OAAO/U,KAAKqF,IAAMrF,KAAK2H,WArBzB,YACS4I,EACA7I,EACAC,EACAtC,EACAkD,GAJAvI,UAAAuQ,EACAvQ,WAAA0H,EACA1H,WAAA2H,EACA3H,SAAAqF,EACArF,UAAAuI,ECJX,WAA6CrB,QAAA6N,QAI3C,YACExE,EACAiE,EACA9M,EACAC,EACAtC,EACA6P,EACAC,EACA5M,GARF,MAUEK,aAAM2H,EAAM7I,EAAOC,EAAOtC,EAAKkD,SAb1BM,YAAW,EACXA,aAAY,EAajBA,EAAK2L,QAAU3L,EAAK+L,UACpB,IAAMQ,EAAoB,MAAfZ,EAAQ,GACba,EAAuB,MAAlBhX,EAAKmW,UAChB3L,EAAK2L,QAAUA,EACZQ,MACCI,EAAK,EAAI,EACTC,GAAM,EAAIb,EAAQjW,QAEnB+W,OACHzM,EAAKqM,SAAWE,GAAMF,EACtBrM,EAAKsM,UAAYE,GAAMF,ICH3B,SAASD,GAAU3N,EAAcrB,GAC/B,GAAKqB,GAAU8H,GAAY9H,GAG3B,IADA,IAAMgO,EAAOrP,EAAS3B,EAAQC,EACvBH,EAAMkD,EAAMG,MAAMvC,WAAWoC,EAAMlC,IAAM,EAAIkC,EAAM4N,YAAcI,GAAMhO,EAAM4N,YAGtF,SAASA,GAAW5N,EAAcrB,GAChC,GAAKqB,GAAU8H,GAAY9H,GAA3B,CAGA,IADA,IAAMgO,EAAOrP,EAAS3B,EAAQC,EACvBH,EAAMkD,EAAMG,MAAMvC,WAAWoC,EAAMI,MAAQJ,EAAM2N,WAAaK,GAAMhO,EAAM2N,WACxB,OAArD3N,EAAMG,MAAM8N,OAAOjO,EAAMI,MAAQJ,EAAM2N,WAAoB3N,EAAM2N,YClCvE,WAAiChO,QAAA6N,QAC/B,YACSR,EACAE,GAFT,MAIE7L,aAAMwF,YAAU4B,OAAQuE,EAAM7M,MAAO6M,EAAM5M,MAAO8M,EAAUA,EAAQpP,IAAMkP,EAAMlP,IAAKkP,EAAMhM,mBAHpFM,QAAA0L,EACA1L,UAAA4L,ICHX,WAAqCvN,QAAA6N,IAWnCU,sBAAA,SAAUC,gBAAAA,MAIR,IAHA,IAGS5W,EAHK4W,G1BLE,G0BKWrR,EAAMrE,KAAK0H,MAAMvC,WAAWnF,KAAK2H,QACxD3H,KAAK2H,MAAQ,EACb3H,KAAK2H,MACW7I,EAAIkB,KAAKqF,IAAKvG,IAChC,K1BVgB,G0BUVuF,EAAMrE,KAAK0H,MAAMvC,WAAWrG,KAAe,OAAO,EAE1D,OAAO,OAhBT,YACS4I,EACAC,EACAtC,EACAkD,GAJT,MAMEK,aAAMwF,YAAUgC,KAAM1I,EAAOC,EAAOtC,EAAKkD,gBALlCM,QAAAnB,EACAmB,QAAAlB,EACAkB,MAAAxD,EACAwD,OAAAN,EAGPM,EAAK2L,QAAU3L,EAAK+L,YCVxB,WAAkC1N,QAAA6N,QAEhC,YACSrN,EACAC,EACAtC,EACAkD,GAJT,MAMEK,aAAMwF,YAAU0B,QAASpI,EAAOC,EAAOtC,EAAKkD,gBALrCM,QAAAnB,EACAmB,QAAAlB,EACAkB,MAAAxD,EACAwD,OAAAN,EAGPM,EAAKuL,QAAUvL,EAAK+L,YCTjB,OAAMe,GAAa,CACxBtS,KAAM,EACNG,KAAM,EACNC,IAAK,EACLG,IAAK,EACLC,KAAM,EACNG,KAAM,EACNC,SAAY,EACZE,IAAO,EACPC,GAAM,OAG2B8C,QAAA6N,IAWjCa,2BAAA,WACE,IAAM7Y,EAAMiD,KAAK4U,UACjB,OAAO7X,KAAO4Y,GAAaA,GAAW5Y,GAAO,OAX/C,YACS2K,EACAC,EACAtC,EACAkD,GAJT,MAMEK,aAAMwF,YAAUgB,SAAU1H,EAAOC,EAAOtC,EAAKkD,gBALtCM,QAAAnB,EACAmB,QAAAlB,EACAkB,MAAAxD,EACAwD,OAAAN,EAGPM,EAAKoK,SAAWpK,EAAK+L,YClBzB,WAAyC1N,QAAA6N,QAEvC,YACSc,EACApC,EACPpO,GAHF,MAKEuD,aAAMwF,YAAU8B,eAAgB2F,EAASnO,MAAOmO,EAASlO,MAAOtC,EAAKwQ,EAAStN,mBAJvEM,WAAAgN,EACAhN,QAAA4K,EAIP5K,EAAK+K,aAAe/K,EAAKgN,oBAAoBJ,GACzC5M,EAAKgN,SAASjB,UACdxC,GAAmBvJ,EAAKgN,SAASjB,aCZzC,WAAiC1N,QAAA6N,QAC/B,YACSjM,EACAgN,EACPpO,EACAC,EACAtC,EACAkD,GANF,MAQEK,aAAMwF,YAAU2H,OAAQrO,EAAOC,EAAOtC,EAAKkD,gBAPpCM,OAAAC,EACAD,OAAAiN,ICFX,WAA+B5O,QAAA6N,QAC7B,YACSrN,EACAC,EACAtC,EACAyD,EACAvL,EACAgL,GANT,MAQEK,aAAMwF,YAAU4H,KAAMtO,EAAOC,EAAOtC,EAAKkD,gBAPlCM,QAAAnB,EACAmB,QAAAlB,EACAkB,MAAAxD,EACAwD,OAAAC,EACAD,QAAAtL,EACAsL,OAAAN,ICTX,WAAiCrB,QAAA6N,QAC/B,YACSrN,EACAC,EACAtC,EACAkD,GAJT,MAMEK,aAAMwF,YAAUwB,OAAQlI,EAAOC,EAAOtC,EAAKkD,gBALpCM,QAAAnB,EACAmB,QAAAlB,EACAkB,MAAAxD,EACAwD,OAAAN,ICLX,WAA+BrB,QAAA6N,IAWtBkB,wBAAP,WACE,OAAOjW,KAAK0H,MAAMsN,MAAMhV,KAAK2H,MAAQ3H,KAAKkV,SAAUlV,KAAKqF,IAAMrF,KAAKmV,gBATtE,YACSzN,EACAC,EACAtC,EACAkD,GAJT,MAMEK,aAAMwF,YAAUkB,KAAM5H,EAAOC,EAAOtC,EAAKkD,gBALlCM,QAAAnB,EACAmB,QAAAlB,EACAkB,MAAAxD,EACAwD,OAAAN,EANTM,WAAW,EACXA,YAAY,ICDd,WAAgC3B,QAAA6N,QAC9B,YACSrN,EACAC,EACAtC,EACAyN,EACAC,EACAxK,GANT,MAQEK,aAAMwF,YAAUkC,MAAO5I,EAAOC,EAAOtC,EAAKkD,gBAPnCM,QAAAnB,EACAmB,QAAAlB,EACAkB,MAAAxD,EACAwD,MAAAiK,EACAjK,MAAAkK,EACAlK,OAAAN,ICPX,WAAiCrB,QAAAgP,QAC/B,YACExO,EACAC,EACAtC,EACAgG,EACA9C,GALF,IAOUtC,mBAAgBD,oBAAiBK,wBAAqBC,yBACxD/I,EAAQmK,EAAMsN,MAAMrN,EAAQtB,EAAoB9H,OAAQ8G,EAAMiB,EAAqB/H,eACzFqK,aAAMwF,YAAUoB,OAAQjS,EAAOmK,EAAOC,EAAOtC,EAAKY,EAAgBD,EAAiBuC,iBC0BrF4N,4BAAA,WACE,OAAO,IAAI5D,GAAWvS,KAAKoW,yBAG3BD,kCAAF,sEAEE,OADME,EAAUrW,KAAKsW,gBAGfD,cAAN7N,iCAEOxI,KAAKuW,EAAIvW,KAAKwW,GACbvD,EAAWjT,KAAKyW,kBAGhBC,EAAU1W,KAAKsW,gBAGfrD,oBACN,OADAzK,YACMkO,iBAANlO,oCAGJ2N,0BAAA,WACEnW,KAAK2W,YACL,IAAMtR,WC5DqBpG,EAAa0I,EAAehD,EAAYU,gBAAAA,EAAMpG,EAAIV,QAI/E,IAHA,IAEIqY,EAFAzW,EAAOwE,EACP7F,EAAI6I,EAEDxH,EAAKlB,EAAIH,KAAOA,EAAIuG,IACzBlF,EAAOA,EAAKlB,EAAIH,OACF,MAAG8X,EAAOzW,GAE1B,OAAKyW,EACDA,EAAmB,cAAMvS,EAAMpF,EAAIkG,WAAWrG,IAAMwF,GAAqB,EACtExF,GAFY,EDoDL+X,CAAc7W,KAAK0H,MAAO1H,KAAKuW,EAAGvW,KAAK2E,KAAM3E,KAAKuW,EAAI,GAClE,IAAa,IAATlR,EACJ,OAAO,IAAIuQ,GAAc5V,KAAK0H,MAAO1H,KAAKuW,EAAIvW,KAAKuW,EAAIlR,EAAMrF,KAAKuI,OAEpE4N,yBAAA,WAEE,IADA,IAAMW,EAAU,KACH,CACX,IAAMC,EAAS/W,KAAKgX,aACpB,IAAKD,EAAQ,OAAOD,EACpBA,EAAQ/X,KAAKgY,KAGjBZ,wBAAA,WAAA,WAEE,GADAnW,KAAK2W,YACD3W,KAAKqF,MAAO,OAAO,KACvB2F,GAAuB,MAAhBhL,KAAKiX,OAAgB,WAAM,MAAA,uBAAuBpO,EAAKqO,aAC9DlX,KAAKuW,IACL,IAAM5O,EAAQ3H,KAAKuW,EACbzN,EAAO9I,KAAKmX,iBAClB,IAAKrO,EAAKxI,OAAQ,OAAO,KACzB,IAAMwV,EAAO,GAEb,GADA9V,KAAK2W,YACe,MAAhB3W,KAAKiX,OACP,EAAG,GACCjX,KAAKuW,EACP,IAAM1T,EAAM7C,KAAKoX,gBAEjB,IADAvU,GAAOiT,EAAK/W,KAAK8D,GACV7C,KAAKuW,EAAIvW,KAAKwW,GAAqB,MAAhBxW,KAAKiX,QAAkC,MAAhBjX,KAAKiX,UAAkBjX,KAAKuW,QACtD,MAAhBvW,KAAKiX,QAEhB,OAAO,IAAII,GAAYvO,EAAK8L,UAAWkB,EAAM9V,KAAK0H,MAAOC,EAAO3H,KAAKuW,EAAGvW,KAAKuI,OAG/E4N,2BAAA,WACE,IAAMpZ,EAAMiD,KAAKsW,YACjB,GAAKvZ,EAAL,CAEA,GADAiD,KAAK2W,YACe,MAAhB3W,KAAKiX,OAAgB,OAAOla,IAC9BiD,KAAKuW,EACP,IAAMhZ,EAAQyC,KAAKsW,YACnB,MAAO,CAACvZ,EAAI6X,UAAWrX,KAGzB4Y,gCAAA,SAAoB9K,gBAAAA,KAElB,IADA,IAAM0F,EAA0B,GACzB/Q,KAAKuW,EAAIvW,KAAKwW,GAAG,CACtB,IAAMjP,EAAQvH,KAAKsX,kBAAkBjM,GACrC0F,EAAOhS,KAAKwI,GAGd,gBZ5G4BwJ,EAAiB1F,GAG/C,IAFA,IAAIkM,GAAQ,EAEHzY,EAAI,EAAGA,EAAIiS,EAAOxS,OAAQO,IAAK,CACtC,IAAMyI,EAAQwJ,EAAOjS,GAChBkQ,GAAiBzH,MACjBgQ,GAAShQ,EAAM2N,UAClBA,GAASnE,EAAOjS,EAAI,GAAIuM,EAAQnF,QAG9BuJ,GAAWlI,KACM,QAAfA,EAAMuB,KAAgByO,GAAQ,EACV,WAAfhQ,EAAMuB,OAAmByO,GAAQ,KAGvCA,GAAShQ,EAAM4N,WAClBA,GAAUpE,EAAOjS,EAAI,GAAIuM,EAAQnF,UY2FnCsR,CAAezG,EAAQ1F,GAChB0F,GAGToF,+BAAA,SAAmB9K,GACT,IAAAlF,qBAAkBE,wBAC1B,OAAuB,EAAnBrG,KAAKyX,WAAwBzX,KAAK0X,uBAAuBrM,GACzDrL,KAAK2X,MAAMxR,GAA0BnG,KAAK4X,aAAavM,GACvDrL,KAAK2X,MAAMtR,GAA6BrG,KAAK6X,gBAAgBxM,GAC1DrL,KAAK8X,cAAczM,IAG5B8K,2BAAA,SAAe9K,GAEb,IADA,IAAM1D,EAAQ3H,KAAKuW,EACZvW,KAAKuW,EAAIvW,KAAKwW,GAAG,CACd,IAAArQ,qBAAkBE,wBAC1B,GAAIrG,KAAK2X,MAAMxR,GAAmB,MAClC,GAAInG,KAAK2X,MAAMtR,GAAsB,QACnCrG,KAAKuW,EAET,OAAO,IAAIN,GAAUjW,KAAK0H,MAAOC,EAAO3H,KAAKuW,EAAGvW,KAAKuI,OAGvD4N,0BAAA,SAAc9K,gBAAAA,KACN,IAAE9C,YAAMb,aACRC,EAAQ3H,KAAKuW,EACnB,IAAyD,IAArDvW,KAAK+X,gBAAgB1M,EAAQjF,mBAC/B,MAAMpG,KAAKgY,QAAQ,OAAOhY,KAAKkX,SAASvP,iBAAqBA,GAE/D,IAAMJ,EAAQ,IAAI0Q,GAASvQ,EAAOC,EAAO3H,KAAKuW,EAAGlL,EAAS9C,GAE1D,MADmB,QAAfhB,EAAMuB,OAAgB9I,KAAKyX,WAAa9P,GACrCJ,GAGT4O,6BAAA,SAAiB+B,GACf,KAAOlY,KAAKuW,EAAIvW,KAAKwW,GACnB,GpC5Ie,EoC4IVxW,KAAKmY,WACRnY,KAAKoY,kBAIP,KADEpY,KAAKuW,EACHvW,KAAKqY,OAAOH,GAAY,OAAOlY,KAAKuW,EAE1C,OAAQ,GAGVJ,6BAAA,SAAiB9K,gBAAAA,KACT,IAAE9C,YAAMb,aACNpB,yBACFqB,EAAQ3H,KAAKuW,EACnB,IAAoD,IAAhDvW,KAAK+X,gBAAgBzR,GACvB,MAAMtG,KAAKgY,QAAQ,UAAUhY,KAAKkX,SAASvP,iBAAqBA,GAElE,OAAO,IAAI2Q,GAAY5Q,EAAOC,EAAO3H,KAAKuW,EAAGlL,EAAS9C,IAGxD4N,oCAAA,SAAwB9K,GAItB,IAHQ,IAAAlF,qBAAkBC,sBACpBuB,EAAQ3H,KAAKuW,EACfgC,EAAUvY,KAAKwY,OAAOrS,GAAoBA,EAAiB5H,OACxDyB,KAAKuW,EAAIvW,KAAKwW,GACnB,GAAwC,WAApCxW,KAAKmX,iBAAiBvC,UAI1B,KAAO5U,KAAKuW,GAAKvW,KAAKwW,GAAG,CACvB,GAAIxW,KAAKqY,OAAOjS,GAAoB,CAClC,IAAMf,EAAMrF,KAAKuW,EACjB,OAAI5O,IAAU4Q,GACZvY,KAAKyX,YAAc,EACZ,IAAIQ,GAASjY,KAAK0H,MAAOC,EAAOtC,EAAKgG,EAASrL,KAAKuI,QAE1DvI,KAAKuW,EAAIgC,EACF,IAAItC,GAAUjW,KAAK0H,MAAOC,EAAO4Q,EAASvY,KAAKuI,OAG1D,GAAIvI,KAAKqY,OAAOlS,GAAmB,MACnCnG,KAAKuW,SAfLgC,EAAUvY,KAAKwY,OAAOrS,GAAoBA,EAAiB5H,OAkB/D,MAAMyB,KAAKgY,QAAQ,OAAOhY,KAAKkX,SAASlX,KAAKyX,0BAA0B9P,IAGzEwO,qBAAA,SAAS7N,EAAaX,GACpB,OAAO,IAAI8Q,EAAkBnQ,EAAK,IAAImN,GAAgBzV,KAAK0H,MAAOC,EAAO3H,KAAKwW,EAAGxW,KAAKuI,QAGxF4N,sBAAA,SAAUxO,GACR,oBADQA,EAAgB3H,KAAKuW,GACtBmC,KAAKjb,mB1CjEUwB,EAAauX,GACrC,OAAOvX,EAAIV,OAASiY,EAAIvX,EAAI0Z,OAAO,EAAGnC,EAAI,GAAK,MAAQvX,E0CgE/B2Z,CAAS5Y,KAAK0H,MAAMsN,MAAMrN,GAAQ,MAM1DwO,sBAAA,WAEE,OADA0C,QAAQC,KAAK,qEACN9Y,KAAKmX,kBAGdhB,4BAAA,WACEnW,KAAK2W,YAEL,IADA,IAAMhP,EAAQ3H,KAAKuW,EACZvW,KAAKmY,WAAa7T,KAActE,KAAKuW,EAC5C,OAAO,IAAId,GAAgBzV,KAAK0H,MAAOC,EAAO3H,KAAKuW,EAAGvW,KAAKuI,OAG7D4N,wBAAA,WAEE,IADA,IAAM4C,EAAS,KACF,CACX,IAAMC,EAAOhZ,KAAKiZ,WAClB,IAAKD,EAAM,OAAOD,EAClBA,EAAOha,KAAKia,KAIhB7C,sBAAA,WACEnW,KAAK2W,YACe,MAAhB3W,KAAKiX,UAAkBjX,KAAKuW,EAChC,IAGIhZ,EAHEoK,EAAQ3H,KAAKuW,EACbzN,EAAO9I,KAAKmX,iBAClB,GAAKrO,EAAKxI,OAQV,OALAN,KAAK2W,YACe,MAAhB3W,KAAKiX,WACLjX,KAAKuW,EACPhZ,EAAQyC,KAAKsW,aAER,IAAI4C,GAAUlZ,KAAK0H,MAAOC,EAAO3H,KAAKuW,EAAGzN,EAAMvL,EAAOyC,KAAKuI,OAGpE4N,uBAAA,WACE,OAAOnW,KAAK0H,MAAMsN,MAAMhV,KAAKuW,IAG/BJ,qBAAA,SAASrX,gBAAAA,KACPkB,KAAKuW,GAAKzX,GAGZqX,iBAAA,WACE,OAAOnW,KAAKuW,GAAKvW,KAAKwW,GAGxBL,oBAAA,SAAQ9Q,GACN,KAAOrF,KAAKuW,EAAIvW,KAAKwW,GAEnB,KADExW,KAAKuW,EACHvW,KAAKqY,OAAOhT,GAAM,OAAOrF,KAAKuW,EAEpC,OAAQ,GAGVJ,uBAAA,WACE,IAAM5Y,EAAQyC,KAAKoY,cAAgBpY,KAAKmZ,YACxC,GAAI5b,EAAO,OAAOA,EAElB,GAAoB,MAAhByC,KAAKiX,OAAgB,CAGvB,GAFAjX,KAAKuW,MACC7C,EAAO1T,KAAKoY,cACP,OACX,GAAoB,MAAhBpY,KAAKiX,OAAgB,OAEzB,OADAjX,KAAKuW,IACE,IAAI6C,GAAoB1F,EAAM,GAAI1T,KAAKuW,GAGhD,IAAMV,EAAW7V,KAAKmX,iBACtB,GAAKtB,EAASvV,OAAd,CAIA,IAFA,IAAIzC,EAAWgY,EAAShY,UAAS,GAC3B4V,EAA2C,KAE/C,GAAoB,MAAhBzT,KAAKiX,OAAgB,CACvBpZ,GAAW,EACXmC,KAAKuW,IACL,IAAM7C,EAAO1T,KAAKsW,aAAe,IAAIb,GAAgBzV,KAAK0H,MAAO1H,KAAKuW,EAAGvW,KAAKuW,EAAGvW,KAAKuI,MACtFvI,KAAKwY,OAAO,KACZ/E,EAAM1U,KAAK2U,OACN,CAAA,GAAoB,MAAhB1T,KAAKiX,QAAmC,MAAjBjX,KAAKiX,KAAK,GAMrC,MAHL,GAFAjX,KAAKuW,MACC7C,EAAO1T,KAAKmX,kBACR7W,OAAQ,MACboT,EAAK7V,aAAYA,GAAW,GACjC4V,EAAM1U,KAAK2U,GAGf,OAAKD,EAAMlV,QAAUgT,GAAcnT,eAAeyX,EAASrB,SAClD,IAAI6E,GAAarZ,KAAK0H,MAAOmO,EAASlO,MAAOkO,EAASxQ,IAAKrF,KAAKuI,MAErE1K,EAAiB,IAAIyb,GAAYzD,EAAUpC,EAAM,IAC9C,IAAI2F,GAAoBvD,EAAUpC,EAAOzT,KAAKuW,KAGvDJ,uBAAA,WACEnW,KAAK2W,YACL,IAAMhP,EAAQ3H,KAAKuW,EACnB,GAAoB,MAAhBvW,KAAKiX,OAAT,GACEjX,KAAKuW,EACP,IAAMzD,EAAM9S,KAAKuZ,mBACjBvZ,KAAKuW,GAAK,EACV,IAAMxD,EAAM/S,KAAKuZ,mBAEjB,QADEvZ,KAAKuW,EACA,IAAIiD,GAAWxZ,KAAK0H,MAAOC,EAAO3H,KAAKuW,EAAGzD,EAAKC,EAAK/S,KAAKuI,QAGlE4N,8BAAA,WAAA,WACQ5Y,EAAQyC,KAAKsW,YAEnB,OADAtL,GAAOzN,EAAO,WAAM,MAAA,oBAAoBsL,EAAKqO,gCACtC3Z,GAGT4Y,wBAAA,WACEnW,KAAK2W,YACL,IAAMhP,EAAQ3H,KAAKuW,EACnB,GpC5TiB,EoC4TXvW,KAAKmY,WAAX,GACEnY,KAAKuW,EAEP,IADA,IAAIkD,GAAU,EACPzZ,KAAKuW,EAAIvW,KAAKwW,MACjBxW,KAAKuW,EACHvW,KAAK0H,MAAM1H,KAAKuW,EAAI,KAAOvW,KAAK0H,MAAMC,IAAW8R,IACjDA,EAASA,GAAU,EACa,OAA3BzZ,KAAK0H,MAAM1H,KAAKuW,EAAI,KAAakD,GAAU,GAEtD,OAAO,IAAIC,GAAY1Z,KAAK0H,MAAOC,EAAO3H,KAAKuW,EAAGvW,KAAKuI,QAGzD4N,0BAAA,WAEE,IADA,IAAMxO,EAAQ3H,KAAKuW,IACVvW,KAAKmY,WAAa5T,IAA0B,MAAhBvE,KAAKiX,QAAkBjX,KAAKuW,EAAIvW,KAAKwW,GAAGxW,KAAKuW,IAClF,OAAO,IAAId,GAAgBzV,KAAK0H,MAAOC,EAAO3H,KAAKuW,EAAGvW,KAAKuI,OAG7D4N,mBAAA,SAAOwD,GACL,IAAK,IAAI7a,EAAI,EAAGA,EAAI6a,EAAKpb,OAAQO,IAC/B,GAAI6a,EAAK7a,KAAOkB,KAAK0H,MAAM1H,KAAKuW,EAAIzX,GAAI,OAAO,EAEjD,OAAO,GAGTqX,oBAAA,SAAQyD,GACN,IAAK,IAAI9a,EAAI,EAAGA,EAAI8a,EAAQrb,OAAQO,IAClC,GAAI8a,EAAQA,EAAQrb,OAAS,EAAIO,KAAOkB,KAAK0H,MAAM1H,KAAKuW,EAAI,EAAIzX,GAAI,OAAO,EAE7E,OAAO,GAGTqX,sBAAA,SAAU9W,GACR,oBADQA,KACDgF,EAAMrE,KAAK0H,MAAMvC,WAAWnF,KAAKuW,EAAIlX,KAG9C8W,kBAAA,SAAM9W,GACJ,oBADIA,KACGW,KAAK0H,MAAM1H,KAAKuW,EAAIlX,IAG7B8W,uBAAA,WACE,KAAOnW,KAAKmY,WAAa5T,KAASvE,KAAKuW,OA7UzC,YACS7O,EACC/C,EACA4D,gBAAAA,MAFDvI,WAAA0H,EACC1H,UAAA2E,EACA3E,UAAAuI,EAPVvI,OAAI,EAEIA,iBAAc,EAOpBA,KAAKwW,EAAI9O,EAAMnJ,kBE/BW2I,QAAAgP,QAG5B,YACExO,EACAC,EACAtC,EACAgG,EACA9C,GALF,WAOUxC,gBAAaD,iBAAcK,qBAAkBC,sBAC/C7I,EAAQmK,EAAMsN,MAAMrN,EAAQxB,EAAiB5H,OAAQ8G,EAAMe,EAAkB7H,QACnFsK,EAAAD,aAAMwF,YAAUsB,IAAKnS,EAAOmK,EAAOC,EAAOtC,EAAKU,EAAaD,EAAcyC,SAE1E,IAAMsR,EAAY,IAAI1D,GAAUtN,EAAK2L,QAASnJ,EAAQxE,eAEtD,GADAgC,EAAKC,KAAO+Q,EAAU1C,iBAAiBvC,WAClC/L,EAAKC,KAAM,MAAM,IAAI2P,EAAkB,qBAAsB5P,UAElEgR,EAAUlD,YACV9N,EAAKiN,KAAO+D,EAAUC,sBCLtB9D,oBAAF,SAAUhT,4EACFgW,EAAO,4CACKxQ,EAAA3D,EAAA5H,OAAOuM,KAAKxJ,KAAKgZ,wDAAxBjc,UACT0O,EAAAuN,EAAKjU,EAAAhI,OAA0B2I,IAAnB1F,KAAKgZ,KAAKjc,UAAqB6O,GAAA,iBAAO,SAAMuH,GAAUnT,KAAKgZ,KAAKjc,GAAMiG,WAAhC4I,EAAAmO,0BAAlDtO,4MAEF,SAAOuN,WAXT,YAAagB,WADbha,UAA+B,GAE7B,IAAM6Z,EAAY,IAAI1D,GAAU6D,EAAQ,QACxC,IAAmB,IAAApV,EAAAC,EAAAgV,EAAUI,4CAAc,CAAtC,IAAMjB,UACThZ,KAAKgZ,KAAKA,EAAKlQ,KAAK0L,SAAWwE,EAAKzb,yGCV1C,QAYSwY,oBAAP,SAAexY,EAAY+J,WACnB4S,EAAc,OACpB,IAAkB,IAAAtV,EAAAC,EAAA7E,KAAK8V,oCAAqB,CAAvC,IAAMjT,UCbN/E,EDcgB+E,GAAMqX,EAAKnb,KAAK,CAAC8D,EAAI,GAAIsQ,GAAUtQ,EAAI,GAAIyE,KACzD4S,EAAKnb,KAAKoU,GAAUtQ,EAAKyE,sGAEhC,OAAOtH,KAAKgT,KAAKmH,MAAM,CAAE7S,UAAS8S,OAAQpa,KAAKoa,WAAW7c,GAAU2c,SAZtE,YAAoBpR,EAAckK,EAAyB8C,EAAmBsE,GAC5Epa,KAAK8I,KAAOA,EACZ9I,KAAKgT,KAAOA,GAAQ1T,EACpBU,KAAK8V,KAAOA,EACZ9V,KAAKoa,OAASA,UECPC,mBAAT,SAAgBrX,EAAcwP,oEAElB,OADVA,EAAUA,GAAYxP,EAAIE,KAAKwD,WAAmC,EAAtB1G,KAAK8W,QAAQvY,QAAuC,YAAzByB,KAAK8W,QAAQ,GAAGhO,QACvE9I,KAAKsa,QAAQC,SAASvX,EAAKwP,WAAvCjT,EAAMwF,iDAEWyD,EAAA3D,EAAA7E,KAAK8W,oEACLjI,OAAOtP,EAAKyD,WAA/BzD,EAAMwF,2MAER,SAAOxF,WAZT,YAAoBN,EAAamb,GANjBpa,aAAoB,GAOlC,IAAM6Z,EAAY,IAAI1D,GAAUlX,EAAKmb,EAAO/O,QAAQxE,eACpD7G,KAAKsa,QAAUT,EAAUW,iBACzBxa,KAAK8W,QAAU+C,EAAUY,cAAczS,IAAI,SAACQ,OAAEM,SAAMgN,SAAW,OAAA,IAAIC,GAAOjN,EAAMsR,EAAOtD,QAAQnD,IAAI7K,GAAOgN,EAAMsE,KCVpH,WAAyBlT,QAAAwT,IAgBdhL,oBAAT,SAAiB1M,EAAcuL,4DAChB,SAAM,IAAIyH,GAAKhW,KAAKuH,MAAMuO,MAAMjH,OAAO7L,kBAA9CgW,EAAOxQ,SAEThL,GADEwV,EAAOhT,KAAKgT,MACEnE,WAAsBmE,EAAKnE,OAAO7L,EAAKuL,EAASyK,iBAAvC,SAAOxQ,mCAftC,YAAoBjB,EAAiBwJ,EAAyBqJ,GAA9D,MACExR,aAAMrB,SACNsB,EAAKC,KAAOvB,EAAMuB,KAElB,IAAMkK,EAAOoH,EAAOO,KAAKhH,IAAIpM,EAAMuB,aAEnCD,EAAKmK,KAAO/V,OAAO2d,OAAO5H,GAC1BnK,EAAKmK,KAAKoH,OAASA,EACfvR,EAAKmK,KAAK6H,OACZhS,EAAKmK,KAAK6H,MAAMtT,EAAOwJ,KCX7B,WAA4B7J,QAAAwT,IAMjBlL,oBAAT,SAAiBxM,EAAcuL,0DACjB,SAAMvO,KAAKzC,MAAMA,MAAMyF,GAAK,kBAAlCzD,EAAMiJ,SACZ+F,EAAQ9N,MAAMlB,eANhB,YAAoBgI,EAAoB6S,GAAxC,MACExR,aAAMrB,gBACNsB,EAAKtL,MAAQ,IAAI8c,GAAM9S,EAAMiN,QAAS4F,KCN1C,WAA0BlT,QAAAwT,IAMfpL,oBAAT,SAAiBtM,EAAcuL,oCAC7BA,EAAQ9N,MAAMT,KAAKf,gBALrB,YAAoBsI,GAApB,MACEqB,aAAMrB,gBACNsB,EAAK5J,IAAMsI,EAAMuT,eCKrB,QAeSC,mBAAP,SAAc7N,EAAc1L,GAC1B,IACMuP,EADY,IAAIoF,GAAUjJ,EAAMlN,KAAKoa,OAAO/O,QAAQxE,cAAerF,GAChDwZ,mBAAmBhb,KAAKoa,OAAO/O,SACxD,OAAOrL,KAAKib,YAAYlK,IAEnBgK,yBAAP,SAAoBhK,GAGlB,IAFA,IAAIxJ,EACE+G,EAAwB,GACtB/G,EAAQwJ,EAAOC,SACrB1C,EAAUvP,KAAKiB,KAAKkR,WAAW3J,EAAOwJ,IAExC,OAAOzC,GAEFyM,wBAAP,SAAmBxT,EAAsB2T,GACvC,IACE,OAAIzL,GAAWlI,GACN,IAAImI,GAAInI,EAAO2T,EAAclb,KAAKoa,QAEvC7K,GAAchI,GACT,IAAIiI,GAAOjI,EAAsBvH,KAAKoa,QAExC,IAAI9K,GAAK/H,GAChB,MAAOyG,GACP,MAAM,IAAImN,EAAWnN,EAAGzG,KAGrBwT,yBAAP,SAAoBhK,GAApB,WACE,OAAO,IAAIP,GAAYO,EAAQ,SAACxJ,EAAOwJ,GAAW,OAAAlI,EAAKqI,WAAW3J,EAAOwJ,MAEjEgK,8BAAV,SAA4BxS,EAAcwC,EAAgBtM,EAAoC2M,iCAApC3M,EAAmB2K,GAAWoC,gDAIzE,OAHPzO,EAAMiD,KAAKob,OAAOnP,mBAAmB1D,GACvC6C,EAAc,IAAM7C,EACpB9J,EAAO,IAAM8J,KACEvI,KAAKE,MAAOmb,KAAKte,WACpC,GADMue,EAAO9S,SACH,SAAO8S,GAEXC,EAAO9N,GAAWzN,KAAKwb,WAAWjT,EAAMwC,EAAMtM,EAAM2M,IAC1DpL,KAAKE,MAAOO,MAAM1D,EAAKwe,oBAEd,gCAAMA,UAAb,SAAO/S,iCAGPxI,KAAKE,MAAOM,OAAOzD,8BAGbge,wBAAV,SAAsBxS,EAAcwC,EAAgBtM,EAAoC2M,mCAApC3M,EAAmB2K,GAAWoC,gDAC/D,SAAMxL,KAAKob,OAAOK,OAAOlT,EAAM9J,EAAMsM,EAAMK,kBAAtD5J,EAAWuD,SACVH,GAAA4D,EAAAxI,KAAKoa,QAAOS,MAAM9P,GAAOU,EAAAzL,KAAK4F,GAAG8V,aAAala,uBAAY,SAAMxB,KAAK4F,GAAG+V,SAASna,WAAvBiK,EAAA1G,0BAAjE,SAAOH,aAA4FpD,aAtDrG,YAAoB4Y,GAClBpa,KAAKoa,OAASA,EACdpa,KAAKE,MAAQF,KAAKoa,OAAO/O,QAAQnL,MACjCF,KAAK4F,GAAK5F,KAAKoa,OAAO/O,QAAQzF,GAC9B5F,KAAK4b,UAAY5b,KAAKE,MAAQF,KAAK6b,iBAAmB7b,KAAKwb,WAC3Dxb,KAAKob,OAAS,IAAIjQ,GAAOnL,KAAKoa,OAAO/O,gBC1B1B,CACbwP,MAAO,SAAUtT,GACf,IAAMsS,EAAY,IAAI1D,GAAU5O,EAAMuO,KAAM9V,KAAKoa,OAAO/O,QAAQxE,eAChE7G,KAAKjD,IAAM8c,EAAU1C,iBAAiB3C,QACtCqF,EAAUlD,YACV3L,GAA4B,MAArB6O,EAAU5C,OAAgB,WAAM,MAAA,iBAAiB1P,EAAMqN,YAC9DiF,EAAUiC,UACV9b,KAAKzC,MAAQsc,EAAUC,aAEzBjL,OAAQ,SAAY7L,4DACO,OAAzBwF,EAAAxF,EAAI+Y,SAASnX,EAAA5E,KAAKjD,OAAaiD,KAAKoa,OAAO4B,WAAWhc,KAAKzC,MAAOyF,kBAAlEwF,KAAyBiD,2BCVbwQ,GAAc1c,GAC5B,OAAIzB,EAAQyB,GAAaA,EACrBjC,EAASiC,IAAqB,EAAbA,EAAIhB,OAAmB,CAACgB,GACzCf,EAASe,GAAatC,OAAOuM,KAAKjK,GAAKyI,IAAI,SAACjL,GAAQ,MAAA,CAACA,EAAKwC,EAAIxC,MAC3D,YAGOmf,GAAS3c,GACvB,OAAIzB,EAAQyB,GAAaA,EAClB,CAAEA,GCTX,WAAiC2H,QAAApK,GASxBqf,kBAAP,WACEnc,KAAKlB,KAEAqd,oBAAP,WACE,OAAOnc,KAAKlB,GAEPqd,mBAAP,WACE,OAAOnc,KAAKlB,EAAI,GAEXqd,mBAAP,WACE,OAAkB,IAAXnc,KAAKlB,GAEPqd,kBAAP,WACE,OAAOnc,KAAKlB,IAAMkB,KAAKzB,OAAS,GAE3B4d,oBAAP,WACE,OAAOnc,KAAKzB,OAASyB,KAAKlB,GAErBqd,qBAAP,WACE,OAAOnc,KAAKzB,OAASyB,KAAKlB,EAAI,GAEzBqd,qBAAP,WACE,OAAOzD,KAAKjb,UAAUuC,WA3BxB,YAAoBzB,EAAgB6d,EAAoBvG,GAAxD,MACEjN,2BAJQC,IAAI,EAKZA,EAAKtK,OAASA,EACdsK,EAAKC,KAAU+M,MAAYuG,ICJ/B,IAAMC,GAAY,CAAC,SAAU,QAAS,eAIvB,CACb5d,KAAM,QACNoc,MAAO,SAAUtT,EAAiB2T,GAA3B,IAiBD3E,SAhBEsD,EAAY,IAAI1D,GAAU5O,EAAMuO,KAAM9V,KAAKoa,OAAO/O,QAAQxE,eAE1DgP,EAAWgE,EAAU1C,iBACrBmF,EAAQzC,EAAU1C,iBAClBiF,EAAavC,EAAUvD,YAC7BtL,GACE6K,EAASvV,QAA4B,OAAlBgc,EAAM9H,SAAoB4H,EAC7C,WAAM,MAAA,gBAAgB7U,EAAMqN,YAG9B5U,KAAK6V,SAAWA,EAASrB,QACzBxU,KAAKoc,WAAaA,EAClBpc,KAAKgZ,KAAO,IAAIhD,GAAK6D,EAAUC,aAC/B9Z,KAAKsO,UAAY,GACjBtO,KAAKuc,cAAgB,GAGrB,IAAM5N,EAAsB3O,KAAKoa,OAAOoC,OAAOC,YAAYvB,GACxDwB,GAAG,QAAS,WAAM,OAACnG,EAAI1N,EAAKyF,YAC5BoO,GAAG,WAAY,WAAM,OAACnG,EAAI1N,EAAK0T,gBAC/BG,GAAG,aAAc,WAAM,OAAA/N,EAAO/P,SAC9B8d,GAAG,WAAY,SAACxT,GAAkB,OAAAqN,EAAExX,KAAKmK,KACzCwT,GAAG,MAAO,WACT,MAAM,IAAIna,MAAM,OAAOgF,EAAMqN,2BAGjCjG,EAAOhQ,SAETkQ,OAAQ,SAAY7L,EAAcuL,gFAEF,OADxBhL,EAAIvD,KAAKoa,OAAOuC,SACLnU,EAAAyT,MAAmB9I,GAAUnT,KAAKoc,WAAYpZ,kBAA3DoZ,EAAa5T,gBAAaiD,YAEdlN,gBACRgF,EAAEkL,gBAAgBzO,KAAKuc,cAAevZ,EAAKuL,WACjD,OADA9C,oBAIW,SAAMzL,KAAKgZ,KAAKnK,OAAO7L,WAA9BgW,EAAOvN,SACPmR,EAAY5c,KAAKoa,OAAO/O,QAAQwR,wBAClC5f,OAAOuM,KAAKwP,GAAMjC,OAAO,SAAA7I,GAAK,OAAAmO,GAAUS,SAAS5O,KACjDmO,GAAUtF,OAAO,SAAA7I,GAAK,YAAYxI,IAAZsT,EAAK9K,KAE/BkO,EAAaQ,EAAU5S,OAAO,SAACoS,EAAYW,GACzC,MAAiB,WAAbA,EAyBV,SAAoBze,EAAe0e,GACjC,OAAO1e,EAAI0W,MAAMgI,GA1BqBC,CAAOb,EAAYpD,EAAa,QACjD,UAAb+D,EA4BV,SAAmBze,EAAe0e,GAChC,OAAO1e,EAAI0W,MAAM,EAAGgI,GA7BiBrc,CAAMyb,EAAYpD,EAAY,OAoBrE,SAAsB1a,GACpB,OAAOuL,EAAIvL,GAAK4e,UApBLC,CAASf,IACfA,GAEGjS,EAAQ,CAAEiT,QAAS,IAAIjB,GAAYC,EAAW7d,OAAQyB,KAAKoc,WAAWxH,UAAW5U,KAAK6V,WAC5F7S,EAAIjE,KAAKoL,8CACUkT,EAAAxY,EAAAuX,oDAARkB,UACTnT,EAAMnK,KAAK6V,UAAYyH,KACjB/Z,EAAEkL,gBAAgBzO,KAAKsO,UAAWtL,EAAKuL,YAC7C,GADA9C,SACI8C,EAAe,MAEjB,OADAA,EAAe,OAAI,QAGrBA,EAAkB,UAAI,EACtBpE,EAAMiT,QAAQtd,qNAEhBkD,EAAIpB,sBCrEO,CACbiZ,MAAO,SAAU0C,EAAoBrC,GAA9B,WACCrB,EAAY,IAAI1D,GAAUoH,EAASzH,KAAM9V,KAAKoa,OAAO/O,QAAQxE,eACnE7G,KAAK6V,SAoBT,SAA2BgE,GACzB,IAAMF,EAAOE,EAAU1C,iBAAiB3C,QACxC,GAAImF,EAAM,OAAOA,EACjB,IAAM6D,EAAS3D,EAAUzB,aACzB,GAAIoF,EAAQ,OAAO1I,GAAgB0I,GAxBjBC,CAAiB5D,GACjC7O,GAAOhL,KAAK6V,SAAU,WAAM,OAAG0H,EAASzH,+BAExC9V,KAAKsO,UAAY,GAEjB,IAAMK,EAAS3O,KAAKoa,OAAOoC,OAAOC,YAAYvB,GAC9CvM,EAAO+N,GAAG,iBAAkB,WAAM,OAAA/N,EAAO/P,SACtC8d,GAAG,WAAY,SAACxT,GAAkB,OAAAL,EAAKyF,UAAUvP,KAAKmK,KACtDwT,GAAG,MAAO,WACT,MAAM,IAAIna,MAAM,OAAOgb,EAAS3I,2BAEpCjG,EAAOhQ,SAETkQ,OAAQ,SAAY7L,0DAEL,SADHhD,KAAKoa,OAAOuC,SACDlO,gBAAgBzO,KAAKsO,UAAWtL,kBAA/CkK,EAAO1E,SACbxF,EAAI+Y,SAAS/b,KAAK6V,UAAY3I,eCtB7BwQ,GAAAA,MCGU,CACb7C,MAAO,SAAU0C,EAAoBrC,GAA9B,WACLlb,KAAK2d,KAAO,IAAItD,GAAMkD,EAASzH,KAAM9V,KAAKoa,QAC1Cpa,KAAK4d,MAAQ,GACb5d,KAAKuc,cAAgB,GAErB,IAAIhG,EAAgB,GACd5H,EAAsB3O,KAAKoa,OAAOoC,OAAOC,YAAYvB,GACxDwB,GAAG,WAAY,SAACnV,GACfgP,EAAI,GAIJ,IAFA,IAAMsD,EAAY,IAAI1D,GAAU5O,EAAMuO,KAAMjN,EAAKuR,OAAO/O,QAAQxE,gBAExDgT,EAAUxU,OAAO,CACvB,IAAM9H,EAAQsc,EAAUvD,YACxBzN,EAAK+U,MAAM7e,KAAK,CACdQ,IAAKhC,EACL+Q,UAAWiI,IAEbsD,EAAUrB,OAAO,QAGpBkE,GAAG,WAAY,WAAM,OAACnG,EAAI1N,EAAK0T,gBAC/BG,GAAG,cAAe,WAAM,OAAA/N,EAAO/P,SAC/B8d,GAAG,WAAY,SAACxT,GAAkB,OAAAqN,EAAExX,KAAKmK,KACzCwT,GAAG,MAAO,WACT,MAAM,IAAIna,MAAM,OAAOgb,EAAS3I,2BAGpCjG,EAAOhQ,SAGTkQ,OAAQ,SAAY7L,EAAcuL,0EAEX,OADfhL,EAAIvD,KAAKoa,OAAOuC,SACTnU,EAAA9K,KAAcsC,KAAK2d,KAAKpgB,MAAMyF,EAAKA,EAAIE,KAAKwD,mBAAnDiX,EAAOnV,gBAAQoD,mDACAhH,EAAAC,EAAA7E,KAAK4d,wDAAfC,UACG1K,GAAU0K,EAAOte,IAAKyD,EAAKA,EAAIE,KAAKwD,aACpCiX,WACJpa,EAAEkL,gBAAgBoP,EAAOvP,UAAWtL,EAAKuL,YAC/C,OADA3C,qMAIJ,SAAMrI,EAAEkL,gBAAgBzO,KAAKuc,cAAevZ,EAAKuL,mBAAjD3C,qBCzCW,CACbiP,MAAO,SAAU0C,EAAoBrC,GACnC,IAAMvM,EAAS3O,KAAKoa,OAAOoC,OAAOC,YAAYvB,GAC9CvM,EACG+N,GAAG,QAAS,SAACnV,GACO,eAAfA,EAAMuB,MAAuB6F,EAAO/P,SAEzC8d,GAAG,MAAO,WACT,MAAM,IAAIna,MAAM,OAAOgb,EAAS3I,2BAEpCjG,EAAOhQ,WFdN+e,GAAAA,GAAAA,8BAIHA,8BAGaA,MGDA,CACbI,iBACAC,kBACAlD,MAAO,SAAUtT,GACf,IAAMuO,EAAOvO,EAAMuO,KACb+D,EAAY,IAAI1D,GAAUL,EAAM9V,KAAKoa,OAAO/O,QAAQxE,eAG1D,IAFA7G,KAAW,KAAIA,KAAK8d,cAAcjE,EAAW7Z,KAAKoa,QAClDpa,KAAkB,YAAIuH,EAAMgB,MACpBsR,EAAUxU,OAAO,CACvBwU,EAAUlD,YACV,IAAMhP,EAAQkS,EAAUtD,EAClByH,EAAUnE,EAAU1C,iBAC1B,IAAwB,SAApB6G,EAAQxJ,SAA0C,QAApBwJ,EAAQxJ,WACxCqF,EAAUlD,YAEe,MAArBkD,EAAU5C,QAAgB,CAC5B,IAAM1Z,EAAQsc,EAAUvD,YAExB,GAAI/Y,EAAO,CACT,IAAM0gB,EAAWpE,EAAUtD,EAEvB2H,SACkB,OAFRrE,EAAU1C,iBAEd3C,QAAkB0J,EAAQrE,EAAU1C,iBACzC0C,EAAUtD,EAAI0H,EAEnBje,KAAKge,EAAQxJ,SAAW,CAAEjX,QAAO2gB,MAAOA,GAASA,EAAM1J,SACvDqF,EAAUlD,YACe,MAArBkD,EAAU5C,QAAgB4C,EAAUiC,UAExC,UAONjC,EAAUtD,EAAI5O,EACd,MAEF3H,KAAKgZ,KAAO,IAAIhD,GAAK6D,EAAUC,cAEjCjL,OAAQ,SAAY7L,EAAcuL,4FAEf,OADT6L,GAAF5R,EAAmBxI,aAATgZ,YACOhZ,KAAK+d,eAAe/d,KAAW,KAAGgD,EAAKoX,WAIhD,OAHdpP,GADMxJ,EAAWoK,SACA,WAAM,MAAA,qBAAqBpK,QAEtC2c,EAAW,IAAI9U,GAAQ,GAAIrG,EAAIE,KAAMF,EAAI+H,SAC3BiO,EAAKnK,OAAO7L,cAA1BmH,EAAQyB,SACV5L,KAAW,OACP4E,EAAmB5E,KAAW,KAA5BzC,UAAO2gB,UACf/T,EAAM+T,GAAS1c,GAAY2R,GAAU5V,EAAOyF,IAE9Cmb,EAASpf,KAAKoL,IAEVnK,KAAU,IAAV,aACIyL,EAAmBzL,KAAU,IAA3BzC,UAAO2gB,UAEf9B,EAAaH,GADTG,EAAajJ,GAAU5V,EAAOyF,IAElCmH,EAAe,QAAI,IAAIgS,GAAYC,EAAW7d,OAAQhB,EAAMqX,UAAWsJ,6CACpDb,EAAAxY,EAAAuX,oDAARkB,UACTnT,EAAM+T,GAASZ,KACSlD,EAAOgE,kBAAkB5c,EAAU2c,EAASpT,KAAM/K,KAAkB,sBAC5F,OADMsO,EAAY1C,YACZwO,EAAOuC,SAASlO,gBAAgBH,EAAW6P,EAAU5P,WAA3D3C,SACAzB,EAAMiT,QAAQtd,kOAGE,SAAMsa,EAAOgE,kBAAkB5c,EAAU2c,EAASpT,KAAM/K,KAAkB,sBAC5F,OADMsO,EAAY1C,YACZwO,EAAOuC,SAASlO,gBAAgBH,EAAW6P,EAAU5P,YAA3D3C,oDAaUkS,GAAejE,EAAsBO,GACnD,GAAIA,EAAO/O,QAAQxF,gBAAiB,CAClC,IAAM0C,EAAOsR,EAAUvD,YACvB,QAAa5Q,IAAT6C,EAAoB,MAAM,IAAI8V,UAAU,qBAAqBxE,EAAUnS,WAC3E,GAAuB,SAAnBa,EAAKqM,UAAsB,OAAO,KACtC,GAAIC,GAAyBtM,GAAO,CAElC,IAAM+S,EAAOlB,EAAOS,MAAM/F,GAAgBvM,IAE1C,OAAoB,IAAhB+S,EAAK/c,QAAgB+f,GAAuBhD,EAAK,GAAG/T,OAAe+T,EAAK,GAAG/T,MAAMuT,aAC9EQ,EAET,OAAO/S,EAET,IAAM/G,EAAWqY,EAAU0E,eAAe3J,UAC1C,MAAoB,SAAbpT,EAAsB,KAAOA,WAGtBuc,GAAgBxV,EAAsBvF,EAAcoX,GAClE,MAAoB,iBAAT7R,EAA0BA,EACjCiW,MAAM1gB,QAAQyK,GAAc6R,EAAOuC,SAASlO,gBAAgBlG,EAAMvF,GAC/DmQ,GAAU5K,EAAMvF,aCvGV,CACb8a,iBACAC,kBACAlD,MAAO,SAAUtT,GACf,IAAMuO,EAAOvO,EAAMuO,KACb+D,EAAY,IAAI1D,GAAUL,EAAM9V,KAAKoa,OAAO/O,QAAQxE,eAC1D7G,KAAW,KAAIA,KAAK8d,cAAcjE,EAAW7Z,KAAKoa,QAClDpa,KAAkB,YAAIuH,EAAMgB,KAE5B,IAAMZ,EAAQkS,EAAUtD,EAEA,SADRsD,EAAU1C,iBACd3C,SACVqF,EAAUlD,YACe,MAArBkD,EAAU5C,OACZjX,KAAKye,QAAU5E,EAAUvD,YACpBuD,EAAUtD,EAAI5O,GAChBkS,EAAUtD,EAAI5O,EAErB3H,KAAKgZ,KAAO,IAAIhD,GAAK6D,EAAUC,cAEjCjL,OAAQ,SAAY7L,EAAcuL,0EAGf,OAFT6L,GAAF5R,EAA4BxI,aAAlBgZ,SAAMyF,YACd9B,EAAavC,cACEpa,KAAK+d,eAAe/d,KAAW,KAAGgD,EAAKoX,WAMhD,OALdpP,GADMxJ,EAAWoD,SACA,WAAM,MAAA,qBAAqBpD,QAEtCkd,EAAQ1b,EAAI2b,aAAa,SAAU,aACzC3b,EAAI4G,YAAY,SAAU,IAC1B5G,EAAI4G,YAAY,YAAa8T,GAAUkB,WACnB5F,EAAKnK,OAAO7L,WAEd,OAFZmH,EAAQvF,SACV6Z,IAAStU,EAAM3I,GAAY2R,GAAUsL,EAASzb,OAC1BoX,EAAOgE,kBAAkB5c,EAAUwB,EAAI+H,KAAM/K,KAAkB,qBAEvF,OAFMsO,EAAY1J,SAClB5B,EAAIjE,KAAKoL,MACHwS,EAASlO,gBAAgBH,EAAWtL,EAAKuL,kBAA/C3J,SACA5B,EAAIpB,MACJoB,EAAI6b,gBAAgBH,eCpCT,CACb7D,MAAO,SAAUtT,GACf,IAAMsS,EAAY,IAAI1D,GAAU5O,EAAMuO,KAAM9V,KAAKoa,OAAO/O,QAAQxE,eAChE7G,KAAK6V,SAAWgE,EAAU1C,iBAAiB3C,SAE7C3F,OAAQ,SAAUvH,EAAkBiH,GAClC,IAAMpE,EAAQ7C,EAAQwC,aACjBjM,EAASsM,EAAMnK,KAAK6V,aACvB1L,EAAMnK,KAAK6V,UAAY,GAEzBtH,EAAQ9N,MAAMhD,IAAY0M,EAAMnK,KAAK6V,iBCT1B,CACbgF,MAAO,SAAU0C,GACf,IAAM1D,EAAY,IAAI1D,GAAUoH,EAASzH,KAAM9V,KAAKoa,OAAO/O,QAAQxE,eAC7DiY,EAAQjF,EAAUvD,YAYxB,IAXAuD,EAAUlD,YAEV3W,KAAKuL,WAAa,GAEduT,IACuB,MAArBjF,EAAU5C,QACZjX,KAAK8e,MAAQA,EACbjF,EAAUiC,WACL9b,KAAKuL,WAAWxM,KAAK+f,KAGtBjF,EAAUxU,OAAO,CACvB,IAAM9H,EAAQsc,EAAUvD,YACpB/Y,GAAOyC,KAAKuL,WAAWxM,KAAKxB,GAChCsc,EAAUrB,OAAO,KAEnBxN,GAAOhL,KAAKuL,WAAWhN,OAAQ,WAAM,MAAA,qBAAqBgf,EAAS3I,aAGrE/F,OAAQ,SAAU7L,EAAcuL,GAC9B,IACMwQ,EAAc,SADN5L,GAAUnT,KAAK8e,MAAO9b,OACIhD,KAAKuL,WAAWpD,KAAK,KACvD6W,EAAShc,EAAIyG,YAAY,SAC3BwV,EAAMD,EAAOD,QAELrZ,IAARuZ,IACFA,EAAMD,EAAOD,GAAe,GAG9B,IAAMlU,EAAY7K,KAAKuL,WAAW0T,GAClCA,GAAOA,EAAM,GAAKjf,KAAKuL,WAAWhN,OAClCygB,EAAOD,GAAeE,EACtB,IAAM/R,EAAOiG,GAAUtI,EAAW7H,GAClCuL,EAAQ9N,MAAMyM,QCvCH,CACb2N,MAAO,SAAU0C,EAAoBrC,GAA9B,IAID3E,SAHJvW,KAAKkf,SAAW,GAChBlf,KAAKuc,cAAgB,GAGrBvc,KAAKoa,OAAOoC,OAAOC,YAAYvB,GAC5BwB,GAAG,QAAS,WAAM,OAAA7T,EAAKqW,SAASngB,KAAK,CACpCkM,UAAW,IAAIoP,GAAMkD,EAASzH,KAAMjN,EAAKuR,QACzC9L,UAAYiI,EAAI,OAEjBmG,GAAG,YAAa,SAACnV,GAAoB,OAAAsB,EAAKqW,SAASngB,KAAK,CACvDkM,UAAW,IAAIoP,GAAM9S,EAAMuO,KAAMjN,EAAKuR,QACtC9L,UAAYiI,EAAI,OAEjBmG,GAAG,WAAY,WAAM,OAACnG,EAAI1N,EAAK0T,gBAC/BG,GAAG,YAAa,WAAc1c,KAAKpB,SACnC8d,GAAG,WAAY,SAACxT,GAAkB,OAAAqN,EAAExX,KAAKmK,KACzCwT,GAAG,MAAO,WAAQ,MAAM,IAAIna,MAAM,OAAOgb,EAAS3I,2BAClDjW,SAGLkQ,OAAQ,SAAY7L,EAAcuL,0EAC1BhL,EAAIvD,KAAKoa,OAAOuC,iDAEiBnU,EAAA3D,EAAA7E,KAAKkf,2DAAjCzT,UAAER,cAAWqD,iBACFrD,EAAU1N,MAAMyF,EAAKA,EAAIE,KAAKwD,2BAC9C3D,EADU6I,SACM5I,MACZO,EAAEkL,gBAAgBH,EAAWtL,EAAKuL,iBACxC,OADA3C,qMAIJ,SAAMrI,EAAEkL,gBAAgBzO,KAAKuc,cAAevZ,EAAKuL,mBAAjD3C,qBC/BW,CACbiP,MAAO,SAAUtT,GACf,IAAMsS,EAAY,IAAI1D,GAAU5O,EAAMuO,KAAM9V,KAAKoa,OAAO/O,QAAQxE,eAChE7G,KAAK6V,SAAWgE,EAAU1C,iBAAiB3C,SAE7C3F,OAAQ,SAAUvH,EAAkBiH,GAClC,IAAMpE,EAAQ7C,EAAQwC,aACjBjM,EAASsM,EAAMnK,KAAK6V,aACvB1L,EAAMnK,KAAK6V,UAAY,GAEzB,IAAMtW,EAAM4K,EAAMnK,KAAK6V,UACvB1L,EAAMnK,KAAK6V,YACXtH,EAAQ9N,MAAMhD,EAAU8B,SCVb,CACbue,iBACAC,kBACAlD,MAAO,SAAUtT,EAAiB2T,GAChC,IAAMrB,EAAY,IAAI1D,GAAU5O,EAAMuO,KAAM9V,KAAKoa,OAAO/O,QAAQxE,eAChE7G,KAAW,KAAIA,KAAK8d,cAAcjE,EAAW7Z,KAAKoa,QAClDpa,KAAkB,YAAIuH,EAAMgB,KAC5BvI,KAAKgZ,KAAO,IAAIhD,GAAK6D,EAAUC,aAC/B9Z,KAAKsb,KAAOtb,KAAKoa,OAAOoC,OAAOvB,YAAYC,IAE7CrM,OAAQ,SAAY7L,EAAcuL,qFACxB6L,GAAF5R,EAAyBxI,aAAfgZ,SAAMzQ,SACdoU,EAAavC,WACR,OAAT7R,SACFvF,EAAI4G,YAAY,YAAa8T,GAAUkB,WACjCjC,EAASlO,gBAAgBzO,KAAKsb,KAAMtY,EAAKuL,YAC/C,OADAxJ,oBAGe,SAAM/E,KAAK+d,eAAe/d,KAAW,KAAGgD,EAAKoX,WAE5C,OADlBpP,GADMxJ,EAAWuD,SACA,WAAM,MAAA,qBAAqBvD,WACpB4Y,EAAO+E,iBAAiB3d,EAAUwB,EAAI+H,KAAM/K,KAAkB,qBAIzE,OAJPsO,EAAYvJ,SAGlB/B,EAAI4G,YAAY,YAAa8T,GAAU0B,UACpBzC,EAASlO,gBAAgBzO,KAAKsb,KAAMtY,WAQ9C,OARHkK,EAAOnI,cAIMW,KAHb2Z,EAASrc,EAAIyG,YAAY,WAGpB,MAAmB4V,EAAO,IAAM,SAACC,EAAmB/Q,GAAqB,OAAAA,EAAQ9N,MAAMyM,KAClGlK,EAAI4G,YAAY,YAAa8T,GAAUkB,QAGvCnT,GAAA7G,EAAA5B,GAAIjE,QAAWia,EAAKnK,OAAO7L,WAC3B,OADAyI,WAAS1G,cACH4X,EAASlO,gBAAgBH,EAAWtL,EAAKuL,kBAA/CxJ,SACA/B,EAAIpB,mBCrCuBsF,QAAApK,GAWtByiB,mBAAP,WACE,OAAOvf,KAAKwf,wBAXd,YAEUA,gBAAAA,aAA8C,MAAA,KAFxD,MAIE5W,2BAFQC,mBAAA2W,cCDG,CACb3E,MAAA,SAAsBtT,EAAiB2T,GAAvC,WACQvD,EAAQ,MAAM8H,KAAKlY,EAAMuO,MAC/B9V,KAAK0f,MAAQ/H,EAAQA,EAAM,GAAK,GAChC3X,KAAKsb,KAAO,GACZtb,KAAKoa,OAAOoC,OAAOC,YAAYvB,GAC5BwB,GAAG,eAAgB,WAAc1c,KAAKpB,SACtC8d,GAAG,WAAY,SAACxT,GAAkB,OAAAL,EAAKyS,KAAKvc,KAAKmK,KACjDwT,GAAG,MAAO,WAAQ,MAAM,IAAIna,MAAM,OAAOgF,EAAMqN,2BAC/CjW,SAGHkQ,OAAF,SAAyB7L,EAAcuL,iEAC/BoR,EAAc3f,KAAK4f,eAAe5c,GACpCA,EAAIyG,YAAY,eAAiBiU,GAAU0B,aAC7Cpc,EAAIyG,YAAY,UAAUzJ,KAAK0f,OAASC,gBAExC,SAAMA,EAAY,IAAIJ,GAAahR,WAAnC/F,wCAIJoX,eAAA,SAA+B5c,GAGP,SAAhB6c,EAA4BC,EAAuBvR,oDAGvD,OADAvL,EAAIjE,KAAK,CAAE2gB,MAAOI,OACZ1F,EAAOuC,SAASlO,gBAAgB6M,EAAMtY,EAAKuL,kBAAjD/F,SACAxF,EAAIpB,aANA,IAAEwY,cAAQkB,YACVyE,EAAc/c,EAAIyG,YAAY,UAAUzJ,KAAK0f,OAOnD,OAAOK,EACH,SAACD,EAAuBvR,GAAqB,OAAAwR,EAAY,IAAIR,GAAU,WAAM,OAAAM,EAAcC,EAAYvR,KAAWA,IAClHsR,OClCO,CACbhF,MAAO,SAAU0C,EAAoBrC,GAA9B,WACLlb,KAAK+Q,OAAS,GAEd,IAAMpC,EAAS3O,KAAKoa,OAAOoC,OAAOC,YAAYvB,GAC9CvM,EACG+N,GAAG,QAAS,SAACnV,GACO,WAAfA,EAAMuB,KAAmB6F,EAAO/P,OAC/BiK,EAAKkI,OAAOhS,KAAKwI,KAEvBmV,GAAG,MAAO,WACT,MAAM,IAAIna,MAAM,OAAOgb,EAAS3I,2BAEpCjG,EAAOhQ,SAETkQ,OAAQ,WACN,OAAO7O,KAAK+Q,OAAO/I,IAAI,SAACT,GAAyB,OAAAA,EAAMqN,YAAWzM,KAAK,UChBrCjB,QAAAiV,IAO7B6D,iBAAP,WACE,OAAOpY,KAAKqY,MAAMjgB,KAAKlB,EAAIkB,KAAKkgB,MAAQ,GAEnCF,kBAAP,WACE,OAAQhgB,KAAKlB,EAAIkB,KAAKkgB,MAEjBF,iBAAP,WACE,OAAOhgB,KAAKmgB,OAAS,GAEhBH,uBAAP,WACE,OAAuB,IAAhBhgB,KAAKmgB,QAEPH,sBAAP,WACE,OAAOhgB,KAAKyI,QAAUzI,KAAKkgB,UAlB7B,YAAoB3hB,EAAgB2hB,EAAc9D,EAAoBvG,GAAtE,MACEjN,aAAMrK,EAAQ6d,EAAYvG,gBAC1BhN,EAAKtK,OAASA,EACdsK,EAAKqX,KAAOA,QCaVvF,GAA0C,CAC9CyF,UAAQC,IAAOC,GAAKC,WAASC,KAAQC,GAAMC,WAASC,WAAS9R,UAAQ+R,aAAWC,aAAWC,SAAOC,GAAMC,GAAIC,UAAQvB,SAAOwB,OAAKC,SChBnH,CACbtG,MAAO,SAAU0C,EAAoBrC,GAA9B,WACCrB,EAAY,IAAI1D,GAAUoH,EAASzH,KAAM9V,KAAKoa,OAAO/O,QAAQxE,eAE7DgP,EAAWgE,EAAU1C,iBAC3B0C,EAAUlD,YAEV,IAQIJ,EARE6K,EAAMvH,EAAU1C,iBACtBnM,GAAOoW,GAAuB,OAAhBA,EAAI5M,QAAkB,WAAM,MAAA,gBAAgB+I,EAAS3I,YAEnE5U,KAAK6V,SAAWA,EAASrB,QACzBxU,KAAKoc,WAAavC,EAAUvD,YAC5BtW,KAAKgZ,KAAO,IAAIhD,GAAK6D,EAAUC,aAC/B9Z,KAAKsO,UAAY,GAGjB,IAAMK,EAAsB3O,KAAKoa,OAAOoC,OAAOC,YAAYvB,GACxDwB,GAAG,QAAS,WAAM,OAACnG,EAAI1N,EAAKyF,YAC5BoO,GAAG,kBAAmB,WAAM,OAAA/N,EAAO/P,SACnC8d,GAAG,WAAY,SAACxT,GAAkB,OAAAqN,EAAExX,KAAKmK,KACzCwT,GAAG,MAAO,WACT,MAAM,IAAIna,MAAM,OAAOgb,EAAS3I,2BAGpCjG,EAAOhQ,SAGTkQ,OAAQ,SAAY7L,EAAcuL,4EACF,OAAb/F,EAAAyT,MAAmB9I,GAAUnT,KAAKoc,WAAYpZ,WAClD,OADToZ,EAAa5T,gBAAa5D,cACX5E,KAAKgZ,KAAKnK,OAAO7L,WAA9BgW,EAAOpU,SACPqY,EAASjE,EAAKiE,QAAU,EACxBtc,OAAwB+E,IAAfsT,EAAKrY,MAAuByb,EAAW7d,OAASya,EAAKrY,MAEpEyb,EAAaA,EAAWpH,MAAMiI,EAAQA,EAAStc,GACzCuf,EAAOlH,EAAKkH,MAAQ9D,EAAW7d,OAE/BgF,EAAIvD,KAAKoa,OAAOuC,SAChB0E,EAAe,IAAIrB,GAAiB5D,EAAW7d,OAAQ2hB,EAAMlgB,KAAKoc,WAAWxH,UAAW5U,KAAK6V,UAC7F1L,EAAQ,CAAEkX,gBAChBre,EAAIjE,KAAKoL,GAEA8U,EAAM,0BAAGA,EAAM7C,EAAW7d,QACjC4L,EAAMnK,KAAK6V,UAAYuG,EAAW6C,GACN,IAAxBoC,EAAalB,SACY,IAAvBkB,EAAapM,OAAa1G,EAAQ9N,MAAM,SAC5C8N,EAAQ9N,MAAM,iBAAiB4gB,EAAapM,aAE9C1G,EAAQ9N,MAAM,iBAAiB4gB,EAAa5Y,eACtClF,EAAEkL,gBAAgBzO,KAAKsO,UAAWtL,EAAKuL,kBAA7C3J,SACA2J,EAAQ9N,MAAM,iCAR2Bwe,IAAOoC,EAAavhB,2BAU3Dsc,EAAW7d,QAAQgQ,EAAQ9N,MAAM,SACrCuC,EAAIpB,eDpCoI0f,OEnB7H,CACbzG,MAAO,SAAU0C,EAAoBrC,GAA9B,IAGD3E,SAFJvW,KAAKkf,SAAW,GAChBlf,KAAKuc,cAAgB,GAErBvc,KAAKoa,OAAOoC,OAAOC,YAAYvB,GAC5BwB,GAAG,QAAS,WAAM,OAAA7T,EAAKqW,SAASngB,KAAK,CACpCkM,UAAW,IAAIoP,GAAMkD,EAASzH,KAAMjN,EAAKuR,QACzCvY,KAAMoB,EACNqL,UAAYiI,EAAI,OAEjBmG,GAAG,YAAa,SAACnV,GAAoB,OAAAsB,EAAKqW,SAASngB,KAAK,CACvDkM,UAAW,IAAIoP,GAAM9S,EAAMuO,KAAMjN,EAAKuR,QACtCvY,KAAMkB,EACNuL,UAAYiI,EAAI,OAEjBmG,GAAG,WAAY,WAAM,OAACnG,EAAI1N,EAAK0T,gBAC/BG,GAAG,gBAAiB,WAAc1c,KAAKpB,SACvC8d,GAAG,WAAY,SAACxT,GAAkB,OAAAqN,EAAExX,KAAKmK,KACzCwT,GAAG,MAAO,WAAQ,MAAM,IAAIna,MAAM,OAAOgb,EAAS3I,2BAClDjW,SAGLkQ,OAAQ,SAAY7L,EAAcuL,8EAC1BhL,EAAIvD,KAAKoa,OAAOuC,iDAEuBnU,EAAA3D,EAAA7E,KAAKkf,2DAAvCzT,UAAER,cAAWsW,SAAMjT,iBACRrD,EAAU1N,MAAMyF,EAAKA,EAAIE,KAAKwD,2BAA5CnJ,EAAQqO,SACV2V,EAAKhkB,EAAOyF,MACRO,EAAEkL,gBAAgBH,EAAWtL,EAAKuL,iBACxC,OADA3C,qMAKJ,SAAMrI,EAAEkL,gBAAgBzO,KAAKuc,cAAevZ,EAAKuL,mBAAjD3C,kBFfgJ4V,MGnBrI,CACb3S,OAAQ,SAAU7L,EAAcuL,GAC9BA,EAAe,OAAI,IHiB6IkT,SInBrJ,CACb5S,OAAQ,SAAU7L,EAAcuL,GAC9BA,EAAkB,UAAI,KCFpBmT,GAAY,CAChBC,IAAK,QACL/d,IAAK,OACLH,IAAK,OACLme,IAAK,QACLC,IAAK,SAEDC,GAAc,CAClBC,QAAS,IACTC,OAAQ,IACRC,OAAQ,IACRC,QAAS,IACTC,QAAS,cAGKC,GAAQnjB,GACtB,OAAOxB,EAAUwB,GAAKQ,QAAQ,aAAc,SAAA4iB,GAAK,OAAAX,GAAUW,KChBtD,IAAMC,GAAM1a,KAAK0a,IACXC,GAAU3a,KAAKC,IACf2a,GAAS5a,KAAKE,IACd2a,GAAO7a,KAAK6a,KAEZxC,GAAQrY,KAAKqY,MCL1B,IAAMyC,GAAU,gCACVC,GAAa,CACjB,UAAW,WAAY,QAAS,QAAS,MAAO,OAAQ,OAAQ,SAChE,YAAa,UAAW,WAAY,YAEhCC,GAAW,CACf,SAAU,SAAU,UAAW,YAAa,WAAY,SAAU,YAE9DC,GAAkBF,GAAW3a,IAAI8a,IACjCC,GAAgBH,GAAS5a,IAAI8a,IAC7BE,GAAW,CACfC,EAAG,KACHC,EAAG,KACHC,EAAG,KACHC,QAAW,MAQb,SAASN,GAAM7jB,GACb,OAAOA,EAAI+V,MAAM,EAAG,GAQtB,SAASqO,GAAcC,GAErB,IADA,IAAIC,EAAM,EACDzkB,EAAI,EAAGA,EAAIwkB,EAAEE,aAAc1kB,EAClCykB,GALK,CAAC,GAiBV,SAAqBD,GACnB,IAAMG,EAAOH,EAAEI,cACf,QAAyB,IAAP,EAAPD,MAAoBA,EAAO,KAAQA,EAAO,KAAQ,GAAKA,IApBtDE,CAMSL,GANO,GAAK,GAChB,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAK7BxkB,GAExB,OAAOykB,EAAMD,EAAEM,UAEjB,SAASC,GAAeP,EAASQ,GAE/B,IAAMC,EAAMV,GAAaC,IAAMQ,EAAWR,EAAEU,UAGtC1W,EAAQ,EADD,IAAI2W,KAAKX,EAAEI,cAAe,EAAG,GACnBM,SAAWF,EAClC,OAAOzmB,OAAOuK,KAAKqY,OAAO8D,EAAMzW,GAAQ,GAAK,GAgB/C,IAAM4W,GAAY,CAChBZ,EAAG,EACHtV,EAAG,EACHmW,EAAG,EACHC,EAAG,EACH/R,EAAG,EACHlU,EAAG,EACHmF,EAAG,EACH+gB,EAAG,EACHhC,EAAG,EACHiC,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,GAICC,GAAW,CACf/kB,EAAG,IACHglB,EAAG,IACH/kB,EAAG,IACHglB,EAAG,IACH1f,EAAG,IACH8I,EAAG,IACH7P,EAAG,IACHmF,EAAG,IACHiT,EAAG,IACHsO,EAAG,KAECC,GAAc,CAClBnlB,EAAG,SAAC2jB,GAAY,OAAAP,GAAcO,EAAEU,WAChCW,EAAG,SAACrB,GAAY,OAAAV,GAASU,EAAEU,WAC3BpkB,EAAG,SAAC0jB,GAAY,OAAAT,GAAgBS,EAAEE,aAClCoB,EAAG,SAACtB,GAAY,OAAAX,GAAWW,EAAEE,aAC7Bte,EAAG,SAACoe,GAAY,OAAAA,EAAEyB,kBAClBC,EAAG,SAAC1B,GAAY,OAxClB,SAAkBA,GAChB,OAAO2B,SAAS3B,EAAEI,cAAcvmB,WAAW+nB,UAAU,EAAG,GAAI,IAuC5CC,CAAQ7B,IACxBA,EAAG,SAACA,GAAY,OAAAA,EAAEM,WAClB5V,EAAG,SAACsV,GAAY,OAAAA,EAAEM,WAClBO,EAAG,SAACb,GAAY,OAAAA,EAAE8B,YAClBhB,EAAG,SAACd,GAAY,OAAAjmB,OAAOimB,EAAE8B,WAAa,IAAM,KAC5C/S,EAAG,SAACiR,GAAY,OAAAD,GAAaC,IAC7BnlB,EAAG,SAACmlB,GAAY,OAAAA,EAAE8B,YAClB9hB,EAAG,SAACggB,GAAY,OAAAjmB,OAAOimB,EAAE8B,WAAa,IAAM,KAC5Cf,EAAG,SAACf,GAAY,OAAAA,EAAE+B,mBAClBhD,EAAG,SAACiB,GAAY,OAAAA,EAAEE,WAAa,GAC/Bc,EAAG,SAAChB,GAAY,OAAAA,EAAEgC,cAClB9O,EAAG,SAAC8M,EAASpgB,GACX,IAAMqiB,EAAQvV,OAAO9M,EAAKqiB,QAAU,EAEpC,gB/EHoBtmB,EAAUV,EAAgBW,GAChD,oBADgDA,OACzCC,EAAIF,EAAKV,EAAQW,EAAI,SAACD,EAAKC,GAAO,OAAAD,EAAMC,I+EEtCsmB,CADKnoB,OAAOimB,EAAE+B,mBAAmB1M,OAAO,EAAG4M,GAC/BA,EAAO,MAE5BhP,EAAG,SAAC+M,GAAY,OAACA,EAAE8B,WAAa,GAAK,KAAO,MAC5CP,EAAG,SAACvB,GAAY,OAACA,EAAE8B,WAAa,GAAK,KAAO,MAC5CK,EAAG,SAACnC,GAAY,OA/DlB,SAAoBA,GAClB,IAAMrkB,EAAMqkB,EAAEM,UAAUzmB,WAClBuoB,EAAQT,SAAShmB,EAAI+V,OAAO,IAClC,OAAOgO,GAAS0C,IAAU1C,GAAkB,QA4D5B2C,CAAUrC,IAC1BsC,EAAG,SAACtC,GAAY,OAAA1b,KAAKie,MAAMvC,EAAE1lB,UAAY,MACzC2mB,EAAG,SAACjB,GAAY,OAAAA,EAAEwC,cAClBC,EAAG,SAACzC,GAAY,OAAAA,EAAEU,UAAY,GAC9BQ,EAAG,SAAClB,GAAY,OAAAO,GAAcP,EAAG,IACjC0C,EAAG,SAAC1C,GAAY,OAAAA,EAAEU,UAClBS,EAAG,SAACnB,GAAY,OAAAO,GAAcP,EAAG,IACjCpV,EAAG,SAACoV,GAAY,OAAAA,EAAE2C,sBAClBC,EAAG,SAAC5C,GAAY,OAAAA,EAAE6C,sBAClBC,EAAG,SAAC9C,GAAY,OAAAA,EAAEI,cAAcvmB,WAAW+nB,UAAU,EAAG,IACxDmB,EAAG,SAAC/C,GAAY,OAAAA,EAAEI,eAClB4C,EAAG,SAAChD,EAASpgB,GACX,IAAMqjB,EAAU3e,KAAK0a,IAAIgB,EAAEkD,qBACrB5V,EAAIhJ,KAAKqY,MAAMsG,EAAU,IACzBlE,EAAIkE,EAAU,GACpB,OAAgC,EAAxBjD,EAAEkD,oBAA0B,IAAM,KACxCxnB,EAAS4R,EAAG,EAAG,MACd1N,EAAKujB,MAAM,KAAO,IAAM,IACzBznB,EAASqjB,EAAG,EAAG,MAEnBpQ,EAAK,WAAM,MAAA,MACX5S,EAAK,WAAM,MAAA,MACXqnB,IAAK,WAAM,MAAA,MAgBb,SAASC,GAAQrD,EAAS3L,WAClB/S,SAAC8C,OAAO+D,OAAAmb,kBAAcrB,OAAOxI,OAAU8J,OACvCC,EAAUhC,GAAY+B,GAC5B,IAAKC,EAAS,OAAOpf,EACrB,IAAM+e,EAAQ,OACd,IAAmB,IAAAM,EAAAliB,EAAA+hB,kCAASH,YAAc,oGAC1C,IAAIpZ,EAAMhQ,OAAOypB,EAAQxD,EAAG,CAAEmD,QAAOlB,QAAOxI,cACxCiK,EAAUtC,GAASmC,IAAe,IAClCI,EAAW1B,GAASrB,GAAU2C,IAAe,EAMjD,OALIJ,EAAM,KAAMpZ,EAAMA,EAAI6Z,cACjBT,EAAM,OAAMpZ,W/EjCKpO,GAE1B,OADqB4K,EAAI5K,GAAKkoB,KAAK,SAAAjoB,GAAM,MAAM,KAANA,GAAaA,GAAM,MACtCD,EAAIioB,cAAgBjoB,EAAI7B,c+E+BnBgqB,CAAW/Z,IAClCoZ,EAAS,EAAGO,EAAU,IACjBP,EAAM,KAAMO,EAAU,KAC3BP,EAAM,OAAMQ,EAAW,GACpBjoB,EAASqO,EAAK4Z,EAAUD,GA5BhClC,GAAoBlU,EAAIkU,GAAYllB,EC1IrC,OACMynB,IAAqB,IAAIpD,MAAOuC,oBAChCc,GAA2B,oCASCpgB,QAAA+c,MAShCsD,+BAAA,WACE,OAAOvnB,KAAKwnB,gBAgBPD,6BAAP,SAAkCE,GAChC,IAAMpF,EAAIoF,EAAW9P,MAAM2P,IAE3B,GAAIjF,GAAc,MAATA,EAAE,GACT,OAAO,IAAIkF,IAAc,IAAItD,KAAKwD,GAAa,GAGjD,GAAIpF,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAI,CACvB,IAAA7Z,SAAKkf,OAAMC,OAAOC,OAClBC,GAAkB,MAATH,GAAgB,EAAI,IAA4B,GAAtBzC,SAAS0C,EAAO,IAAW1C,SAAS2C,EAAS,KACtF,OAAO,IAAIL,IAAc,IAAItD,KAAKwD,GAAaI,GAEjD,OAAO,IAAI5D,KAAKwD,QApClB,YAAaK,EAA8BN,GAA3C,WACE,GAAIM,aAAgBP,GAAc,OAAOO,EACzC,IAAMC,EAfQ,KAeAV,GAAqBG,GAC7BQ,EAAO,IAAI/D,KAAK6D,GAAMG,UAAYF,SACxClf,EAAAD,aAAMof,UACDR,eAAiBA,wDHMEvoB,GAC1B,OAAOmjB,GALT,SAAmBnjB,GACjB,OAAO5B,OAAO4B,GAAKQ,QAAQ,yBAA0B,SAAA4iB,GAAK,OAAAP,GAAYO,KAIxD6F,CAASjpB,0BAGIiT,GAC3B,OAAOA,EAAEzS,QAAQ,MAAO,gCAGCyS,GACzB,OAAOA,EAAEzS,QAAQ,4DAA6D,mDC5BvD,SAACyS,EAAWrP,GAAgB,OAAAqP,EAAIrP,kBAEpC,SAACqP,EAAWrP,GAAgB,OAAAqP,EAAIrP,UAC/B,SAACqP,EAAWrP,GAAgB,OAAAqP,EAAIrP,SACjC,SAACqP,EAAWrP,GAAgB,OAAAqP,EAAIrP,kBAE9BqP,EAAWrP,gBAAAA,KAChC,IAAMslB,EAAMvgB,KAAKwgB,IAAI,GAAIvlB,GACzB,OAAO+E,KAAKie,MAAM3T,EAAIiW,GAAOA,iBAGTjW,EAAWrP,GAC/B,OAAOmN,OAAOkC,GAAKlC,OAAOnN,yBAGC6E,EAAc2gB,GACzC,OAAK3gB,GAAUA,EAAM4gB,UACJ5iB,IAAb2iB,EACKxe,EAAInC,GAAO4gB,KAChB,SAACxV,EAAKC,GAAQ,OAAAlT,EAAuBiT,EAAIuV,GAAWtV,EAAIsV,MAGrDxe,EAAInC,GAAO4gB,KAAKzoB,GANW,cGtBX,SAACqO,GAAc,OAAAA,EAAEvM,MAAM,KAAKqG,IAAIugB,oBAAoBpgB,KAAK,gBACzD,SAAC+F,GAAc,OAAAA,EAAEvM,MAAM,KAAKqG,IAAIwgB,oBAAoBrgB,KAAK,WCK9D,SAAC+J,EAAUrP,GAAgB,OAAAqP,EAAE/J,UAAazC,IAAR7C,EAAoB,IAAMA,SAC5D,SAACqP,GAAW,OAAApU,EAAQoU,GAAKuW,EAAUvW,GAAK,UACvC,SAACA,GAAW,OAAApU,EAAQoU,GAAKA,EAAE,GAAK,YAC9B,SAACA,GAAa,OAAArI,EAAIqI,GAAGgL,yBAED5e,EAAU+pB,GAClC,SAAXK,EAAYzf,GAAe,OAAAof,EAAWxf,EAAKvB,QAAQ+C,aAAapB,EAAKof,EAAS1mB,MAAM,MAAQsH,EADpG,WAEE,OAAOiT,GAAQ5d,GAAKgqB,KAAK,SAACxV,EAAKC,GAG7B,OAFAD,EAAM4V,EAAS5V,KACfC,EAAM2V,EAAS3V,KACK,EAAWA,EAAND,EAAY,EAAI,UAIzB,SAACZ,GAAsB,OAACA,GAAKA,EAAE3T,QAAW,gBAEfD,EAAc+pB,GAA7D,WACE,OAAOnM,GAAQ5d,GAAK0J,IAAI,SAAAiB,GAAO,OAAAJ,EAAKvB,QAAQ+C,aAAapB,EAAKof,EAAS1mB,MAAM,0BAGjCrD,GAC5C,OAAO4d,GAAQ5d,GAAKyY,OAAO,SAAA7I,GAAK,OAACvQ,EAAMuQ,sBAGTgE,EAASrP,GACvC,OAAOqZ,GAAQhK,GAAGyW,OAAO9lB,mBAGDqP,EAAQvK,EAAepJ,GAE/C,oBAF+CA,KAC/CoJ,EAAQA,EAAQ,EAAIuK,EAAE3T,OAASoJ,EAAQA,EAChCuK,EAAE8C,MAAMrN,EAAOA,EAAQpJ,mBAG2BD,EAAU+pB,EAAkBO,GAAvF,WACE,OAAO1M,GAAQ5d,GAAKyY,OAAO,SAAA9N,GACzB,IAAM1L,EAAQsL,EAAKvB,QAAQ+C,aAAapB,EAAK5L,OAAOgrB,GAAU1mB,MAAM,MACpE,YAAoB+D,IAAbkjB,EAAyB7lB,EAASxF,EAAOsL,EAAKvB,SAAW/J,IAAUqrB,mBAIrDtqB,GACvB,IAAMynB,EAAI,GACV,OAAQznB,GAAO,IAAIyY,OAAO,SAAAxX,GACxB,OAAIwmB,EAAE3nB,eAAef,OAAOkC,MAC5BwmB,EAAE1oB,OAAOkC,KAAQ,oBC7CmB2S,EAAkBrP,GACxD,IACIgmB,EADE3lB,EAAOlD,KAAKsH,QAAQpE,KAiB1B,OAOF,SAAsB2lB,GACpB,OAAOA,aAAgB5E,OAAS6E,MAAMD,EAAKZ,WARtCc,CAdHF,EADQ,QAAN3W,GAAqB,UAANA,EACV,IAAI+R,KACFpmB,EAASqU,GACX,IAAI+R,KAAS,IAAJ/R,GACP5U,EAAS4U,GACd,QAAQrQ,KAAKqQ,GACR,IAAI+R,KAAU,KAAJ/R,GACRhP,EAAKqD,kBACPghB,GAAayB,0BAA0B9W,GAEvC,IAAI+R,KAAK/R,GAGXA,IAGLhP,EAAK9E,eAAe,oBACtByqB,EAAO,IAAItB,GAAasB,EAAM3lB,EAAKskB,0BJoHdlE,EAAS2F,GAIhC,IAHA,IAEItR,EAFAuR,EAAS,GACTpP,EAAYmP,EAERtR,EAAQ+K,GAAQjD,KAAK3F,IAC3BoP,GAAUpP,EAAU9E,MAAM,EAAG2C,EAAM+N,OACnC5L,EAAYA,EAAU9E,MAAM2C,EAAM+N,MAAQ/N,EAAM,GAAGpZ,QACnD2qB,GAAUvC,GAAOrD,EAAG3L,GAEtB,OAAOuR,EAASpP,EI3HTqP,CAASN,EAAMhmB,IAJSqP,oBCnBkBA,EAAgBrP,GACjE,OAAI/E,EAAQoU,IAAM5U,EAAS4U,GAAWA,EAAE3T,OAAS2T,EAAIrP,EAC9CI,EAAQvF,EAAQwU,GAAIlS,KAAKsH,SAAWzE,EAAMqP,iBAE7BA,GACpB,OAAOwG,KAAKjb,UAAUyU,oBCDAA,EAAWrP,GAEjC,OADAmI,GAA4B,IAArBoe,UAAU7qB,OAAc,6BACxBd,EAAUyU,GAAKzU,EAAUoF,qBAGTqP,EAAWrP,GAElC,OADAmI,GAA4B,IAArBoe,UAAU7qB,OAAc,8BACxBd,EAAUoF,GAAOpF,EAAUyU,oBAGZA,GACtB,OAAOzU,EAAUyU,GAAGzS,QAAQ,OAAQ,uBAGZyS,GACxB,OAAOzU,EAAUyU,GAAG9U,+BAGE6B,GACtB,OAAOxB,EAAUwB,GAAKioB,+BAGAhV,EAAWrP,GACjC,OAAOpF,EAAUyU,GAAGvQ,MAAMtE,OAAOwF,IAAMsF,KAAK,0BAGjB+J,EAAW5O,GACtC,OAAO7F,EAAUyU,GAAGzS,QAAQpC,OAAOiG,GAAI,qBAGjBrE,GACtB,OAAOxB,EAAUwB,GAAKQ,QAAQ,OAAQ,oBAGjByS,EAAWrP,GAChC,OAAOpF,EAAUyU,GAAGvQ,MAAMtE,OAAOwF,oBAGZqP,GACrB,OAAOzU,EAAUyU,GAAGoD,+BAGSpD,GAC7B,OAAOzU,EAAUyU,GAAGzS,QAAQ,MAAO,yBAGTR,GAE1B,OADAA,EAAMxB,EAAUwB,IACLuW,OAAO,GAAG0R,cAAgBjoB,EAAI+V,MAAM,GAAG5X,gCAG3B8U,EAAW0H,EAAiByP,GACnD,OAAO5rB,EAAUyU,GAAGvQ,MAAMtE,OAAOuc,IAAUzR,KAAKkhB,0BAGpBnX,EAAWoX,EAAcC,GACrD,OAAO9rB,EAAUyU,GAAGzS,QAAQpC,OAAOisB,GAAOC,sBAGlBrX,EAAW5O,EAAQkmB,GAE3C,oBAFmClmB,mBAAQkmB,UAC3CtX,EAAIzU,EAAUyU,IACR3T,QAAU+E,EAAU4O,EACnBA,EAAEyG,OAAO,EAAGrV,EAAIkmB,EAAEjrB,QAAUirB,0BAGNtX,EAAW5O,EAAQkmB,gBAARlmB,mBAAQkmB,SAChD,IAAMlrB,EAAM4T,EAAEvQ,MAAM,OAChB0L,EAAM/O,EAAI0W,MAAM,EAAG1R,GAAG6E,KAAK,KAE/B,OADI7J,EAAIC,QAAU+E,IAAG+J,GAAOmc,GACrBnc,SCvEPoc,iBAAA,SAAK3gB,GACH,IAAMkK,EAAOhT,KAAK0pB,MAAM5gB,GAExB,OADAkC,GAAOgI,EAAM,WAAM,MAAA,QAAQlK,kBACpBkK,GAGTyW,iBAAA,SAAK3gB,EAAckK,GACjBhT,KAAK0pB,MAAM5gB,GAAQkK,OAVvB,cACUhT,WAAyC,GCEnD,QAQE2pB,iBAAA,SAAK7gB,GACH,IAAMkK,EAAOhT,KAAK0pB,MAAM5gB,GAExB,OADAkC,GAAOgI,IAAShT,KAAKwG,cAAe,WAAM,MAAA,qBAAqBsC,IACxDkK,GAGT2W,iBAAA,SAAK7gB,EAAckK,GACjBhT,KAAK0pB,MAAM5gB,GAAQkK,GAGrB2W,oBAAA,SAAQ7gB,EAAcgN,GACpB,OAAO,IAAIC,GAAOjN,EAAM9I,KAAK2T,IAAI7K,GAAOgN,EAAM9V,KAAKoa,aAhBrD,YACmB5T,EACA4T,GADApa,mBAAAwG,EACAxG,YAAAoa,EAJXpa,WAA4C,WC6B7C4pB,mBAAP,SAAc1c,EAAc1L,GAC1B,OAAOxB,KAAKwc,OAAO3B,MAAM3N,EAAM1L,IAG1BooB,qBAAP,SAAgB1gB,EAAiBiB,EAAgBY,GAC/C,IAAM/H,EAAM,IAAIqG,GAAQc,EAAOnK,KAAKqL,QAASN,GAC7C,OAAO/K,KAAK2c,SAASlO,gBAAgBvF,EAAKlG,IAE/B4mB,oBAAb,SAAqB1gB,EAAiBiB,oEACpC,SAAO8D,GAAUjO,KAAK6pB,QAAQ3gB,EAAKiB,GAAO,UAErCyf,wBAAP,SAAmB1gB,EAAiBiB,GAClC,OAAOzM,GAAQsC,KAAK6pB,QAAQ3gB,EAAKiB,GAAO,KAEnCyf,gCAAP,SAA2B1gB,EAAiBiB,GAC1C,IAAMnH,EAAM,IAAIqG,GAAQc,EAAOnK,KAAKqL,SACpC,OAAOrL,KAAK2c,SAASmN,4BAA4B5gB,EAAKlG,IAGjD4mB,6BAAP,SAAwB1c,EAAc/C,EAAgBY,GACpD,IAAM7B,EAAMlJ,KAAK6a,MAAM3N,GACvB,OAAOlN,KAAK6pB,QAAQ3gB,EAAKiB,EAAOY,IAErB6e,4BAAb,SAA6B1c,EAAc/C,oEACzC,SAAO8D,GAAUjO,KAAK+pB,gBAAgB7c,EAAM/C,GAAO,UAE9Cyf,gCAAP,SAA2B1c,EAAc/C,GACvC,OAAOzM,GAAQsC,KAAK+pB,gBAAgB7c,EAAM/C,GAAO,KAG5Cyf,+BAAP,SAA0BrhB,EAAcwC,EAAgBK,GACtD,OAAOpL,KAAKwc,OAAOZ,UAAUrT,EAAMwC,EAAM3B,GAAW4gB,SAAU5e,IAEzDwe,8BAAP,SAAyBrhB,EAAcwC,EAAgBK,GACrD,OAAOpL,KAAKwc,OAAOZ,UAAUrT,EAAMwC,EAAM3B,GAAW6gB,QAAS7e,IAElDwe,uBAAb,SAAwBrhB,oEACtB,SAAO0F,GAAsBjO,KAAKwc,OAAOZ,UAAUrT,GAAM,UAEpDqhB,2BAAP,SAAsBrhB,GACpB,OAAO7K,GAAoBsC,KAAKwc,OAAOZ,UAAUrT,GAAM,KAE5CqhB,wBAAb,SAAyBrhB,EAAcvF,iGACnB,SAAMhD,KAAK4b,UAAUrT,WACvC,OADM+F,EAAY9F,YACXxI,KAAK6O,OAAOP,EAAWtL,UAEzB4mB,4BAAP,SAAuBrhB,EAAcvF,GACnC,IAAMsL,EAAYtO,KAAKkqB,cAAc3hB,GACrC,OAAOvI,KAAKmqB,WAAW7b,EAAWtL,IAEvB4mB,oCAAb,SAAqCrhB,EAAc4B,iGAC/B,SAAMnK,KAAK4b,UAAUrT,WACvC,OADM+F,EAAY9F,YACXxI,KAAKoqB,mBAAmB9b,EAAWnE,UAGrCyf,wBAAP,SAAmB3qB,EAAa+D,GAE9B,OADc,IAAIqX,GAAMpb,EAAKe,MAChBzC,MAAMyF,GAAK,IAEb4mB,uBAAb,SAAwB3qB,EAAa+D,oEACnC,SAAOiL,GAAUjO,KAAKgc,WAAW/c,EAAK+D,UAEjC4mB,2BAAP,SAAsB3qB,EAAa+D,GACjC,OAAOtF,GAAQsC,KAAKgc,WAAW/c,EAAK+D,KAG/B4mB,4BAAP,SAAuB9gB,EAAciO,GACnC/W,KAAK8W,QAAQuT,IAAIvhB,EAAMiO,IAElB6S,yBAAP,SAAoB9gB,EAAcwhB,GAChCtqB,KAAK2a,KAAK0P,IAAIvhB,EAAMwhB,IAEfV,oBAAP,SAAeW,GACb,OAAOA,EAAOxsB,KAAKiC,KAAM4pB,KAEpBA,qBAAP,WACE,IAAMY,EAAOxqB,KACTyqB,GAAY,EAEhB,OAAO,SAAqBC,EAAkB1nB,EAAa2nB,SACrDF,IACFA,GAAY,GACZjiB,EAAAgiB,EAAKnf,QAAQxK,MAAK+pB,kBAAW9jB,EAAuB9G,KAAKa,SAE3D2pB,EAAKK,WAAWH,EAAU1nB,GAAKsK,KAAK,SAAAJ,GAAQ,OAAAyd,EAAS,KAAMzd,IAAcyd,SA9F7E,YAAoBznB,GAApB,wBAAoBA,MAClBlD,KAAKqL,iBhFkIqBA,GAC5B,IAAMyf,OAAmBxlB,EAAmB+F,GAO5C,OANIyf,EAAYtlB,WAAaF,EAAeE,WAC1CslB,EAAYtlB,SAAWslB,EAAYjqB,MAEjCiqB,EAAYvlB,UAAYD,EAAeC,UACzCulB,EAAYvlB,QAAUulB,EAAYjqB,MAE7BiqB,EgF1IUC,UhF0GQ1f,GAWzB,IAVAA,EAAUA,GAAW,IACTjN,eAAe,UACzBiN,EAAQxK,KAAOiG,EAAuBuE,EAAQxK,OAE5CwK,EAAQjN,eAAe,cACzBiN,EAAQ7F,SAAWsB,EAAuBuE,EAAQ7F,WAEhD6F,EAAQjN,eAAe,aACzBiN,EAAQ9F,QAAUuB,EAAuBuE,EAAQ9F,UAE/C8F,EAAQjN,eAAe,SAAU,CACnC,IAAI8B,SACmCA,EAAV,iBAAlBmL,EAAQnL,MAA4C,EAAhBmL,EAAQnL,MAAY,IAAID,EAAIoL,EAAQnL,YAASwF,EAC1D,iBAAlB2F,EAAQnL,MAA4BmL,EAAQnL,MAC/CmL,EAAQnL,MAAQ,IAAID,EAAI,WAAQyF,EAC7C2F,EAAQnL,MAAQA,EAKlB,OAHImL,EAAQjN,eAAe,eACxBiN,EAA8BxE,cAAgBpC,EAAW4G,EAAQ3G,YAE7D2G,EgF/HuB2f,CAAU9nB,IACtClD,KAAKwc,OAAS,IAAIzB,GAAO/a,MACzBA,KAAK2c,SAAW,IAAItO,GACpBrO,KAAK8W,QAAU,IAAI6S,GAAU3pB,KAAKqL,QAAQ7E,cAAexG,MACzDA,KAAK2a,KAAO,IAAI8O,GAEhBzrB,EAAOitB,GAAa,SAACC,EAAsBpiB,GAAiB,OAAAD,EAAKsiB,YAAY3rB,EAAUsJ,GAAOoiB,KAC9FltB,EAAOotB,GAAgB,SAACnmB,EAA4B6D,GAAiB,OAAAD,EAAKwiB,eAAe7rB,EAAUsJ,GAAO7D"}