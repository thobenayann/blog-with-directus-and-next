"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const NULL_LENGTH = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF]);
const NText = {
  id: 0x63,
  type: 'NTEXT',
  name: 'NText',
  hasTableName: true,
  declaration: function () {
    return 'ntext';
  },
  resolveLength: function (parameter) {
    const value = parameter.value; // Temporary solution. Remove 'any' later.

    if (value != null) {
      return value.length;
    } else {
      return -1;
    }
  },

  generateTypeInfo(parameter, _options) {
    const buffer = Buffer.alloc(10);
    buffer.writeUInt8(this.id, 0);
    buffer.writeInt32LE(parameter.length, 1);

    if (parameter.collation) {
      parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
    }

    return buffer;
  },

  generateParameterLength(parameter, options) {
    if (parameter.value == null) {
      return NULL_LENGTH;
    }

    const buffer = Buffer.alloc(4);
    buffer.writeInt32LE(Buffer.byteLength(parameter.value, 'ucs2'), 0);
    return buffer;
  },

  generateParameterData: function* (parameter, options) {
    if (parameter.value == null) {
      return;
    }

    yield Buffer.from(parameter.value.toString(), 'ucs2');
  },
  validate: function (value) {
    if (value == null) {
      return null;
    }

    if (typeof value !== 'string') {
      if (typeof value.toString !== 'function') {
        throw new TypeError('Invalid string.');
      }

      emitTypeCoercionWarning();
      value = value.toString();
    }

    return value;
  }
};
var _default = NText;
exports.default = _default;
module.exports = NText;
let typeCoercionWarningEmitted = false;

function emitTypeCoercionWarning() {
  if (typeCoercionWarningEmitted) {
    return;
  }

  typeCoercionWarningEmitted = true;
  process.emitWarning('`ntext` type coercion from non-string type value via `.toString()` method is deprecated and will be removed.', 'DeprecationWarning', NText.validate);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kYXRhLXR5cGVzL250ZXh0LnRzIl0sIm5hbWVzIjpbIk5VTExfTEVOR1RIIiwiQnVmZmVyIiwiZnJvbSIsIk5UZXh0IiwiaWQiLCJ0eXBlIiwibmFtZSIsImhhc1RhYmxlTmFtZSIsImRlY2xhcmF0aW9uIiwicmVzb2x2ZUxlbmd0aCIsInBhcmFtZXRlciIsInZhbHVlIiwibGVuZ3RoIiwiZ2VuZXJhdGVUeXBlSW5mbyIsIl9vcHRpb25zIiwiYnVmZmVyIiwiYWxsb2MiLCJ3cml0ZVVJbnQ4Iiwid3JpdGVJbnQzMkxFIiwiY29sbGF0aW9uIiwidG9CdWZmZXIiLCJjb3B5IiwiZ2VuZXJhdGVQYXJhbWV0ZXJMZW5ndGgiLCJvcHRpb25zIiwiYnl0ZUxlbmd0aCIsImdlbmVyYXRlUGFyYW1ldGVyRGF0YSIsInRvU3RyaW5nIiwidmFsaWRhdGUiLCJUeXBlRXJyb3IiLCJlbWl0VHlwZUNvZXJjaW9uV2FybmluZyIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0eXBlQ29lcmNpb25XYXJuaW5nRW1pdHRlZCIsInByb2Nlc3MiLCJlbWl0V2FybmluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsTUFBTUEsV0FBVyxHQUFHQyxNQUFNLENBQUNDLElBQVAsQ0FBWSxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixDQUFaLENBQXBCO0FBRUEsTUFBTUMsS0FBZSxHQUFHO0FBQ3RCQyxFQUFBQSxFQUFFLEVBQUUsSUFEa0I7QUFFdEJDLEVBQUFBLElBQUksRUFBRSxPQUZnQjtBQUd0QkMsRUFBQUEsSUFBSSxFQUFFLE9BSGdCO0FBS3RCQyxFQUFBQSxZQUFZLEVBQUUsSUFMUTtBQU90QkMsRUFBQUEsV0FBVyxFQUFFLFlBQVc7QUFDdEIsV0FBTyxPQUFQO0FBQ0QsR0FUcUI7QUFXdEJDLEVBQUFBLGFBQWEsRUFBRSxVQUFTQyxTQUFULEVBQW9CO0FBQ2pDLFVBQU1DLEtBQUssR0FBR0QsU0FBUyxDQUFDQyxLQUF4QixDQURpQyxDQUNLOztBQUV0QyxRQUFJQSxLQUFLLElBQUksSUFBYixFQUFtQjtBQUNqQixhQUFPQSxLQUFLLENBQUNDLE1BQWI7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPLENBQUMsQ0FBUjtBQUNEO0FBQ0YsR0FuQnFCOztBQXFCdEJDLEVBQUFBLGdCQUFnQixDQUFDSCxTQUFELEVBQVlJLFFBQVosRUFBc0I7QUFDcEMsVUFBTUMsTUFBTSxHQUFHZCxNQUFNLENBQUNlLEtBQVAsQ0FBYSxFQUFiLENBQWY7QUFDQUQsSUFBQUEsTUFBTSxDQUFDRSxVQUFQLENBQWtCLEtBQUtiLEVBQXZCLEVBQTJCLENBQTNCO0FBQ0FXLElBQUFBLE1BQU0sQ0FBQ0csWUFBUCxDQUFvQlIsU0FBUyxDQUFDRSxNQUE5QixFQUF1QyxDQUF2Qzs7QUFFQSxRQUFJRixTQUFTLENBQUNTLFNBQWQsRUFBeUI7QUFDdkJULE1BQUFBLFNBQVMsQ0FBQ1MsU0FBVixDQUFvQkMsUUFBcEIsR0FBK0JDLElBQS9CLENBQW9DTixNQUFwQyxFQUE0QyxDQUE1QyxFQUErQyxDQUEvQyxFQUFrRCxDQUFsRDtBQUNEOztBQUVELFdBQU9BLE1BQVA7QUFDRCxHQS9CcUI7O0FBaUN0Qk8sRUFBQUEsdUJBQXVCLENBQUNaLFNBQUQsRUFBWWEsT0FBWixFQUFxQjtBQUMxQyxRQUFJYixTQUFTLENBQUNDLEtBQVYsSUFBbUIsSUFBdkIsRUFBNkI7QUFDM0IsYUFBT1gsV0FBUDtBQUNEOztBQUVELFVBQU1lLE1BQU0sR0FBR2QsTUFBTSxDQUFDZSxLQUFQLENBQWEsQ0FBYixDQUFmO0FBQ0FELElBQUFBLE1BQU0sQ0FBQ0csWUFBUCxDQUFvQmpCLE1BQU0sQ0FBQ3VCLFVBQVAsQ0FBa0JkLFNBQVMsQ0FBQ0MsS0FBNUIsRUFBbUMsTUFBbkMsQ0FBcEIsRUFBZ0UsQ0FBaEU7QUFDQSxXQUFPSSxNQUFQO0FBQ0QsR0F6Q3FCOztBQTJDdEJVLEVBQUFBLHFCQUFxQixFQUFFLFdBQVVmLFNBQVYsRUFBcUJhLE9BQXJCLEVBQThCO0FBQ25ELFFBQUliLFNBQVMsQ0FBQ0MsS0FBVixJQUFtQixJQUF2QixFQUE2QjtBQUMzQjtBQUNEOztBQUVELFVBQU1WLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZUSxTQUFTLENBQUNDLEtBQVYsQ0FBZ0JlLFFBQWhCLEVBQVosRUFBd0MsTUFBeEMsQ0FBTjtBQUNELEdBakRxQjtBQW1EdEJDLEVBQUFBLFFBQVEsRUFBRSxVQUFTaEIsS0FBVCxFQUErQjtBQUN2QyxRQUFJQSxLQUFLLElBQUksSUFBYixFQUFtQjtBQUNqQixhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsVUFBSSxPQUFPQSxLQUFLLENBQUNlLFFBQWIsS0FBMEIsVUFBOUIsRUFBMEM7QUFDeEMsY0FBTSxJQUFJRSxTQUFKLENBQWMsaUJBQWQsQ0FBTjtBQUNEOztBQUVEQyxNQUFBQSx1QkFBdUI7QUFDdkJsQixNQUFBQSxLQUFLLEdBQUdBLEtBQUssQ0FBQ2UsUUFBTixFQUFSO0FBQ0Q7O0FBRUQsV0FBT2YsS0FBUDtBQUNEO0FBbEVxQixDQUF4QjtlQXFFZVIsSzs7QUFDZjJCLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQjVCLEtBQWpCO0FBRUEsSUFBSTZCLDBCQUEwQixHQUFHLEtBQWpDOztBQUNBLFNBQVNILHVCQUFULEdBQW1DO0FBQ2pDLE1BQUlHLDBCQUFKLEVBQWdDO0FBQzlCO0FBQ0Q7O0FBRURBLEVBQUFBLDBCQUEwQixHQUFHLElBQTdCO0FBRUFDLEVBQUFBLE9BQU8sQ0FBQ0MsV0FBUixDQUNFLDhHQURGLEVBRUUsb0JBRkYsRUFHRS9CLEtBQUssQ0FBQ3dCLFFBSFI7QUFLRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vZGF0YS10eXBlJztcblxuY29uc3QgTlVMTF9MRU5HVEggPSBCdWZmZXIuZnJvbShbMHhGRiwgMHhGRiwgMHhGRiwgMHhGRl0pO1xuXG5jb25zdCBOVGV4dDogRGF0YVR5cGUgPSB7XG4gIGlkOiAweDYzLFxuICB0eXBlOiAnTlRFWFQnLFxuICBuYW1lOiAnTlRleHQnLFxuXG4gIGhhc1RhYmxlTmFtZTogdHJ1ZSxcblxuICBkZWNsYXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdudGV4dCc7XG4gIH0sXG5cbiAgcmVzb2x2ZUxlbmd0aDogZnVuY3Rpb24ocGFyYW1ldGVyKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJhbWV0ZXIudmFsdWUgYXMgYW55OyAvLyBUZW1wb3Jhcnkgc29sdXRpb24uIFJlbW92ZSAnYW55JyBsYXRlci5cblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LFxuXG4gIGdlbmVyYXRlVHlwZUluZm8ocGFyYW1ldGVyLCBfb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMCk7XG4gICAgYnVmZmVyLndyaXRlVUludDgodGhpcy5pZCwgMCk7XG4gICAgYnVmZmVyLndyaXRlSW50MzJMRShwYXJhbWV0ZXIubGVuZ3RoISwgMSk7XG5cbiAgICBpZiAocGFyYW1ldGVyLmNvbGxhdGlvbikge1xuICAgICAgcGFyYW1ldGVyLmNvbGxhdGlvbi50b0J1ZmZlcigpLmNvcHkoYnVmZmVyLCA1LCAwLCA1KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9LFxuXG4gIGdlbmVyYXRlUGFyYW1ldGVyTGVuZ3RoKHBhcmFtZXRlciwgb3B0aW9ucykge1xuICAgIGlmIChwYXJhbWV0ZXIudmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfTEVOR1RIO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICBidWZmZXIud3JpdGVJbnQzMkxFKEJ1ZmZlci5ieXRlTGVuZ3RoKHBhcmFtZXRlci52YWx1ZSwgJ3VjczInKSwgMCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSxcblxuICBnZW5lcmF0ZVBhcmFtZXRlckRhdGE6IGZ1bmN0aW9uKihwYXJhbWV0ZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAocGFyYW1ldGVyLnZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB5aWVsZCBCdWZmZXIuZnJvbShwYXJhbWV0ZXIudmFsdWUudG9TdHJpbmcoKSwgJ3VjczInKTtcbiAgfSxcblxuICB2YWxpZGF0ZTogZnVuY3Rpb24odmFsdWUpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdHJpbmcuJyk7XG4gICAgICB9XG5cbiAgICAgIGVtaXRUeXBlQ29lcmNpb25XYXJuaW5nKCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBOVGV4dDtcbm1vZHVsZS5leHBvcnRzID0gTlRleHQ7XG5cbmxldCB0eXBlQ29lcmNpb25XYXJuaW5nRW1pdHRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW1pdFR5cGVDb2VyY2lvbldhcm5pbmcoKSB7XG4gIGlmICh0eXBlQ29lcmNpb25XYXJuaW5nRW1pdHRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHR5cGVDb2VyY2lvbldhcm5pbmdFbWl0dGVkID0gdHJ1ZTtcblxuICBwcm9jZXNzLmVtaXRXYXJuaW5nKFxuICAgICdgbnRleHRgIHR5cGUgY29lcmNpb24gZnJvbSBub24tc3RyaW5nIHR5cGUgdmFsdWUgdmlhIGAudG9TdHJpbmcoKWAgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZC4nLFxuICAgICdEZXByZWNhdGlvbldhcm5pbmcnLFxuICAgIE5UZXh0LnZhbGlkYXRlXG4gICk7XG59XG4iXX0=