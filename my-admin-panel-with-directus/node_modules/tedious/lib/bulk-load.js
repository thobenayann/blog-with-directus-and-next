"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = require("events");

var _writableTrackingBuffer = _interopRequireDefault(require("./tracking-buffer/writable-tracking-buffer"));

var _stream = require("stream");

var _token = require("./token/token");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 */
const FLAGS = {
  nullable: 1 << 0,
  caseSen: 1 << 1,
  updateableReadWrite: 1 << 2,
  updateableUnknown: 1 << 3,
  identity: 1 << 4,
  computed: 1 << 5,
  // introduced in TDS 7.2
  fixedLenCLRType: 1 << 8,
  // introduced in TDS 7.2
  sparseColumnSet: 1 << 10,
  // introduced in TDS 7.3.B
  hidden: 1 << 13,
  // introduced in TDS 7.2
  key: 1 << 14,
  // introduced in TDS 7.2
  nullableUnknown: 1 << 15 // introduced in TDS 7.2

};
/**
 * @private
 */

const DONE_STATUS = {
  FINAL: 0x00,
  MORE: 0x1,
  ERROR: 0x2,
  INXACT: 0x4,
  COUNT: 0x10,
  ATTN: 0x20,
  SRVERROR: 0x100
};
/**
 * @private
 */

const rowTokenBuffer = Buffer.from([_token.TYPE.ROW]);
const textPointerAndTimestampBuffer = Buffer.from([// TextPointer length
0x10, // TextPointer
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Timestamp
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
const textPointerNullBuffer = Buffer.from([0x00]); // A transform that converts rows to packets.

class RowTransform extends _stream.Transform {
  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */
  constructor(bulkLoad) {
    super({
      writableObjectMode: true
    });
    this.columnMetadataWritten = void 0;
    this.bulkLoad = void 0;
    this.mainOptions = void 0;
    this.columns = void 0;
    this.bulkLoad = bulkLoad;
    this.mainOptions = bulkLoad.options;
    this.columns = bulkLoad.columns;
    this.columnMetadataWritten = false;
  }
  /**
   * @private
   */


  _transform(row, _encoding, callback) {
    if (!this.columnMetadataWritten) {
      this.push(this.bulkLoad.getColMetaData());
      this.columnMetadataWritten = true;
    }

    this.push(rowTokenBuffer);

    for (let i = 0; i < this.columns.length; i++) {
      const c = this.columns[i];
      let value = Array.isArray(row) ? row[i] : row[c.objName];

      if (!this.bulkLoad.firstRowWritten) {
        try {
          value = c.type.validate(value, c.collation);
        } catch (error) {
          return callback(error);
        }
      }

      const parameter = {
        length: c.length,
        scale: c.scale,
        precision: c.precision,
        value: value
      };

      if (c.type.name === 'Text' || c.type.name === 'Image' || c.type.name === 'NText') {
        if (value == null) {
          this.push(textPointerNullBuffer);
          continue;
        }

        this.push(textPointerAndTimestampBuffer);
      }

      this.push(c.type.generateParameterLength(parameter, this.mainOptions));

      for (const chunk of c.type.generateParameterData(parameter, this.mainOptions)) {
        this.push(chunk);
      }
    }

    process.nextTick(callback);
  }
  /**
   * @private
   */


  _flush(callback) {
    this.push(this.bulkLoad.createDoneToken());
    process.nextTick(callback);
  }

}
/**
 * A BulkLoad instance is used to perform a bulk insert.
 *
 * Use [[Connection.newBulkLoad]] to create a new instance, and [[Connection.execBulkLoad]] to execute it.
 *
 * Example of BulkLoad Usages:
 *
 * ```js
 * // optional BulkLoad options
 * const options = { keepNulls: true };
 *
 * // instantiate - provide the table where you'll be inserting to, options and a callback
 * const bulkLoad = connection.newBulkLoad('MyTable', options, (error, rowCount) => {
 *   console.log('inserted %d rows', rowCount);
 * });
 *
 * // setup your columns - always indicate whether the column is nullable
 * bulkLoad.addColumn('myInt', TYPES.Int, { nullable: false });
 * bulkLoad.addColumn('myString', TYPES.NVarChar, { length: 50, nullable: true });
 *
 * // execute
 * connection.execBulkLoad(bulkLoad, [
 *   { myInt: 7, myString: 'hello' },
 *   { myInt: 23, myString: 'world' }
 * ]);
 * ```
 */


class BulkLoad extends _events.EventEmitter {
  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */
  constructor(table, collation, connectionOptions, {
    checkConstraints = false,
    fireTriggers = false,
    keepNulls = false,
    lockTable = false,
    order = {}
  }, callback) {
    if (typeof checkConstraints !== 'boolean') {
      throw new TypeError('The "options.checkConstraints" property must be of type boolean.');
    }

    if (typeof fireTriggers !== 'boolean') {
      throw new TypeError('The "options.fireTriggers" property must be of type boolean.');
    }

    if (typeof keepNulls !== 'boolean') {
      throw new TypeError('The "options.keepNulls" property must be of type boolean.');
    }

    if (typeof lockTable !== 'boolean') {
      throw new TypeError('The "options.lockTable" property must be of type boolean.');
    }

    if (typeof order !== 'object' || order === null) {
      throw new TypeError('The "options.order" property must be of type object.');
    }

    for (const [column, direction] of Object.entries(order)) {
      if (direction !== 'ASC' && direction !== 'DESC') {
        throw new TypeError('The value of the "' + column + '" key in the "options.order" object must be either "ASC" or "DESC".');
      }
    }

    super();
    this.error = void 0;
    this.canceled = void 0;
    this.executionStarted = void 0;
    this.streamingMode = void 0;
    this.table = void 0;
    this.timeout = void 0;
    this.options = void 0;
    this.callback = void 0;
    this.columns = void 0;
    this.columnsByName = void 0;
    this.firstRowWritten = void 0;
    this.rowToPacketTransform = void 0;
    this.bulkOptions = void 0;
    this.connection = void 0;
    this.rows = void 0;
    this.rst = void 0;
    this.rowCount = void 0;
    this.collation = void 0;
    this.error = undefined;
    this.canceled = false;
    this.executionStarted = false;
    this.collation = collation;
    this.table = table;
    this.options = connectionOptions;
    this.callback = callback;
    this.columns = [];
    this.columnsByName = {};
    this.firstRowWritten = false;
    this.streamingMode = false;
    this.rowToPacketTransform = new RowTransform(this); // eslint-disable-line no-use-before-define

    this.bulkOptions = {
      checkConstraints,
      fireTriggers,
      keepNulls,
      lockTable,
      order
    };
  }
  /**
   * Adds a column to the bulk load.
   *
   * The column definitions should match the table you are trying to insert into.
   * Attempting to call addColumn after the first row has been added will throw an exception.
   *
   * ```js
   * bulkLoad.addColumn('MyIntColumn', TYPES.Int, { nullable: false });
   * ```
   *
   * @param name The name of the column.
   * @param type One of the supported `data types`.
   * @param __namedParameters Additional column type information. At a minimum, `nullable` must be set to true or false.
   * @param length For VarChar, NVarChar, VarBinary. Use length as `Infinity` for VarChar(max), NVarChar(max) and VarBinary(max).
   * @param nullable Indicates whether the column accepts NULL values.
   * @param objName If the name of the column is different from the name of the property found on `rowObj` arguments passed to [[addRow]] or [[Connection.execBulkLoad]], then you can use this option to specify the property name.
   * @param precision For Numeric, Decimal.
   * @param scale For Numeric, Decimal, Time, DateTime2, DateTimeOffset.
  */


  addColumn(name, type, {
    output = false,
    length,
    precision,
    scale,
    objName = name,
    nullable = true
  }) {
    if (this.firstRowWritten) {
      throw new Error('Columns cannot be added to bulk insert after the first row has been written.');
    }

    if (this.executionStarted) {
      throw new Error('Columns cannot be added to bulk insert after execution has started.');
    }

    const column = {
      type: type,
      name: name,
      value: null,
      output: output,
      length: length,
      precision: precision,
      scale: scale,
      objName: objName,
      nullable: nullable,
      collation: this.collation
    };

    if ((type.id & 0x30) === 0x20) {
      if (column.length == null && type.resolveLength) {
        column.length = type.resolveLength(column);
      }
    }

    if (type.resolvePrecision && column.precision == null) {
      column.precision = type.resolvePrecision(column);
    }

    if (type.resolveScale && column.scale == null) {
      column.scale = type.resolveScale(column);
    }

    this.columns.push(column);
    this.columnsByName[name] = column;
  }
  /**
   * Adds a row to the bulk insert.
   *
   * ```js
   * bulkLoad.addRow({ first_name: 'Bill', last_name: 'Gates' });
   * ```
   *
   * @param row An object of key/value pairs representing column name (or objName) and value.
   *
   * @deprecated This method is deprecated. Instead of adding rows individually, you should pass
   *   all row objects when calling [[Connection.execBulkLoad]]. This method will be removed in the future.
   */


  addRow(...input) {
    emitAddRowDeprecationWarning();
    this.firstRowWritten = true;
    let row;

    if (input.length > 1 || !input[0] || typeof input[0] !== 'object') {
      row = input;
    } else {
      row = input[0];
    } // write each column


    if (Array.isArray(row)) {
      this.rowToPacketTransform.write(this.columns.map((column, i) => {
        return column.type.validate(row[i], column.collation);
      }));
    } else {
      this.rowToPacketTransform.write(this.columns.map(column => {
        return column.type.validate(row[column.objName], column.collation);
      }));
    }
  }
  /**
   * @private
   */


  getOptionsSql() {
    const addOptions = [];

    if (this.bulkOptions.checkConstraints) {
      addOptions.push('CHECK_CONSTRAINTS');
    }

    if (this.bulkOptions.fireTriggers) {
      addOptions.push('FIRE_TRIGGERS');
    }

    if (this.bulkOptions.keepNulls) {
      addOptions.push('KEEP_NULLS');
    }

    if (this.bulkOptions.lockTable) {
      addOptions.push('TABLOCK');
    }

    if (this.bulkOptions.order) {
      const orderColumns = [];

      for (const [column, direction] of Object.entries(this.bulkOptions.order)) {
        orderColumns.push(`${column} ${direction}`);
      }

      if (orderColumns.length) {
        addOptions.push(`ORDER (${orderColumns.join(', ')})`);
      }
    }

    if (addOptions.length > 0) {
      return ` WITH (${addOptions.join(',')})`;
    } else {
      return '';
    }
  }
  /**
   * @private
   */


  getBulkInsertSql() {
    let sql = 'insert bulk ' + this.table + '(';

    for (let i = 0, len = this.columns.length; i < len; i++) {
      const c = this.columns[i];

      if (i !== 0) {
        sql += ', ';
      }

      sql += '[' + c.name + '] ' + c.type.declaration(c);
    }

    sql += ')';
    sql += this.getOptionsSql();
    return sql;
  }
  /**
   * This is simply a helper utility function which returns a `CREATE TABLE SQL` statement based on the columns added to the bulkLoad object.
   * This may be particularly handy when you want to insert into a temporary table (a table which starts with `#`).
   *
   * ```js
   * var sql = bulkLoad.getTableCreationSql();
   * ```
   *
   * A side note on bulk inserting into temporary tables: if you want to access a local temporary table after executing the bulk load,
   * you'll need to use the same connection and execute your requests using [[Connection.execSqlBatch]] instead of [[Connection.execSql]]
   */


  getTableCreationSql() {
    let sql = 'CREATE TABLE ' + this.table + '(\n';

    for (let i = 0, len = this.columns.length; i < len; i++) {
      const c = this.columns[i];

      if (i !== 0) {
        sql += ',\n';
      }

      sql += '[' + c.name + '] ' + c.type.declaration(c);

      if (c.nullable !== undefined) {
        sql += ' ' + (c.nullable ? 'NULL' : 'NOT NULL');
      }
    }

    sql += '\n)';
    return sql;
  }
  /**
   * @private
   */


  getColMetaData() {
    const tBuf = new _writableTrackingBuffer.default(100, null, true); // TokenType

    tBuf.writeUInt8(_token.TYPE.COLMETADATA); // Count

    tBuf.writeUInt16LE(this.columns.length);

    for (let j = 0, len = this.columns.length; j < len; j++) {
      const c = this.columns[j]; // UserType

      if (this.options.tdsVersion < '7_2') {
        tBuf.writeUInt16LE(0);
      } else {
        tBuf.writeUInt32LE(0);
      } // Flags


      let flags = FLAGS.updateableReadWrite;

      if (c.nullable) {
        flags |= FLAGS.nullable;
      } else if (c.nullable === undefined && this.options.tdsVersion >= '7_2') {
        flags |= FLAGS.nullableUnknown;
      }

      tBuf.writeUInt16LE(flags); // TYPE_INFO

      tBuf.writeBuffer(c.type.generateTypeInfo(c, this.options)); // TableName

      if (c.type.hasTableName) {
        tBuf.writeUsVarchar(this.table, 'ucs2');
      } // ColName


      tBuf.writeBVarchar(c.name, 'ucs2');
    }

    return tBuf.data;
  }
  /**
   * Sets a timeout for this bulk load.
   *
   * ```js
   * bulkLoad.setTimeout(timeout);
   * ```
   *
   * @param timeout The number of milliseconds before the bulk load is considered failed, or 0 for no timeout.
   *   When no timeout is set for the bulk load, the [[ConnectionOptions.requestTimeout]] of the Connection is used.
   */


  setTimeout(timeout) {
    this.timeout = timeout;
  }
  /**
   * @private
   */


  createDoneToken() {
    // It might be nice to make DoneToken a class if anything needs to create them, but for now, just do it here
    const tBuf = new _writableTrackingBuffer.default(this.options.tdsVersion < '7_2' ? 9 : 13);
    tBuf.writeUInt8(_token.TYPE.DONE);
    const status = DONE_STATUS.FINAL;
    tBuf.writeUInt16LE(status);
    tBuf.writeUInt16LE(0); // CurCmd (TDS ignores this)

    tBuf.writeUInt32LE(0); // row count - doesn't really matter

    if (this.options.tdsVersion >= '7_2') {
      tBuf.writeUInt32LE(0); // row count is 64 bits in >= TDS 7.2
    }

    return tBuf.data;
  }
  /**
   * Switches the `BulkLoad` object into streaming mode and returns a
   * [writable stream](https://nodejs.org/dist/latest-v10.x/docs/api/stream.html#stream_writable_streams)
   * that can be used to send a large amount of rows to the server.
   *
   * ```js
   * const bulkLoad = connection.newBulkLoad(...);
   * bulkLoad.addColumn(...);
   *
   * const rowStream = bulkLoad.getRowStream();
   *
   * connection.execBulkLoad(bulkLoad);
   * ```
   *
   * In streaming mode, [[addRow]] cannot be used. Instead all data rows must be written to the returned stream object.
   * The stream implementation uses data flow control to prevent memory overload. [`stream.write()`](https://nodejs.org/dist/latest-v10.x/docs/api/stream.html#stream_writable_write_chunk_encoding_callback)
   * returns `false` to indicate that data transfer should be paused.
   *
   * After that, the stream emits a ['drain' event](https://nodejs.org/dist/latest-v10.x/docs/api/stream.html#stream_event_drain)
   * when it is ready to resume data transfer.
   *
   * @deprecated
   *   This method is deprecated. Instead of writing rows to the stream returned by this method,
   *   you can pass any object that implements the `Iterable` or `AsyncIterable` interface (e.g. a `Readable`
   *   stream or an `AsyncGenerator`) when calling [[Connection.execBulkLoad]]. This method will be removed in the future.
   */


  getRowStream() {
    emitGetRowStreamDeprecationWarning();

    if (this.firstRowWritten) {
      throw new Error('BulkLoad cannot be switched to streaming mode after first row has been written using addRow().');
    }

    if (this.executionStarted) {
      throw new Error('BulkLoad cannot be switched to streaming mode after execution has started.');
    }

    this.streamingMode = true;
    return this.rowToPacketTransform;
  }
  /**
   * @private
   */


  cancel() {
    if (this.canceled) {
      return;
    }

    this.canceled = true;
    this.emit('cancel');
  }

}

let addRowDeprecationWarningEmitted = false;

function emitAddRowDeprecationWarning() {
  if (addRowDeprecationWarningEmitted) {
    return;
  }

  addRowDeprecationWarningEmitted = true;
  process.emitWarning('The BulkLoad.addRow method is deprecated. Please provide the row data for ' + 'the bulk load as the second argument to Connection.execBulkLoad instead.', 'DeprecationWarning', BulkLoad.prototype.addRow);
}

let getRowStreamDeprecationWarningEmitted = false;

function emitGetRowStreamDeprecationWarning() {
  if (getRowStreamDeprecationWarningEmitted) {
    return;
  }

  getRowStreamDeprecationWarningEmitted = true;
  process.emitWarning('The BulkLoad.getRowStream method is deprecated. You can pass an Iterable, AsyncIterable or ' + 'stream.Readable object containing the row data as a second argument to Connection.execBulkLoad instead.', 'DeprecationWarning', BulkLoad.prototype.getRowStream);
}

var _default = BulkLoad;
exports.default = _default;
module.exports = BulkLoad;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9idWxrLWxvYWQudHMiXSwibmFtZXMiOlsiRkxBR1MiLCJudWxsYWJsZSIsImNhc2VTZW4iLCJ1cGRhdGVhYmxlUmVhZFdyaXRlIiwidXBkYXRlYWJsZVVua25vd24iLCJpZGVudGl0eSIsImNvbXB1dGVkIiwiZml4ZWRMZW5DTFJUeXBlIiwic3BhcnNlQ29sdW1uU2V0IiwiaGlkZGVuIiwia2V5IiwibnVsbGFibGVVbmtub3duIiwiRE9ORV9TVEFUVVMiLCJGSU5BTCIsIk1PUkUiLCJFUlJPUiIsIklOWEFDVCIsIkNPVU5UIiwiQVRUTiIsIlNSVkVSUk9SIiwicm93VG9rZW5CdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiVE9LRU5fVFlQRSIsIlJPVyIsInRleHRQb2ludGVyQW5kVGltZXN0YW1wQnVmZmVyIiwidGV4dFBvaW50ZXJOdWxsQnVmZmVyIiwiUm93VHJhbnNmb3JtIiwiVHJhbnNmb3JtIiwiY29uc3RydWN0b3IiLCJidWxrTG9hZCIsIndyaXRhYmxlT2JqZWN0TW9kZSIsImNvbHVtbk1ldGFkYXRhV3JpdHRlbiIsIm1haW5PcHRpb25zIiwiY29sdW1ucyIsIm9wdGlvbnMiLCJfdHJhbnNmb3JtIiwicm93IiwiX2VuY29kaW5nIiwiY2FsbGJhY2siLCJwdXNoIiwiZ2V0Q29sTWV0YURhdGEiLCJpIiwibGVuZ3RoIiwiYyIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5Iiwib2JqTmFtZSIsImZpcnN0Um93V3JpdHRlbiIsInR5cGUiLCJ2YWxpZGF0ZSIsImNvbGxhdGlvbiIsImVycm9yIiwicGFyYW1ldGVyIiwic2NhbGUiLCJwcmVjaXNpb24iLCJuYW1lIiwiZ2VuZXJhdGVQYXJhbWV0ZXJMZW5ndGgiLCJjaHVuayIsImdlbmVyYXRlUGFyYW1ldGVyRGF0YSIsInByb2Nlc3MiLCJuZXh0VGljayIsIl9mbHVzaCIsImNyZWF0ZURvbmVUb2tlbiIsIkJ1bGtMb2FkIiwiRXZlbnRFbWl0dGVyIiwidGFibGUiLCJjb25uZWN0aW9uT3B0aW9ucyIsImNoZWNrQ29uc3RyYWludHMiLCJmaXJlVHJpZ2dlcnMiLCJrZWVwTnVsbHMiLCJsb2NrVGFibGUiLCJvcmRlciIsIlR5cGVFcnJvciIsImNvbHVtbiIsImRpcmVjdGlvbiIsIk9iamVjdCIsImVudHJpZXMiLCJjYW5jZWxlZCIsImV4ZWN1dGlvblN0YXJ0ZWQiLCJzdHJlYW1pbmdNb2RlIiwidGltZW91dCIsImNvbHVtbnNCeU5hbWUiLCJyb3dUb1BhY2tldFRyYW5zZm9ybSIsImJ1bGtPcHRpb25zIiwiY29ubmVjdGlvbiIsInJvd3MiLCJyc3QiLCJyb3dDb3VudCIsInVuZGVmaW5lZCIsImFkZENvbHVtbiIsIm91dHB1dCIsIkVycm9yIiwiaWQiLCJyZXNvbHZlTGVuZ3RoIiwicmVzb2x2ZVByZWNpc2lvbiIsInJlc29sdmVTY2FsZSIsImFkZFJvdyIsImlucHV0IiwiZW1pdEFkZFJvd0RlcHJlY2F0aW9uV2FybmluZyIsIndyaXRlIiwibWFwIiwiZ2V0T3B0aW9uc1NxbCIsImFkZE9wdGlvbnMiLCJvcmRlckNvbHVtbnMiLCJqb2luIiwiZ2V0QnVsa0luc2VydFNxbCIsInNxbCIsImxlbiIsImRlY2xhcmF0aW9uIiwiZ2V0VGFibGVDcmVhdGlvblNxbCIsInRCdWYiLCJXcml0YWJsZVRyYWNraW5nQnVmZmVyIiwid3JpdGVVSW50OCIsIkNPTE1FVEFEQVRBIiwid3JpdGVVSW50MTZMRSIsImoiLCJ0ZHNWZXJzaW9uIiwid3JpdGVVSW50MzJMRSIsImZsYWdzIiwid3JpdGVCdWZmZXIiLCJnZW5lcmF0ZVR5cGVJbmZvIiwiaGFzVGFibGVOYW1lIiwid3JpdGVVc1ZhcmNoYXIiLCJ3cml0ZUJWYXJjaGFyIiwiZGF0YSIsInNldFRpbWVvdXQiLCJET05FIiwic3RhdHVzIiwiZ2V0Um93U3RyZWFtIiwiZW1pdEdldFJvd1N0cmVhbURlcHJlY2F0aW9uV2FybmluZyIsImNhbmNlbCIsImVtaXQiLCJhZGRSb3dEZXByZWNhdGlvbldhcm5pbmdFbWl0dGVkIiwiZW1pdFdhcm5pbmciLCJwcm90b3R5cGUiLCJnZXRSb3dTdHJlYW1EZXByZWNhdGlvbldhcm5pbmdFbWl0dGVkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUdBOztBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsS0FBSyxHQUFHO0FBQ1pDLEVBQUFBLFFBQVEsRUFBRSxLQUFLLENBREg7QUFFWkMsRUFBQUEsT0FBTyxFQUFFLEtBQUssQ0FGRjtBQUdaQyxFQUFBQSxtQkFBbUIsRUFBRSxLQUFLLENBSGQ7QUFJWkMsRUFBQUEsaUJBQWlCLEVBQUUsS0FBSyxDQUpaO0FBS1pDLEVBQUFBLFFBQVEsRUFBRSxLQUFLLENBTEg7QUFNWkMsRUFBQUEsUUFBUSxFQUFFLEtBQUssQ0FOSDtBQU1NO0FBQ2xCQyxFQUFBQSxlQUFlLEVBQUUsS0FBSyxDQVBWO0FBT2E7QUFDekJDLEVBQUFBLGVBQWUsRUFBRSxLQUFLLEVBUlY7QUFRYztBQUMxQkMsRUFBQUEsTUFBTSxFQUFFLEtBQUssRUFURDtBQVNLO0FBQ2pCQyxFQUFBQSxHQUFHLEVBQUUsS0FBSyxFQVZFO0FBVUU7QUFDZEMsRUFBQUEsZUFBZSxFQUFFLEtBQUssRUFYVixDQVdhOztBQVhiLENBQWQ7QUFjQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTUMsV0FBVyxHQUFHO0FBQ2xCQyxFQUFBQSxLQUFLLEVBQUUsSUFEVztBQUVsQkMsRUFBQUEsSUFBSSxFQUFFLEdBRlk7QUFHbEJDLEVBQUFBLEtBQUssRUFBRSxHQUhXO0FBSWxCQyxFQUFBQSxNQUFNLEVBQUUsR0FKVTtBQUtsQkMsRUFBQUEsS0FBSyxFQUFFLElBTFc7QUFNbEJDLEVBQUFBLElBQUksRUFBRSxJQU5ZO0FBT2xCQyxFQUFBQSxRQUFRLEVBQUU7QUFQUSxDQUFwQjtBQVVBO0FBQ0E7QUFDQTs7QUFpRkEsTUFBTUMsY0FBYyxHQUFHQyxNQUFNLENBQUNDLElBQVAsQ0FBWSxDQUFFQyxZQUFXQyxHQUFiLENBQVosQ0FBdkI7QUFDQSxNQUFNQyw2QkFBNkIsR0FBR0osTUFB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QUNBLDBFQUZGLEVBR0Usb0JBSEYsRUFJRXRFLFFBQVEsQ0FBQ3VFLFNBQVQsQ0FBbUJ0QyxNQUpyQjtBQU1EOztBQUVELElBQUl1QyxxQ0FBcUMsR0FBRyxLQUE1Qzs7QUFDQSxTQUFTTixrQ0FBVCxHQUE4QztBQUM1QyxNQUFJTSxxQ0FBSixFQUEyQztBQUN6QztBQUNEOztBQUVEQSxFQUFBQSxxQ0FBcUMsR0FBRyxJQUF4QztBQUVBNUUsRUFBQUEsT0FBTyxDQUFDMEUsV0FBUixDQUNFLGdHQUNBLHlHQUZGLEVBR0Usb0JBSEYsRUFJRXRFLFFBQVEsQ0FBQ3VFLFNBQVQsQ0FBbUJOLFlBSnJCO0FBTUQ7O2VBRWNqRSxROztBQUNmeUUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCMUUsUUFBakIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IFdyaXRhYmxlVHJhY2tpbmdCdWZmZXIgZnJvbSAnLi90cmFja2luZy1idWZmZXIvd3JpdGFibGUtdHJhY2tpbmctYnVmZmVyJztcbmltcG9ydCBDb25uZWN0aW9uLCB7IEludGVybmFsQ29ubmVjdGlvbk9wdGlvbnMgfSBmcm9tICcuL2Nvbm5lY3Rpb24nO1xuXG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHsgVFlQRSBhcyBUT0tFTl9UWVBFIH0gZnJvbSAnLi90b2tlbi90b2tlbic7XG5cbmltcG9ydCB7IERhdGFUeXBlLCBQYXJhbWV0ZXIgfSBmcm9tICcuL2RhdGEtdHlwZSc7XG5pbXBvcnQgeyBDb2xsYXRpb24gfSBmcm9tICcuL2NvbGxhdGlvbic7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgRkxBR1MgPSB7XG4gIG51bGxhYmxlOiAxIDw8IDAsXG4gIGNhc2VTZW46IDEgPDwgMSxcbiAgdXBkYXRlYWJsZVJlYWRXcml0ZTogMSA8PCAyLFxuICB1cGRhdGVhYmxlVW5rbm93bjogMSA8PCAzLFxuICBpZGVudGl0eTogMSA8PCA0LFxuICBjb21wdXRlZDogMSA8PCA1LCAvLyBpbnRyb2R1Y2VkIGluIFREUyA3LjJcbiAgZml4ZWRMZW5DTFJUeXBlOiAxIDw8IDgsIC8vIGludHJvZHVjZWQgaW4gVERTIDcuMlxuICBzcGFyc2VDb2x1bW5TZXQ6IDEgPDwgMTAsIC8vIGludHJvZHVjZWQgaW4gVERTIDcuMy5CXG4gIGhpZGRlbjogMSA8PCAxMywgLy8gaW50cm9kdWNlZCBpbiBURFMgNy4yXG4gIGtleTogMSA8PCAxNCwgLy8gaW50cm9kdWNlZCBpbiBURFMgNy4yXG4gIG51bGxhYmxlVW5rbm93bjogMSA8PCAxNSAvLyBpbnRyb2R1Y2VkIGluIFREUyA3LjJcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgRE9ORV9TVEFUVVMgPSB7XG4gIEZJTkFMOiAweDAwLFxuICBNT1JFOiAweDEsXG4gIEVSUk9SOiAweDIsXG4gIElOWEFDVDogMHg0LFxuICBDT1VOVDogMHgxMCxcbiAgQVRUTjogMHgyMCxcbiAgU1JWRVJST1I6IDB4MTAwXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmludGVyZmFjZSBJbnRlcm5hbE9wdGlvbnMge1xuICBjaGVja0NvbnN0cmFpbnRzOiBib29sZWFuO1xuICBmaXJlVHJpZ2dlcnM6IGJvb2xlYW47XG4gIGtlZXBOdWxsczogYm9vbGVhbjtcbiAgbG9ja1RhYmxlOiBib29sZWFuO1xuICBvcmRlcjogeyBbY29sdW1uTmFtZTogc3RyaW5nXTogJ0FTQycgfCAnREVTQycgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zIHtcbiAgLyoqXG4gICAqIEhvbm9ycyBjb25zdHJhaW50cyBkdXJpbmcgYnVsayBsb2FkLCB1c2luZyBULVNRTFxuICAgKiBbQ0hFQ0tfQ09OU1RSQUlOVFNdKGh0dHBzOi8vdGVjaG5ldC5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXMxODYyNDcodj1zcWwuMTA1KS5hc3B4KS5cbiAgICogKGRlZmF1bHQ6IGBmYWxzZWApXG4gICAqL1xuICBjaGVja0NvbnN0cmFpbnRzPzogSW50ZXJuYWxPcHRpb25zWydjaGVja0NvbnN0cmFpbnRzJ10gfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEhvbm9ycyBpbnNlcnQgdHJpZ2dlcnMgZHVyaW5nIGJ1bGsgbG9hZCwgdXNpbmcgdGhlIFQtU1FMIFtGSVJFX1RSSUdHRVJTXShodHRwczovL3RlY2huZXQubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTg3NjQwKHY9c3FsLjEwNSkuYXNweCkuIChkZWZhdWx0OiBgZmFsc2VgKVxuICAgKi9cbiAgZmlyZVRyaWdnZXJzPzogSW50ZXJuYWxPcHRpb25zWydmaXJlVHJpZ2dlcnMnXSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogSG9ub3JzIG51bGwgdmFsdWUgcGFzc2VkLCBpZ25vcmVzIHRoZSBkZWZhdWx0IHZhbHVlcyBzZXQgb24gdGFibGUsIHVzaW5nIFQtU1FMIFtLRUVQX05VTExTXShodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTg3ODg3KHY9c3FsLjEyMCkuYXNweCkuIChkZWZhdWx0OiBgZmFsc2VgKVxuICAgKi9cbiAga2VlcE51bGxzPzogSW50ZXJuYWxPcHRpb25zWydrZWVwTnVsbHMnXSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogUGxhY2VzIGEgYnVsayB1cGRhdGUoQlUpIGxvY2sgb24gdGFibGUgd2hpbGUgcGVyZm9ybWluZyBidWxrIGxvYWQsIHVzaW5nIFQtU1FMIFtUQUJMT0NLXShodHRwczovL3RlY2huZXQubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTgwODc2KHY9c3FsLjEwNSkuYXNweCkuIChkZWZhdWx0OiBgZmFsc2VgKVxuICAgKi9cbiAgbG9ja1RhYmxlPzogSW50ZXJuYWxPcHRpb25zWydsb2NrVGFibGUnXSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBvcmRlcmluZyBvZiB0aGUgZGF0YSB0byBwb3NzaWJseSBpbmNyZWFzZSBidWxrIGluc2VydCBwZXJmb3JtYW5jZSwgdXNpbmcgVC1TUUwgW09SREVSXShodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9wcmV2aW91cy12ZXJzaW9ucy9zcWwvc3FsLXNlcnZlci0yMDA4LXIyL21zMTc3NDY4KHY9c3FsLjEwNSkpLiAoZGVmYXVsdDogYHt9YClcbiAgICovXG4gIG9yZGVyPzogSW50ZXJuYWxPcHRpb25zWydvcmRlciddIHwgdW5kZWZpbmVkO1xufVxuXG5cbmV4cG9ydCB0eXBlIENhbGxiYWNrID1cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIFtbQnVsa0xvYWRdXSBmaW5pc2hlcyBleGVjdXRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSByb3dDb3VudCB0aGUgbnVtYmVyIG9mIHJvd3MgaW5zZXJ0ZWRcbiAgICovXG4gIChlcnI6IEVycm9yIHwgdW5kZWZpbmVkIHwgbnVsbCwgcm93Q291bnQ/OiBudW1iZXIpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb2x1bW4gZXh0ZW5kcyBQYXJhbWV0ZXIge1xuICBvYmpOYW1lOiBzdHJpbmc7XG4gIGNvbGxhdGlvbjogQ29sbGF0aW9uIHwgdW5kZWZpbmVkO1xufVxuXG5pbnRlcmZhY2UgQ29sdW1uT3B0aW9ucyB7XG4gIG91dHB1dD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEZvciBWYXJDaGFyLCBOVmFyQ2hhciwgVmFyQmluYXJ5LiBVc2UgbGVuZ3RoIGFzIGBJbmZpbml0eWAgZm9yIFZhckNoYXIobWF4KSwgTlZhckNoYXIobWF4KSBhbmQgVmFyQmluYXJ5KG1heCkuXG4gICAqL1xuICBsZW5ndGg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEZvciBOdW1lcmljLCBEZWNpbWFsLlxuICAgKi9cbiAgcHJlY2lzaW9uPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBGb3IgTnVtZXJpYywgRGVjaW1hbCwgVGltZSwgRGF0ZVRpbWUyLCBEYXRlVGltZU9mZnNldC5cbiAgICovXG4gIHNjYWxlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgbmFtZSBvZiB0aGUgY29sdW1uIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBmb3VuZCBvbiBgcm93T2JqYCBhcmd1bWVudHMgcGFzc2VkIHRvIFtbYWRkUm93XV0sIHRoZW4geW91IGNhbiB1c2UgdGhpcyBvcHRpb24gdG8gc3BlY2lmeSB0aGUgcHJvcGVydHkgbmFtZS5cbiAgICovXG4gIG9iak5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjb2x1bW4gYWNjZXB0cyBOVUxMIHZhbHVlcy5cbiAgICovXG4gIG51bGxhYmxlPzogYm9vbGVhbjtcbn1cblxuY29uc3Qgcm93VG9rZW5CdWZmZXIgPSBCdWZmZXIuZnJvbShbIFRPS0VOX1RZUEUuUk9XIF0pO1xuY29uc3QgdGV4dFBvaW50ZXJBbmRUaW1lc3RhbXBCdWZmZXIgPSBCdWZmZXIuZnJvbShbXG4gIC8vIFRleHRQb2ludGVyIGxlbmd0aFxuICAweDEwLFxuXG4gIC8vIFRleHRQb2ludGVyXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG5cbiAgLy8gVGltZXN0YW1wXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBcbl0pO1xuY29uc3QgdGV4dFBvaW50ZXJOdWxsQnVmZmVyID0gQnVmZmVyLmZyb20oWzB4MDBdKTtcblxuLy8gQSB0cmFuc2Zvcm0gdGhhdCBjb252ZXJ0cyByb3dzIHRvIHBhY2tldHMuXG5jbGFzcyBSb3dUcmFuc2Zvcm0gZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbHVtbk1ldGFkYXRhV3JpdHRlbjogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBidWxrTG9hZDogQnVsa0xvYWQ7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbWFpbk9wdGlvbnM6IEJ1bGtMb2FkWydvcHRpb25zJ107XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29sdW1uczogQnVsa0xvYWRbJ2NvbHVtbnMnXTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGJ1bGtMb2FkOiBCdWxrTG9hZCkge1xuICAgIHN1cGVyKHsgd3JpdGFibGVPYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gICAgdGhpcy5idWxrTG9hZCA9IGJ1bGtMb2FkO1xuICAgIHRoaXMubWFpbk9wdGlvbnMgPSBidWxrTG9hZC5vcHRpb25zO1xuICAgIHRoaXMuY29sdW1ucyA9IGJ1bGtMb2FkLmNvbHVtbnM7XG5cbiAgICB0aGlzLmNvbHVtbk1ldGFkYXRhV3JpdHRlbiA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJhbnNmb3JtKHJvdzogQXJyYXk8dW5rbm93bj4gfCB7IFtjb2xOYW1lOiBzdHJpbmddOiB1bmtub3duIH0sIF9lbmNvZGluZzogc3RyaW5nLCBjYWxsYmFjazogKGVycm9yPzogRXJyb3IpID0+IHZvaWQpIHtcbiAgICBpZiAoIXRoaXMuY29sdW1uTWV0YWRhdGFXcml0dGVuKSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5idWxrTG9hZC5nZXRDb2xNZXRhRGF0YSgpKTtcbiAgICAgIHRoaXMuY29sdW1uTWV0YWRhdGFXcml0dGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnB1c2gocm93VG9rZW5CdWZmZXIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmNvbHVtbnNbaV07XG4gICAgICBsZXQgdmFsdWUgPSBBcnJheS5pc0FycmF5KHJvdykgPyByb3dbaV0gOiByb3dbYy5vYmpOYW1lXTtcblxuICAgICAgaWYgKCF0aGlzLmJ1bGtMb2FkLmZpcnN0Um93V3JpdHRlbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gYy50eXBlLnZhbGlkYXRlKHZhbHVlLCBjLmNvbGxhdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmFtZXRlciA9IHtcbiAgICAgICAgbGVuZ3RoOiBjLmxlbmd0aCxcbiAgICAgICAgc2NhbGU6IGMuc2NhbGUsXG4gICAgICAgIHByZWNpc2lvbjogYy5wcmVjaXNpb24sXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcblxuICAgICAgaWYgKGMudHlwZS5uYW1lID09PSAnVGV4dCcgfHwgYy50eXBlLm5hbWUgPT09ICdJbWFnZScgfHwgYy50eXBlLm5hbWUgPT09ICdOVGV4dCcpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnB1c2godGV4dFBvaW50ZXJOdWxsQnVmZmVyKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHVzaCh0ZXh0UG9pbnRlckFuZFRpbWVzdGFtcEJ1ZmZlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaChjLnR5cGUuZ2VuZXJhdGVQYXJhbWV0ZXJMZW5ndGgocGFyYW1ldGVyLCB0aGlzLm1haW5PcHRpb25zKSk7XG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGMudHlwZS5nZW5lcmF0ZVBhcmFtZXRlckRhdGEocGFyYW1ldGVyLCB0aGlzLm1haW5PcHRpb25zKSkge1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZmx1c2goY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLnB1c2godGhpcy5idWxrTG9hZC5jcmVhdGVEb25lVG9rZW4oKSk7XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgQnVsa0xvYWQgaW5zdGFuY2UgaXMgdXNlZCB0byBwZXJmb3JtIGEgYnVsayBpbnNlcnQuXG4gKlxuICogVXNlIFtbQ29ubmVjdGlvbi5uZXdCdWxrTG9hZF1dIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSwgYW5kIFtbQ29ubmVjdGlvbi5leGVjQnVsa0xvYWRdXSB0byBleGVjdXRlIGl0LlxuICpcbiAqIEV4YW1wbGUgb2YgQnVsa0xvYWQgVXNhZ2VzOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBvcHRpb25hbCBCdWxrTG9hZCBvcHRpb25zXG4gKiBjb25zdCBvcHRpb25zID0geyBrZWVwTnVsbHM6IHRydWUgfTtcbiAqXG4gKiAvLyBpbnN0YW50aWF0ZSAtIHByb3ZpZGUgdGhlIHRhYmxlIHdoZXJlIHlvdSdsbCBiZSBpbnNlcnRpbmcgdG8sIG9wdGlvbnMgYW5kIGEgY2FsbGJhY2tcbiAqIGNvbnN0IGJ1bGtMb2FkID0gY29ubmVjdGlvbi5uZXdCdWxrTG9hZCgnTXlUYWJsZScsIG9wdGlvbnMsIChlcnJvciwgcm93Q291bnQpID0+IHtcbiAqICAgY29uc29sZS5sb2coJ2luc2VydGVkICVkIHJvd3MnLCByb3dDb3VudCk7XG4gKiB9KTtcbiAqXG4gKiAvLyBzZXR1cCB5b3VyIGNvbHVtbnMgLSBhbHdheXMgaW5kaWNhdGUgd2hldGhlciB0aGUgY29sdW1uIGlzIG51bGxhYmxlXG4gKiBidWxrTG9hZC5hZGRDb2x1bW4oJ215SW50JywgVFlQRVMuSW50LCB7IG51bGxhYmxlOiBmYWxzZSB9KTtcbiAqIGJ1bGtMb2FkLmFkZENvbHVtbignbXlTdHJpbmcnLCBUWVBFUy5OVmFyQ2hhciwgeyBsZW5ndGg6IDUwLCBudWxsYWJsZTogdHJ1ZSB9KTtcbiAqXG4gKiAvLyBleGVjdXRlXG4gKiBjb25uZWN0aW9uLmV4ZWNCdWxrTG9hZChidWxrTG9hZCwgW1xuICogICB7IG15SW50OiA3LCBteVN0cmluZzogJ2hlbGxvJyB9LFxuICogICB7IG15SW50OiAyMywgbXlTdHJpbmc6ICd3b3JsZCcgfVxuICogXSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgQnVsa0xvYWQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVycm9yOiBFcnJvciB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxlZDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleGVjdXRpb25TdGFydGVkOiBib29sZWFuO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0cmVhbWluZ01vZGU6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGFibGU6IHN0cmluZztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aW1lb3V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvcHRpb25zOiBJbnRlcm5hbENvbm5lY3Rpb25PcHRpb25zO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGxiYWNrOiBDYWxsYmFjaztcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbHVtbnM6IEFycmF5PENvbHVtbj47XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29sdW1uc0J5TmFtZTogeyBbbmFtZTogc3RyaW5nXTogQ29sdW1uIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmaXJzdFJvd1dyaXR0ZW46IGJvb2xlYW47XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcm93VG9QYWNrZXRUcmFuc2Zvcm06IFJvd1RyYW5zZm9ybTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJ1bGtPcHRpb25zOiBJbnRlcm5hbE9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25uZWN0aW9uOiBDb25uZWN0aW9uIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJvd3M6IEFycmF5PGFueT4gfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcnN0OiBBcnJheTxhbnk+IHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJvd0NvdW50OiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgY29sbGF0aW9uOiBDb2xsYXRpb24gfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YWJsZTogc3RyaW5nLCBjb2xsYXRpb246IENvbGxhdGlvbiB8IHVuZGVmaW5lZCwgY29ubmVjdGlvbk9wdGlvbnM6IEludGVybmFsQ29ubmVjdGlvbk9wdGlvbnMsIHtcbiAgICBjaGVja0NvbnN0cmFpbnRzID0gZmFsc2UsXG4gICAgZmlyZVRyaWdnZXJzID0gZmFsc2UsXG4gICAga2VlcE51bGxzID0gZmFsc2UsXG4gICAgbG9ja1RhYmxlID0gZmFsc2UsXG4gICAgb3JkZXIgPSB7fSxcbiAgfTogT3B0aW9ucywgY2FsbGJhY2s6IENhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjaGVja0NvbnN0cmFpbnRzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9wdGlvbnMuY2hlY2tDb25zdHJhaW50c1wiIHByb3BlcnR5IG11c3QgYmUgb2YgdHlwZSBib29sZWFuLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmlyZVRyaWdnZXJzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9wdGlvbnMuZmlyZVRyaWdnZXJzXCIgcHJvcGVydHkgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW4uJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBrZWVwTnVsbHMgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3B0aW9ucy5rZWVwTnVsbHNcIiBwcm9wZXJ0eSBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbi4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxvY2tUYWJsZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcHRpb25zLmxvY2tUYWJsZVwiIHByb3BlcnR5IG11c3QgYmUgb2YgdHlwZSBib29sZWFuLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3JkZXIgIT09ICdvYmplY3QnIHx8IG9yZGVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcHRpb25zLm9yZGVyXCIgcHJvcGVydHkgbXVzdCBiZSBvZiB0eXBlIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtjb2x1bW4sIGRpcmVjdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMob3JkZXIpKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uICE9PSAnQVNDJyAmJiBkaXJlY3Rpb24gIT09ICdERVNDJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgb2YgdGhlIFwiJyArIGNvbHVtbiArICdcIiBrZXkgaW4gdGhlIFwib3B0aW9ucy5vcmRlclwiIG9iamVjdCBtdXN0IGJlIGVpdGhlciBcIkFTQ1wiIG9yIFwiREVTQ1wiLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV4ZWN1dGlvblN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuY29sbGF0aW9uID0gY29sbGF0aW9uO1xuXG4gICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbm5lY3Rpb25PcHRpb25zO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmNvbHVtbnMgPSBbXTtcbiAgICB0aGlzLmNvbHVtbnNCeU5hbWUgPSB7fTtcbiAgICB0aGlzLmZpcnN0Um93V3JpdHRlbiA9IGZhbHNlO1xuICAgIHRoaXMuc3RyZWFtaW5nTW9kZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5yb3dUb1BhY2tldFRyYW5zZm9ybSA9IG5ldyBSb3dUcmFuc2Zvcm0odGhpcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcblxuICAgIHRoaXMuYnVsa09wdGlvbnMgPSB7IGNoZWNrQ29uc3RyYWludHMsIGZpcmVUcmlnZ2Vycywga2VlcE51bGxzLCBsb2NrVGFibGUsIG9yZGVyIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNvbHVtbiB0byB0aGUgYnVsayBsb2FkLlxuICAgKlxuICAgKiBUaGUgY29sdW1uIGRlZmluaXRpb25zIHNob3VsZCBtYXRjaCB0aGUgdGFibGUgeW91IGFyZSB0cnlpbmcgdG8gaW5zZXJ0IGludG8uXG4gICAqIEF0dGVtcHRpbmcgdG8gY2FsbCBhZGRDb2x1bW4gYWZ0ZXIgdGhlIGZpcnN0IHJvdyBoYXMgYmVlbiBhZGRlZCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICpcbiAgICogYGBganNcbiAgICogYnVsa0xvYWQuYWRkQ29sdW1uKCdNeUludENvbHVtbicsIFRZUEVTLkludCwgeyBudWxsYWJsZTogZmFsc2UgfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29sdW1uLlxuICAgKiBAcGFyYW0gdHlwZSBPbmUgb2YgdGhlIHN1cHBvcnRlZCBgZGF0YSB0eXBlc2AuXG4gICAqIEBwYXJhbSBfX25hbWVkUGFyYW1ldGVycyBBZGRpdGlvbmFsIGNvbHVtbiB0eXBlIGluZm9ybWF0aW9uLiBBdCBhIG1pbmltdW0sIGBudWxsYWJsZWAgbXVzdCBiZSBzZXQgdG8gdHJ1ZSBvciBmYWxzZS5cbiAgICogQHBhcmFtIGxlbmd0aCBGb3IgVmFyQ2hhciwgTlZhckNoYXIsIFZhckJpbmFyeS4gVXNlIGxlbmd0aCBhcyBgSW5maW5pdHlgIGZvciBWYXJDaGFyKG1heCksIE5WYXJDaGFyKG1heCkgYW5kIFZhckJpbmFyeShtYXgpLlxuICAgKiBAcGFyYW0gbnVsbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbHVtbiBhY2NlcHRzIE5VTEwgdmFsdWVzLlxuICAgKiBAcGFyYW0gb2JqTmFtZSBJZiB0aGUgbmFtZSBvZiB0aGUgY29sdW1uIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBmb3VuZCBvbiBgcm93T2JqYCBhcmd1bWVudHMgcGFzc2VkIHRvIFtbYWRkUm93XV0gb3IgW1tDb25uZWN0aW9uLmV4ZWNCdWxrTG9hZF1dLCB0aGVuIHlvdSBjYW4gdXNlIHRoaXMgb3B0aW9uIHRvIHNwZWNpZnkgdGhlIHByb3BlcnR5IG5hbWUuXG4gICAqIEBwYXJhbSBwcmVjaXNpb24gRm9yIE51bWVyaWMsIERlY2ltYWwuXG4gICAqIEBwYXJhbSBzY2FsZSBGb3IgTnVtZXJpYywgRGVjaW1hbCwgVGltZSwgRGF0ZVRpbWUyLCBEYXRlVGltZU9mZnNldC5cbiAgKi9cbiAgYWRkQ29sdW1uKG5hbWU6IHN0cmluZywgdHlwZTogRGF0YVR5cGUsIHsgb3V0cHV0ID0gZmFsc2UsIGxlbmd0aCwgcHJlY2lzaW9uLCBzY2FsZSwgb2JqTmFtZSA9IG5hbWUsIG51bGxhYmxlID0gdHJ1ZSB9OiBDb2x1bW5PcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuZmlyc3RSb3dXcml0dGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbHVtbnMgY2Fubm90IGJlIGFkZGVkIHRvIGJ1bGsgaW5zZXJ0IGFmdGVyIHRoZSBmaXJzdCByb3cgaGFzIGJlZW4gd3JpdHRlbi4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uU3RhcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2x1bW5zIGNhbm5vdCBiZSBhZGRlZCB0byBidWxrIGluc2VydCBhZnRlciBleGVjdXRpb24gaGFzIHN0YXJ0ZWQuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29sdW1uOiBDb2x1bW4gPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgb2JqTmFtZTogb2JqTmFtZSxcbiAgICAgIG51bGxhYmxlOiBudWxsYWJsZSxcbiAgICAgIGNvbGxhdGlvbjogdGhpcy5jb2xsYXRpb25cbiAgICB9O1xuXG4gICAgaWYgKCh0eXBlLmlkICYgMHgzMCkgPT09IDB4MjApIHtcbiAgICAgIGlmIChjb2x1bW4ubGVuZ3RoID09IG51bGwgJiYgdHlwZS5yZXNvbHZlTGVuZ3RoKSB7XG4gICAgICAgIGNvbHVtbi5sZW5ndGggPSB0eXBlLnJlc29sdmVMZW5ndGgoY29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlUHJlY2lzaW9uICYmIGNvbHVtbi5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgY29sdW1uLnByZWNpc2lvbiA9IHR5cGUucmVzb2x2ZVByZWNpc2lvbihjb2x1bW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnJlc29sdmVTY2FsZSAmJiBjb2x1bW4uc2NhbGUgPT0gbnVsbCkge1xuICAgICAgY29sdW1uLnNjYWxlID0gdHlwZS5yZXNvbHZlU2NhbGUoY29sdW1uKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbHVtbnMucHVzaChjb2x1bW4pO1xuXG4gICAgdGhpcy5jb2x1bW5zQnlOYW1lW25hbWVdID0gY29sdW1uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSByb3cgdG8gdGhlIGJ1bGsgaW5zZXJ0LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBidWxrTG9hZC5hZGRSb3coeyBmaXJzdF9uYW1lOiAnQmlsbCcsIGxhc3RfbmFtZTogJ0dhdGVzJyB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSByb3cgQW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyByZXByZXNlbnRpbmcgY29sdW1uIG5hbWUgKG9yIG9iak5hbWUpIGFuZCB2YWx1ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBvZiBhZGRpbmcgcm93cyBpbmRpdmlkdWFsbHksIHlvdSBzaG91bGQgcGFzc1xuICAgKiAgIGFsbCByb3cgb2JqZWN0cyB3aGVuIGNhbGxpbmcgW1tDb25uZWN0aW9uLmV4ZWNCdWxrTG9hZF1dLiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICovXG4gIGFkZFJvdyhyb3c6IHsgW2NvbHVtbk5hbWU6IHN0cmluZ106IHVua25vd24gfSk6IHZvaWRcblxuICAvKipcbiAgICogQWRkcyBhIHJvdyB0byB0aGUgYnVsayBpbnNlcnQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGJ1bGtMb2FkLmFkZFJvdygnQmlsbCcsICdHYXRlcycpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHJvdyBJZiB0aGVyZSBhcmUgYXQgbGVhc3QgdHdvIGNvbHVtbnMsIHZhbHVlcyBjYW4gYmUgcGFzc2VkIGFzIG11bHRpcGxlIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGFuIGFycmF5LiBUaGV5XG4gICAqICAgbXVzdCBiZSBpbiB0aGUgc2FtZSBvcmRlciB0aGUgY29sdW1ucyB3ZXJlIGFkZGVkIGluLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIG9mIGFkZGluZyByb3dzIGluZGl2aWR1YWxseSwgeW91IHNob3VsZCBwYXNzXG4gICAqICAgYWxsIHJvdyBvYmplY3RzIHdoZW4gY2FsbGluZyBbW0Nvbm5lY3Rpb24uZXhlY0J1bGtMb2FkXV0uIFRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAgKi9cbiAgYWRkUm93KC4uLnJvdzogdW5rbm93bltdKTogdm9pZFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcm93IHRvIHRoZSBidWxrIGluc2VydC5cbiAgICpcbiAgICogYGBganNcbiAgICogYnVsa0xvYWQuYWRkUm93KFsnQmlsbCcsICdHYXRlcyddKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSByb3cgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZXMgb2YgZWFjaCBjb2x1bW4gaW4gdGhlIHNhbWUgb3JkZXIgd2hpY2ggdGhleSB3ZXJlIGFkZGVkIHRvIHRoZSBidWxrTG9hZCBvYmplY3QuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgb2YgYWRkaW5nIHJvd3MgaW5kaXZpZHVhbGx5LCB5b3Ugc2hvdWxkIHBhc3NcbiAgICogICBhbGwgcm93IG9iamVjdHMgd2hlbiBjYWxsaW5nIFtbQ29ubmVjdGlvbi5leGVjQnVsa0xvYWRdXS4gVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAqL1xuICBhZGRSb3cocm93OiB1bmtub3duW10pOiB2b2lkXG5cbiAgYWRkUm93KC4uLmlucHV0OiBbIHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9IF0gfCB1bmtub3duW10pIHtcbiAgICBlbWl0QWRkUm93RGVwcmVjYXRpb25XYXJuaW5nKCk7XG5cbiAgICB0aGlzLmZpcnN0Um93V3JpdHRlbiA9IHRydWU7XG5cbiAgICBsZXQgcm93OiBhbnk7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+IDEgfHwgIWlucHV0WzBdIHx8IHR5cGVvZiBpbnB1dFswXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJvdyA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByb3cgPSBpbnB1dFswXTtcbiAgICB9XG5cbiAgICAvLyB3cml0ZSBlYWNoIGNvbHVtblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJvdykpIHtcbiAgICAgIHRoaXMucm93VG9QYWNrZXRUcmFuc2Zvcm0ud3JpdGUodGhpcy5jb2x1bW5zLm1hcCgoY29sdW1uLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2x1bW4udHlwZS52YWxpZGF0ZShyb3dbaV0sIGNvbHVtbi5jb2xsYXRpb24pO1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvd1RvUGFja2V0VHJhbnNmb3JtLndyaXRlKHRoaXMuY29sdW1ucy5tYXAoKGNvbHVtbikgPT4ge1xuICAgICAgICByZXR1cm4gY29sdW1uLnR5cGUudmFsaWRhdGUocm93W2NvbHVtbi5vYmpOYW1lXSwgY29sdW1uLmNvbGxhdGlvbik7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRPcHRpb25zU3FsKCkge1xuICAgIGNvbnN0IGFkZE9wdGlvbnMgPSBbXTtcblxuICAgIGlmICh0aGlzLmJ1bGtPcHRpb25zLmNoZWNrQ29uc3RyYWludHMpIHtcbiAgICAgIGFkZE9wdGlvbnMucHVzaCgnQ0hFQ0tfQ09OU1RSQUlOVFMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5idWxrT3B0aW9ucy5maXJlVHJpZ2dlcnMpIHtcbiAgICAgIGFkZE9wdGlvbnMucHVzaCgnRklSRV9UUklHR0VSUycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJ1bGtPcHRpb25zLmtlZXBOdWxscykge1xuICAgICAgYWRkT3B0aW9ucy5wdXNoKCdLRUVQX05VTExTJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYnVsa09wdGlvbnMubG9ja1RhYmxlKSB7XG4gICAgICBhZGRPcHRpb25zLnB1c2goJ1RBQkxPQ0snKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5idWxrT3B0aW9ucy5vcmRlcikge1xuICAgICAgY29uc3Qgb3JkZXJDb2x1bW5zID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgW2NvbHVtbiwgZGlyZWN0aW9uXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmJ1bGtPcHRpb25zLm9yZGVyKSkge1xuICAgICAgICBvcmRlckNvbHVtbnMucHVzaChgJHtjb2x1bW59ICR7ZGlyZWN0aW9ufWApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3JkZXJDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBhZGRPcHRpb25zLnB1c2goYE9SREVSICgke29yZGVyQ29sdW1ucy5qb2luKCcsICcpfSlgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWRkT3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gYCBXSVRIICgke2FkZE9wdGlvbnMuam9pbignLCcpfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCdWxrSW5zZXJ0U3FsKCkge1xuICAgIGxldCBzcWwgPSAnaW5zZXJ0IGJ1bGsgJyArIHRoaXMudGFibGUgKyAnKCc7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuY29sdW1ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuY29sdW1uc1tpXTtcbiAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgIHNxbCArPSAnLCAnO1xuICAgICAgfVxuICAgICAgc3FsICs9ICdbJyArIGMubmFtZSArICddICcgKyAoYy50eXBlLmRlY2xhcmF0aW9uKGMpKTtcbiAgICB9XG4gICAgc3FsICs9ICcpJztcblxuICAgIHNxbCArPSB0aGlzLmdldE9wdGlvbnNTcWwoKTtcbiAgICByZXR1cm4gc3FsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgc2ltcGx5IGEgaGVscGVyIHV0aWxpdHkgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIGBDUkVBVEUgVEFCTEUgU1FMYCBzdGF0ZW1lbnQgYmFzZWQgb24gdGhlIGNvbHVtbnMgYWRkZWQgdG8gdGhlIGJ1bGtMb2FkIG9iamVjdC5cbiAgICogVGhpcyBtYXkgYmUgcGFydGljdWxhcmx5IGhhbmR5IHdoZW4geW91IHdhbnQgdG8gaW5zZXJ0IGludG8gYSB0ZW1wb3JhcnkgdGFibGUgKGEgdGFibGUgd2hpY2ggc3RhcnRzIHdpdGggYCNgKS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIHNxbCA9IGJ1bGtMb2FkLmdldFRhYmxlQ3JlYXRpb25TcWwoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEEgc2lkZSBub3RlIG9uIGJ1bGsgaW5zZXJ0aW5nIGludG8gdGVtcG9yYXJ5IHRhYmxlczogaWYgeW91IHdhbnQgdG8gYWNjZXNzIGEgbG9jYWwgdGVtcG9yYXJ5IHRhYmxlIGFmdGVyIGV4ZWN1dGluZyB0aGUgYnVsayBsb2FkLFxuICAgKiB5b3UnbGwgbmVlZCB0byB1c2UgdGhlIHNhbWUgY29ubmVjdGlvbiBhbmQgZXhlY3V0ZSB5b3VyIHJlcXVlc3RzIHVzaW5nIFtbQ29ubmVjdGlvbi5leGVjU3FsQmF0Y2hdXSBpbnN0ZWFkIG9mIFtbQ29ubmVjdGlvbi5leGVjU3FsXV1cbiAgICovXG4gIGdldFRhYmxlQ3JlYXRpb25TcWwoKSB7XG4gICAgbGV0IHNxbCA9ICdDUkVBVEUgVEFCTEUgJyArIHRoaXMudGFibGUgKyAnKFxcbic7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuY29sdW1ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuY29sdW1uc1tpXTtcbiAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgIHNxbCArPSAnLFxcbic7XG4gICAgICB9XG4gICAgICBzcWwgKz0gJ1snICsgYy5uYW1lICsgJ10gJyArIChjLnR5cGUuZGVjbGFyYXRpb24oYykpO1xuICAgICAgaWYgKGMubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzcWwgKz0gJyAnICsgKGMubnVsbGFibGUgPyAnTlVMTCcgOiAnTk9UIE5VTEwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3FsICs9ICdcXG4pJztcbiAgICByZXR1cm4gc3FsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRDb2xNZXRhRGF0YSgpIHtcbiAgICBjb25zdCB0QnVmID0gbmV3IFdyaXRhYmxlVHJhY2tpbmdCdWZmZXIoMTAwLCBudWxsLCB0cnVlKTtcbiAgICAvLyBUb2tlblR5cGVcbiAgICB0QnVmLndyaXRlVUludDgoVE9LRU5fVFlQRS5DT0xNRVRBREFUQSk7XG4gICAgLy8gQ291bnRcbiAgICB0QnVmLndyaXRlVUludDE2TEUodGhpcy5jb2x1bW5zLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBqID0gMCwgbGVuID0gdGhpcy5jb2x1bW5zLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5jb2x1bW5zW2pdO1xuICAgICAgLy8gVXNlclR5cGVcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGRzVmVyc2lvbiA8ICc3XzInKSB7XG4gICAgICAgIHRCdWYud3JpdGVVSW50MTZMRSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRCdWYud3JpdGVVSW50MzJMRSgwKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmxhZ3NcbiAgICAgIGxldCBmbGFncyA9IEZMQUdTLnVwZGF0ZWFibGVSZWFkV3JpdGU7XG4gICAgICBpZiAoYy5udWxsYWJsZSkge1xuICAgICAgICBmbGFncyB8PSBGTEFHUy5udWxsYWJsZTtcbiAgICAgIH0gZWxzZSBpZiAoYy5udWxsYWJsZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy50ZHNWZXJzaW9uID49ICc3XzInKSB7XG4gICAgICAgIGZsYWdzIHw9IEZMQUdTLm51bGxhYmxlVW5rbm93bjtcbiAgICAgIH1cbiAgICAgIHRCdWYud3JpdGVVSW50MTZMRShmbGFncyk7XG5cbiAgICAgIC8vIFRZUEVfSU5GT1xuICAgICAgdEJ1Zi53cml0ZUJ1ZmZlcihjLnR5cGUuZ2VuZXJhdGVUeXBlSW5mbyhjLCB0aGlzLm9wdGlvbnMpKTtcblxuICAgICAgLy8gVGFibGVOYW1lXG4gICAgICBpZiAoYy50eXBlLmhhc1RhYmxlTmFtZSkge1xuICAgICAgICB0QnVmLndyaXRlVXNWYXJjaGFyKHRoaXMudGFibGUsICd1Y3MyJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbE5hbWVcbiAgICAgIHRCdWYud3JpdGVCVmFyY2hhcihjLm5hbWUsICd1Y3MyJyk7XG4gICAgfVxuICAgIHJldHVybiB0QnVmLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIHRpbWVvdXQgZm9yIHRoaXMgYnVsayBsb2FkLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBidWxrTG9hZC5zZXRUaW1lb3V0KHRpbWVvdXQpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHRpbWVvdXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBidWxrIGxvYWQgaXMgY29uc2lkZXJlZCBmYWlsZWQsIG9yIDAgZm9yIG5vIHRpbWVvdXQuXG4gICAqICAgV2hlbiBubyB0aW1lb3V0IGlzIHNldCBmb3IgdGhlIGJ1bGsgbG9hZCwgdGhlIFtbQ29ubmVjdGlvbk9wdGlvbnMucmVxdWVzdFRpbWVvdXRdXSBvZiB0aGUgQ29ubmVjdGlvbiBpcyB1c2VkLlxuICAgKi9cbiAgc2V0VGltZW91dCh0aW1lb3V0PzogbnVtYmVyKSB7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlRG9uZVRva2VuKCkge1xuICAgIC8vIEl0IG1pZ2h0IGJlIG5pY2UgdG8gbWFrZSBEb25lVG9rZW4gYSBjbGFzcyBpZiBhbnl0aGluZyBuZWVkcyB0byBjcmVhdGUgdGhlbSwgYnV0IGZvciBub3csIGp1c3QgZG8gaXQgaGVyZVxuICAgIGNvbnN0IHRCdWYgPSBuZXcgV3JpdGFibGVUcmFja2luZ0J1ZmZlcih0aGlzLm9wdGlvbnMudGRzVmVyc2lvbiA8ICc3XzInID8gOSA6IDEzKTtcbiAgICB0QnVmLndyaXRlVUludDgoVE9LRU5fVFlQRS5ET05FKTtcbiAgICBjb25zdCBzdGF0dXMgPSBET05FX1NUQVRVUy5GSU5BTDtcbiAgICB0QnVmLndyaXRlVUludDE2TEUoc3RhdHVzKTtcbiAgICB0QnVmLndyaXRlVUludDE2TEUoMCk7IC8vIEN1ckNtZCAoVERTIGlnbm9yZXMgdGhpcylcbiAgICB0QnVmLndyaXRlVUludDMyTEUoMCk7IC8vIHJvdyBjb3VudCAtIGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgIGlmICh0aGlzLm9wdGlvbnMudGRzVmVyc2lvbiA+PSAnN18yJykge1xuICAgICAgdEJ1Zi53cml0ZVVJbnQzMkxFKDApOyAvLyByb3cgY291bnQgaXMgNjQgYml0cyBpbiA+PSBURFMgNy4yXG4gICAgfVxuICAgIHJldHVybiB0QnVmLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogU3dpdGNoZXMgdGhlIGBCdWxrTG9hZGAgb2JqZWN0IGludG8gc3RyZWFtaW5nIG1vZGUgYW5kIHJldHVybnMgYVxuICAgKiBbd3JpdGFibGUgc3RyZWFtXShodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjEwLngvZG9jcy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3dyaXRhYmxlX3N0cmVhbXMpXG4gICAqIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2VuZCBhIGxhcmdlIGFtb3VudCBvZiByb3dzIHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGJ1bGtMb2FkID0gY29ubmVjdGlvbi5uZXdCdWxrTG9hZCguLi4pO1xuICAgKiBidWxrTG9hZC5hZGRDb2x1bW4oLi4uKTtcbiAgICpcbiAgICogY29uc3Qgcm93U3RyZWFtID0gYnVsa0xvYWQuZ2V0Um93U3RyZWFtKCk7XG4gICAqXG4gICAqIGNvbm5lY3Rpb24uZXhlY0J1bGtMb2FkKGJ1bGtMb2FkKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEluIHN0cmVhbWluZyBtb2RlLCBbW2FkZFJvd11dIGNhbm5vdCBiZSB1c2VkLiBJbnN0ZWFkIGFsbCBkYXRhIHJvd3MgbXVzdCBiZSB3cml0dGVuIHRvIHRoZSByZXR1cm5lZCBzdHJlYW0gb2JqZWN0LlxuICAgKiBUaGUgc3RyZWFtIGltcGxlbWVudGF0aW9uIHVzZXMgZGF0YSBmbG93IGNvbnRyb2wgdG8gcHJldmVudCBtZW1vcnkgb3ZlcmxvYWQuIFtgc3RyZWFtLndyaXRlKClgXShodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjEwLngvZG9jcy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3dyaXRhYmxlX3dyaXRlX2NodW5rX2VuY29kaW5nX2NhbGxiYWNrKVxuICAgKiByZXR1cm5zIGBmYWxzZWAgdG8gaW5kaWNhdGUgdGhhdCBkYXRhIHRyYW5zZmVyIHNob3VsZCBiZSBwYXVzZWQuXG4gICAqXG4gICAqIEFmdGVyIHRoYXQsIHRoZSBzdHJlYW0gZW1pdHMgYSBbJ2RyYWluJyBldmVudF0oaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYxMC54L2RvY3MvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9ldmVudF9kcmFpbilcbiAgICogd2hlbiBpdCBpcyByZWFkeSB0byByZXN1bWUgZGF0YSB0cmFuc2Zlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogICBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIG9mIHdyaXRpbmcgcm93cyB0byB0aGUgc3RyZWFtIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLFxuICAgKiAgIHlvdSBjYW4gcGFzcyBhbnkgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgYEl0ZXJhYmxlYCBvciBgQXN5bmNJdGVyYWJsZWAgaW50ZXJmYWNlIChlLmcuIGEgYFJlYWRhYmxlYFxuICAgKiAgIHN0cmVhbSBvciBhbiBgQXN5bmNHZW5lcmF0b3JgKSB3aGVuIGNhbGxpbmcgW1tDb25uZWN0aW9uLmV4ZWNCdWxrTG9hZF1dLiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICovXG4gIGdldFJvd1N0cmVhbSgpIHtcbiAgICBlbWl0R2V0Um93U3RyZWFtRGVwcmVjYXRpb25XYXJuaW5nKCk7XG5cbiAgICBpZiAodGhpcy5maXJzdFJvd1dyaXR0ZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnVsa0xvYWQgY2Fubm90IGJlIHN3aXRjaGVkIHRvIHN0cmVhbWluZyBtb2RlIGFmdGVyIGZpcnN0IHJvdyBoYXMgYmVlbiB3cml0dGVuIHVzaW5nIGFkZFJvdygpLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5leGVjdXRpb25TdGFydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1bGtMb2FkIGNhbm5vdCBiZSBzd2l0Y2hlZCB0byBzdHJlYW1pbmcgbW9kZSBhZnRlciBleGVjdXRpb24gaGFzIHN0YXJ0ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJlYW1pbmdNb2RlID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzLnJvd1RvUGFja2V0VHJhbnNmb3JtO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ2NhbmNlbCcpO1xuICB9XG59XG5cbmxldCBhZGRSb3dEZXByZWNhdGlvbldhcm5pbmdFbWl0dGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbWl0QWRkUm93RGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICBpZiAoYWRkUm93RGVwcmVjYXRpb25XYXJuaW5nRW1pdHRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFkZFJvd0RlcHJlY2F0aW9uV2FybmluZ0VtaXR0ZWQgPSB0cnVlO1xuXG4gIHByb2Nlc3MuZW1pdFdhcm5pbmcoXG4gICAgJ1RoZSBCdWxrTG9hZC5hZGRSb3cgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBwcm92aWRlIHRoZSByb3cgZGF0YSBmb3IgJyArXG4gICAgJ3RoZSBidWxrIGxvYWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBDb25uZWN0aW9uLmV4ZWNCdWxrTG9hZCBpbnN0ZWFkLicsXG4gICAgJ0RlcHJlY2F0aW9uV2FybmluZycsXG4gICAgQnVsa0xvYWQucHJvdG90eXBlLmFkZFJvd1xuICApO1xufVxuXG5sZXQgZ2V0Um93U3RyZWFtRGVwcmVjYXRpb25XYXJuaW5nRW1pdHRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW1pdEdldFJvd1N0cmVhbURlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgaWYgKGdldFJvd1N0cmVhbURlcHJlY2F0aW9uV2FybmluZ0VtaXR0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBnZXRSb3dTdHJlYW1EZXByZWNhdGlvbldhcm5pbmdFbWl0dGVkID0gdHJ1ZTtcblxuICBwcm9jZXNzLmVtaXRXYXJuaW5nKFxuICAgICdUaGUgQnVsa0xvYWQuZ2V0Um93U3RyZWFtIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBZb3UgY2FuIHBhc3MgYW4gSXRlcmFibGUsIEFzeW5jSXRlcmFibGUgb3IgJyArXG4gICAgJ3N0cmVhbS5SZWFkYWJsZSBvYmplY3QgY29udGFpbmluZyB0aGUgcm93IGRhdGEgYXMgYSBzZWNvbmQgYXJndW1lbnQgdG8gQ29ubmVjdGlvbi5leGVjQnVsa0xvYWQgaW5zdGVhZC4nLFxuICAgICdEZXByZWNhdGlvbldhcm5pbmcnLFxuICAgIEJ1bGtMb2FkLnByb3RvdHlwZS5nZXRSb3dTdHJlYW1cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnVsa0xvYWQ7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1bGtMb2FkO1xuIl19