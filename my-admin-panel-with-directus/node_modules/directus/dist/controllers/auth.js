"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const grant_1 = __importDefault(require("grant"));
const ms_1 = __importDefault(require("ms"));
const emitter_1 = __importStar(require("../emitter"));
const env_1 = __importDefault(require("../env"));
const exceptions_1 = require("../exceptions");
const grant_2 = __importDefault(require("../grant"));
const respond_1 = require("../middleware/respond");
const services_1 = require("../services");
const async_handler_1 = __importDefault(require("../utils/async-handler"));
const get_auth_providers_1 = require("../utils/get-auth-providers");
const get_email_from_profile_1 = __importDefault(require("../utils/get-email-from-profile"));
const utils_1 = require("@directus/shared/utils");
const logger_1 = __importDefault(require("../logger"));
const drivers_1 = require("../auth/drivers");
const constants_1 = require("../constants");
const router = (0, express_1.Router)();
const authProviders = (0, get_auth_providers_1.getAuthProviders)();
for (const authProvider of authProviders) {
    let authRouter;
    switch (authProvider.driver) {
        case 'local':
            authRouter = (0, drivers_1.createLocalAuthRouter)(authProvider.name);
    }
    if (!authRouter) {
        logger_1.default.warn(`Couldn't create login router for auth provider "${authProvider.name}"`);
        continue;
    }
    router.use(`/login/${authProvider.name}`, authRouter);
}
router.use('/login', (0, drivers_1.createLocalAuthRouter)(constants_1.DEFAULT_AUTH_PROVIDER));
router.post('/refresh', (0, async_handler_1.default)(async (req, res, next) => {
    var _a;
    const accountability = {
        ip: req.ip,
        userAgent: req.get('user-agent'),
        role: null,
    };
    const authenticationService = new services_1.AuthenticationService({
        accountability: accountability,
        schema: req.schema,
    });
    const currentRefreshToken = req.body.refresh_token || req.cookies[env_1.default.REFRESH_TOKEN_COOKIE_NAME];
    if (!currentRefreshToken) {
        throw new exceptions_1.InvalidPayloadException(`"refresh_token" is required in either the JSON payload or Cookie`);
    }
    const mode = req.body.mode || (req.body.refresh_token ? 'json' : 'cookie');
    const { accessToken, refreshToken, expires } = await authenticationService.refresh(currentRefreshToken);
    const payload = {
        data: { access_token: accessToken, expires },
    };
    if (mode === 'json') {
        payload.data.refresh_token = refreshToken;
    }
    if (mode === 'cookie') {
        res.cookie(env_1.default.REFRESH_TOKEN_COOKIE_NAME, refreshToken, {
            httpOnly: true,
            domain: env_1.default.REFRESH_TOKEN_COOKIE_DOMAIN,
            maxAge: (0, ms_1.default)(env_1.default.REFRESH_TOKEN_TTL),
            secure: (_a = env_1.default.REFRESH_TOKEN_COOKIE_SECURE) !== null && _a !== void 0 ? _a : false,
            sameSite: env_1.default.REFRESH_TOKEN_COOKIE_SAME_SITE || 'strict',
        });
    }
    res.locals.payload = payload;
    return next();
}), respond_1.respond);
router.post('/logout', (0, async_handler_1.default)(async (req, res, next) => {
    var _a;
    const accountability = {
        ip: req.ip,
        userAgent: req.get('user-agent'),
        role: null,
    };
    const authenticationService = new services_1.AuthenticationService({
        accountability: accountability,
        schema: req.schema,
    });
    const currentRefreshToken = req.body.refresh_token || req.cookies[env_1.default.REFRESH_TOKEN_COOKIE_NAME];
    if (!currentRefreshToken) {
        throw new exceptions_1.InvalidPayloadException(`"refresh_token" is required in either the JSON payload or Cookie`);
    }
    await authenticationService.logout(currentRefreshToken);
    if (req.cookies[env_1.default.REFRESH_TOKEN_COOKIE_NAME]) {
        res.clearCookie(env_1.default.REFRESH_TOKEN_COOKIE_NAME, {
            httpOnly: true,
            domain: env_1.default.REFRESH_TOKEN_COOKIE_DOMAIN,
            secure: (_a = env_1.default.REFRESH_TOKEN_COOKIE_SECURE) !== null && _a !== void 0 ? _a : false,
            sameSite: env_1.default.REFRESH_TOKEN_COOKIE_SAME_SITE || 'strict',
        });
    }
    return next();
}), respond_1.respond);
router.post('/password/request', (0, async_handler_1.default)(async (req, res, next) => {
    if (typeof req.body.email !== 'string') {
        throw new exceptions_1.InvalidPayloadException(`"email" field is required.`);
    }
    const accountability = {
        ip: req.ip,
        userAgent: req.get('user-agent'),
        role: null,
    };
    const service = new services_1.UsersService({ accountability, schema: req.schema });
    try {
        await service.requestPasswordReset(req.body.email, req.body.reset_url || null);
        return next();
    }
    catch (err) {
        if (err instanceof exceptions_1.InvalidPayloadException) {
            throw err;
        }
        else {
            logger_1.default.warn(err, `[email] ${err}`);
            return next();
        }
    }
}), respond_1.respond);
router.post('/password/reset', (0, async_handler_1.default)(async (req, res, next) => {
    if (typeof req.body.token !== 'string') {
        throw new exceptions_1.InvalidPayloadException(`"token" field is required.`);
    }
    if (typeof req.body.password !== 'string') {
        throw new exceptions_1.InvalidPayloadException(`"password" field is required.`);
    }
    const accountability = {
        ip: req.ip,
        userAgent: req.get('user-agent'),
        role: null,
    };
    const service = new services_1.UsersService({ accountability, schema: req.schema });
    await service.resetPassword(req.body.token, req.body.password);
    return next();
}), respond_1.respond);
router.get('/', (0, async_handler_1.default)(async (req, res, next) => {
    res.locals.payload = { data: (0, get_auth_providers_1.getAuthProviders)() };
    return next();
}), respond_1.respond);
router.get('/oauth', (0, async_handler_1.default)(async (req, res, next) => {
    const providers = (0, utils_1.toArray)(env_1.default.OAUTH_PROVIDERS);
    res.locals.payload = { data: env_1.default.OAUTH_PROVIDERS ? providers : null };
    return next();
}), respond_1.respond);
router.get('/oauth/:provider', (0, async_handler_1.default)(async (req, res, next) => {
    var _a, _b;
    const config = { ...grant_2.default };
    delete config.defaults;
    const availableProviders = Object.keys(config);
    if (availableProviders.includes(req.params.provider) === false) {
        throw new exceptions_1.RouteNotFoundException(`/auth/oauth/${req.params.provider}`);
    }
    if (((_a = req.query) === null || _a === void 0 ? void 0 : _a.redirect) && req.session) {
        req.session.redirect = req.query.redirect;
    }
    const hookPayload = {
        provider: req.params.provider,
        redirect: (_b = req.query) === null || _b === void 0 ? void 0 : _b.redirect,
    };
    (0, emitter_1.emitAsyncSafe)(`oauth.${req.params.provider}.redirect`, {
        event: `oauth.${req.params.provider}.redirect`,
        action: 'redirect',
        schema: req.schema,
        payload: hookPayload,
        accountability: req.accountability,
        user: null,
    });
    await emitter_1.default.emitAsync(`oauth.${req.params.provider}.redirect.before`, {
        event: `oauth.${req.params.provider}.redirect.before`,
        action: 'redirect',
        schema: req.schema,
        payload: hookPayload,
        accountability: req.accountability,
        user: null,
    });
    next();
}));
router.use(grant_1.default.express()(grant_2.default));
router.get('/oauth/:provider/callback', (0, async_handler_1.default)(async (req, res, next) => {
    var _a, _b, _c;
    const redirect = req.session.redirect;
    const accountability = {
        ip: req.ip,
        userAgent: req.get('user-agent'),
        role: null,
    };
    const authenticationService = new services_1.AuthenticationService({
        accountability: accountability,
        schema: req.schema,
    });
    let authResponse;
    const hookPayload = req.session.grant.response;
    await emitter_1.default.emitAsync(`oauth.${req.params.provider}.login.before`, hookPayload, {
        event: `oauth.${req.params.provider}.login.before`,
        action: 'oauth.login',
        schema: req.schema,
        payload: hookPayload,
        accountability: accountability,
        status: 'pending',
        user: null,
    });
    const emitStatus = (status) => {
        (0, emitter_1.emitAsyncSafe)(`oauth.${req.params.provider}.login`, hookPayload, {
            event: `oauth.${req.params.provider}.login`,
            action: 'oauth.login',
            schema: req.schema,
            payload: hookPayload,
            accountability: accountability,
            status,
            user: null,
        });
    };
    try {
        const email = (0, get_email_from_profile_1.default)(req.params.provider, (_a = req.session.grant.response) === null || _a === void 0 ? void 0 : _a.profile);
        (_b = req.session) === null || _b === void 0 ? void 0 : _b.destroy(() => {
            // Do nothing
        });
        // Workaround to use the default local auth provider to validate
        // the email and login without a password.
        authResponse = await authenticationService.login(constants_1.DEFAULT_AUTH_PROVIDER, { email });
    }
    catch (error) {
        emitStatus('fail');
        logger_1.default.warn(error);
        if (redirect) {
            let reason = 'UNKNOWN_EXCEPTION';
            if (error instanceof exceptions_1.ServiceUnavailableException) {
                reason = 'SERVICE_UNAVAILABLE';
            }
            else if (error instanceof exceptions_1.InvalidCredentialsException) {
                reason = 'INVALID_USER';
            }
            return res.redirect(`${redirect.split('?')[0]}?reason=${reason}`);
        }
        throw error;
    }
    const { accessToken, refreshToken, expires } = authResponse;
    emitStatus('success');
    if (redirect) {
        res.cookie(env_1.default.REFRESH_TOKEN_COOKIE_NAME, refreshToken, {
            httpOnly: true,
            domain: env_1.default.REFRESH_TOKEN_COOKIE_DOMAIN,
            maxAge: (0, ms_1.default)(env_1.default.REFRESH_TOKEN_TTL),
            secure: (_c = env_1.default.REFRESH_TOKEN_COOKIE_SECURE) !== null && _c !== void 0 ? _c : false,
            sameSite: env_1.default.REFRESH_TOKEN_COOKIE_SAME_SITE || 'strict',
        });
        return res.redirect(redirect);
    }
    else {
        res.locals.payload = {
            data: { access_token: accessToken, refresh_token: refreshToken, expires },
        };
        return next();
    }
}), respond_1.respond);
exports.default = router;
